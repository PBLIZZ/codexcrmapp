{
  "master": {
    "tasks": [
      {
        "id": 209,
        "title": "Update Supabase Auth Integration for Name Collection",
        "description": "Modify the Supabase authentication integration to collect and store the user's name during sign-up.",
        "details": "1. Update the sign-up function to include the name field in the metadata:\n```tsx\nconst handleSignUp = async (e) => {\n  e.preventDefault();\n  setLoading(true);\n  \n  try {\n    const { data, error } = await supabase.auth.signUp({\n      email,\n      password,\n      options: {\n        data: {\n          full_name: name // Store name in user metadata\n        }\n      }\n    });\n    \n    if (error) throw error;\n    // Handle successful sign-up\n  } catch (error) {\n    // Handle error\n  } finally {\n    setLoading(false);\n  }\n};\n```\n\n2. Verify that the name is being stored in `auth.users.raw_user_meta_data`\n\n3. If using a separate profiles table, ensure that the database trigger is properly set up to copy the name from `raw_user_meta_data` to the profiles table\n\n4. Test the flow to ensure the name is properly stored and accessible in the user's profile",
        "testStrategy": "1. Test the sign-up process with a name provided\n2. Verify in the Supabase dashboard that the name is stored in user metadata\n3. Check that any database triggers correctly copy the name to the profiles table if applicable\n4. Test retrieving and displaying the user's name after sign-up\n5. Test with various name formats (short, long, with special characters, etc.)",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 210,
        "title": "Refactor codebase for TanStack Query v5 and tRPC v11 compatibility",
        "description": "Update application code to align with API changes and best practices for TanStack Query v5 and tRPC v11. This includes addressing breaking changes in how queries, mutations, and tRPC procedures are defined and used throughout the application.",
        "details": "1. Review official tRPC v10 to v11 migration guides.\n2. Review official TanStack Query v4 to v5 migration guides.\n3. Update tRPC client setup in `apps/web` (e.g., `src/lib/trpc/client.ts`, `QueryClient` instantiation, `QueryClientProvider`).\n4. Update tRPC server setup in `packages/server` (e.g., `src/root.ts`, `src/trpc.ts`, `src/context.ts`).\n5. Refactor tRPC procedure definitions in all routers (`packages/server/src/routers/*`) for v11 compatibility.\n6. Update the usage of tRPC hooks (`useQuery`, `useMutation`, etc.) in all client components in `apps/web` to conform to TanStack Query v5 and tRPC v11 APIs.\n7. Address changes in query/mutation options, hook return values, and error handling.\n8. Ensure data fetching, caching, and cache invalidation mechanisms are working correctly with the new versions.\n9. Resolve any TypeScript errors and runtime issues arising from these upgrades.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [191],
        "priority": "critical",
        "subtasks": [
          {
            "id": 1,
            "title": "Review and Install Required Package Versions",
            "description": "Audit the current dependencies and upgrade all relevant packages to TanStack Query v5 and tRPC v11, ensuring compatibility across the codebase.",
            "dependencies": [],
            "details": "Follow the official migration guides to install @tanstack/react-query@^5, @trpc/server@^11, @trpc/client@^11, and related packages. Verify that all peer dependencies are satisfied and remove deprecated packages if necessary.",
            "status": "done",
            "testStrategy": "Run 'npm install' or equivalent, then verify that the application builds and starts without dependency errors."
          },
          {
            "id": 2,
            "title": "Update tRPC Client and Server Configuration",
            "description": "Refactor both client and server tRPC setup files to align with v11 API changes, including transformers, links, and context handling.",
            "dependencies": [1],
            "details": "Update files such as 'apps/web/src/lib/trpc/client.ts', 'packages/server/src/root.ts', 'src/trpc.ts', and 'src/context.ts' to use the new configuration patterns. Address deprecations like 'createTRPCProxyClient' and move transformers to links as required.",
            "status": "done",
            "testStrategy": "Write unit tests for client and server initialization. Confirm that API requests succeed and context is correctly passed."
          },
          {
            "id": 3,
            "title": "Refactor tRPC Procedure and Router Definitions",
            "description": "Update all tRPC procedure and router definitions to comply with v11 syntax and best practices.",
            "dependencies": [2],
            "details": "Modify all routers in 'packages/server/src/routers/*' to use the new procedure definition patterns. Address any breaking changes in how procedures are created, composed, or exported.",
            "status": "done",
            "testStrategy": "Run and expand existing API integration tests to ensure all endpoints behave as expected."
          },
          {
            "id": 4,
            "title": "Update Client-Side Query and Mutation Usage",
            "description": "Refactor all usages of tRPC hooks and TanStack Query hooks in client components to match the new APIs and handle updated return values and options.",
            "dependencies": [3],
            "details": "Update all usages of 'useQuery', 'useMutation', and related hooks in 'apps/web' to match TanStack Query v5 and tRPC v11. Adjust for changes in hook signatures, options, and error handling.\n<info added on 2025-06-06T16:09:39.397Z>\nSuccessfully migrated all mutation status checks from 'isLoading' to 'isPending' property in client components ('apps/web'), resolving TypeScript errors and addressing TanStack Query v5's mutation return type changes. Verified build success post-refactor.\n</info added on 2025-06-06T16:09:39.397Z>",
            "status": "done",
            "testStrategy": "Manually test key user flows and write component tests to verify correct data fetching, error handling, and UI updates."
          },
          {
            "id": 5,
            "title": "Validate Data Fetching, Caching, and Error Handling",
            "description": "Ensure that data fetching, caching, cache invalidation, and error handling mechanisms work correctly with the upgraded libraries.",
            "dependencies": [4],
            "details": "Test all major data flows, including cache updates and invalidation. Resolve any TypeScript or runtime errors that arise from the migration.",
            "status": "in-progress",
            "testStrategy": "Perform end-to-end tests and regression testing. Use development tools to inspect cache state and error boundaries."
          }
        ]
      },
      {
        "id": 211,
        "title": "Fix, Centralize, and Standardize Logout Functionality",
        "description": "Consolidate all sign-out functionality into a single component and standardize all terminology from 'Sign Out' to 'Logout'. This will resolve a critical bug (TRPCClientError: UNAUTHORIZED) and enforce consistent naming conventions (Login/Logout/Signup) across the application.",
        "details": "The primary goal is to fix a logout race condition by using a Server Action that handles session invalidation and an immediate server-side redirect. As part of this fix, all related code—components, functions, variables, and user-facing text—will be refactored from 'Sign Out' or 'signout' to 'Logout'. This will create a single, robust, and consistently named `LogoutButton` component.",
        "testStrategy": "Verify that logging out from all application entry points redirects the user to the login page without any console errors. Confirm that all user-facing text, component names, and function names have been updated from 'Sign Out' to 'Logout'.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement the `logout` Server Action",
            "description": "Create a dedicated Server Action named `logout` that securely signs the user out and performs an immediate server-side redirect to the login page.",
            "details": "",
            "status": "pending",
            "dependencies": [],
            "parentTaskId": 211
          },
          {
            "id": 2,
            "title": "Create a Reusable `LogoutButton` Component",
            "description": "Develop a form-based client component named `LogoutButton` that triggers the `logout` Server Action. It should be styled with Shadcn UI and manage its own pending state.",
            "details": "",
            "status": "pending",
            "dependencies": ["211.1"],
            "parentTaskId": 211
          },
          {
            "id": 3,
            "title": "Integrate `LogoutButton` into all UI Surfaces",
            "description": "Replace existing sign-out logic and buttons in the main navigation's user dropdown and the account settings page with the new reusable `LogoutButton` component.",
            "details": "",
            "status": "pending",
            "dependencies": ["211.2"],
            "parentTaskId": 211
          },
          {
            "id": 4,
            "title": "Standardize All Terminology to 'Logout'",
            "description": "Perform a comprehensive, case-insensitive search across the entire codebase for 'Sign Out' and 'signout', refactoring all instances (variables, comments, log messages, etc.) to 'Logout'.",
            "details": "",
            "status": "pending",
            "dependencies": ["211.3"],
            "parentTaskId": 211
          },
          {
            "id": 5,
            "title": "Remove Redundant Sign-Out Implementations",
            "description": "Audit the codebase to find and delete any old `SignOutButton` components, handler functions, or client-side API calls to ensure the new `logout` Server Action is the single source of truth.",
            "details": "",
            "status": "pending",
            "dependencies": ["211.4"],
            "parentTaskId": 211
          },
          {
            "id": 6,
            "title": "Final Verification and Validation",
            "description": "Thoroughly test the end-to-end logout flow from all entry points to confirm the TRPCClientError is resolved and the user experience is seamless and consistent.",
            "details": "",
            "status": "pending",
            "dependencies": ["211.5"],
            "parentTaskId": 211
          }
        ]
      },
      {
        "id": 212,
        "title": "Database Schema Refactoring for AI-Enhanced CRM",
        "description": "Refactor the Supabase database schema to support new features including contact enrichment, AI insights, and relationship tracking for wellness professionals.",
        "details": "Implement the following schema changes in Supabase:\n\n1. Enhance contacts table with additional fields for wellness journey tracking\n2. Create contact_profiles table for extended profile information\n3. Create sessions table for tracking client interactions\n4. Create ai_actions table to track AI-generated suggestions and approval status\n5. Create notes table with structure for AI analysis and tagging\n6. Implement proper relationships and foreign keys between tables\n7. Set up appropriate indexes for performance optimization\n\nImplementation details:\n- Use Supabase migrations for schema changes (npx supabase migration new ...)\n- Define TypeScript types for all database entities\n- Implement Row Level Security (RLS) policies for data protection\n- Set up appropriate triggers for maintaining data integrity\n- Use Supabase's PostgREST API for efficient querying\n\nExample schema for ai_actions table:\n```sql\nCREATE TABLE ai_actions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) NOT NULL,\n  contact_id UUID REFERENCES contacts(id),\n  action_type TEXT NOT NULL,\n  suggestion TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'pending',\n  feedback TEXT,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```",
        "testStrategy": "1. Write unit tests for database schema validation using Supabase's JavaScript client\n2. Test data integrity with sample data insertion and relationship validation\n3. Verify RLS policies work correctly for different user roles\n4. Performance testing for common queries to ensure proper indexing\n5. Validate type definitions against actual database schema\n6. Test migration scripts in a staging environment before production deployment",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Core Database Schema Structure",
            "description": "Create comprehensive database schema design with all tables, relationships, constraints, and indexing strategy for the application entities",
            "dependencies": [],
            "details": "Define primary tables (users, profiles, posts, comments, etc.), establish foreign key relationships, design composite indexes for query optimization, and create entity relationship diagrams. Include data types, constraints, and normalization considerations.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Create Database Migration Scripts",
            "description": "Develop sequential migration scripts to create all database tables, indexes, and constraints in the correct order",
            "dependencies": [1],
            "details": "Write SQL migration files for table creation, foreign key establishment, index creation, and initial data seeding. Ensure migrations are reversible and handle dependency order correctly. Include version control and rollback capabilities.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Implement Row Level Security (RLS) Policies",
            "description": "Create and configure RLS policies for each table to ensure proper data access control and security",
            "dependencies": [2],
            "details": "Define RLS policies for user data isolation, role-based access control, and data privacy. Implement policies for SELECT, INSERT, UPDATE, and DELETE operations. Test policy effectiveness and performance impact.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Generate TypeScript Type Definitions",
            "description": "Create comprehensive TypeScript interfaces and types that match the database schema structure",
            "dependencies": [2],
            "details": "Generate TypeScript interfaces for each database table, including optional fields, relationships, and computed properties. Create union types for enums, utility types for partial updates, and ensure type safety across the application.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Create Database Query Helpers and Utilities",
            "description": "Develop reusable database query functions, connection utilities, and ORM configuration for each entity",
            "dependencies": [3, 4],
            "details": "Build typed query builders, CRUD operation helpers, transaction utilities, and connection pooling configuration. Include error handling, query optimization, and logging mechanisms for database operations.",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Validate Schema Integration and Performance Testing",
            "description": "Conduct comprehensive testing of the database schema, migrations, RLS policies, and TypeScript integration",
            "dependencies": [5],
            "details": "Execute integration tests for all database operations, validate RLS policy enforcement, test migration rollbacks, verify TypeScript type accuracy, and conduct performance benchmarking. Include load testing and query optimization validation.",
            "status": "done"
          }
        ]
      },
      {
        "id": 213,
        "title": "Implement Core UI Component Library with Tailwind and Shadcn",
        "description": "Develop a comprehensive set of reusable UI components using Tailwind CSS and Shadcn UI components that adhere to the wellness aesthetic defined in the PRD.",
        "details": "Create a component library with the following elements:\n\n1. Configure Tailwind CSS with the wellness-focused color palette (Teal primary, Orange accent)\n2. Set up Shadcn UI components with custom theming\n3. Create the following custom components:\n   - Metric cards with visual indicators\n   - Contact detail cards with tabbed interface\n   - Timeline visualization component\n   - Task cards with priority indicators\n   - AI suggestion components with approval workflow UI\n   - Module-specific sidebars\n   - Quick action button groups\n\nImplementation details:\n- Use Tailwind CSS v3.3+ for styling\n- Implement Shadcn UI v0.4+ components with custom theming\n- Create a theme configuration file for consistent styling\n- Use CSS variables for theming to support future dark mode\n- Implement responsive designs for all components\n- Use React Server Components where appropriate for Next.js optimization\n\nExample component structure:\n```tsx\n// components/ui/MetricCard.tsx\nimport React from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\nimport { cn } from '@/lib/utils';\n\ninterface MetricCardProps {\n  title: string;\n  value: string | number;\n  trend?: 'up' | 'down' | 'neutral';\n  icon?: React.ReactNode;\n  className?: string;\n}\n\nexport function MetricCard({ title, value, trend = 'neutral', icon, className }: MetricCardProps) {\n  return (\n    <Card className={cn('overflow-hidden', className)}>\n      <CardHeader className=\"flex flex-row items-center justify-between pb-2\">\n        <CardTitle className=\"text-sm font-medium\">{title}</CardTitle>\n        {icon && <div className=\"h-4 w-4 text-muted-foreground\">{icon}</div>}\n      </CardHeader>\n      <CardContent>\n        <div className=\"text-2xl font-bold\">{value}</div>\n        {trend && (\n          <p className={cn(\n            \"text-xs\",\n            trend === 'up' && \"text-green-500\",\n            trend === 'down' && \"text-red-500\"\n          )}>\n            {trend === 'up' && '↑'}\n            {trend === 'down' && '↓'}\n            {trend === 'neutral' && '→'}\n          </p>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Create Storybook stories for each component to visualize and test in isolation\n2. Implement component unit tests using React Testing Library\n3. Test responsive behavior using viewport simulation\n4. Accessibility testing using axe-core or similar tools\n5. Visual regression testing to ensure consistent styling\n6. Cross-browser compatibility testing\n7. Performance testing for component rendering efficiency",
        "priority": "high",
        "dependencies": ["222", "223"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Tailwind CSS Configuration Setup",
            "description": "Configure Tailwind CSS with custom design tokens, color palette, typography scales, spacing system, and breakpoints for the component library foundation",
            "dependencies": [],
            "details": "Set up tailwind.config.js with custom theme extensions, configure content paths, add custom utilities, and establish design system tokens including colors, fonts, shadows, and animations",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Shadcn/ui Integration and Base Setup",
            "description": "Initialize Shadcn/ui components library, configure components.json, and set up the base component architecture with proper TypeScript support",
            "dependencies": [1],
            "details": "Install and configure Shadcn/ui CLI, set up components directory structure, configure path aliases, and establish base component patterns with proper typing",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Custom Theming System Implementation",
            "description": "Create a comprehensive theming system with light/dark mode support, CSS custom properties, and theme context providers",
            "dependencies": [1, 2],
            "details": "Implement theme provider with React context, create CSS custom properties for dynamic theming, set up theme switching functionality, and establish theme-aware component patterns",
            "status": "done"
          },
          {
            "id": 4,
            "title": "MetricCard Component Development",
            "description": "Build reusable MetricCard component with variants for different data visualization needs, including charts, progress indicators, and statistical displays",
            "dependencies": [2, 3],
            "details": "Create MetricCard with props for title, value, trend indicators, optional charts, loading states, and multiple size variants with proper TypeScript interfaces",
            "status": "done"
          },
          {
            "id": 5,
            "title": "ContactCard Component Development",
            "description": "Develop ContactCard component with avatar support, contact information display, action buttons, and various layout options",
            "dependencies": [2, 3],
            "details": "Build ContactCard with avatar handling, contact details layout, action buttons (call, email, message), status indicators, and responsive design patterns",
            "status": "done"
          },
          {
            "id": 6,
            "title": "Additional Core Components Creation",
            "description": "Develop remaining essential components including navigation elements, form components, data display components, and utility components",
            "dependencies": [2, 3],
            "details": "Create components like DataTable, FormField, Modal, Dropdown, Tabs, Accordion, and other foundational UI elements with consistent styling and behavior patterns",
            "status": "done"
          },
          {
            "id": 7,
            "title": "Responsive Design Implementation",
            "description": "Implement comprehensive responsive design patterns across all components with mobile-first approach and adaptive layouts",
            "dependencies": [4, 5, 6],
            "details": "Apply responsive design principles to all components, implement mobile-first CSS, create adaptive layouts, test across different screen sizes, and optimize touch interactions",
            "status": "done"
          },
          {
            "id": 8,
            "title": "Storybook Documentation Setup",
            "description": "Configure Storybook for component documentation, create comprehensive stories for all components, and establish design system documentation",
            "dependencies": [7],
            "details": "Set up Storybook with proper addons, create stories for each component with all variants and states, document component APIs, add design tokens documentation, and create usage guidelines",
            "status": "done"
          }
        ]
      },
      {
        "id": 214,
        "title": "Develop Dashboard Module with Business Health Visualization",
        "description": "Implement the dashboard module that serves as the practitioner's 'second brain' with business health visualization, upcoming activities, and AI task delegation panel.",
        "details": "Create a comprehensive dashboard with the following features:\n\n1. Business health visualization cards showing:\n   - Upcoming sessions counter with time-based grouping\n   - Retention risk indicators based on client engagement\n   - Goal progress tracking for retreats, workshops, and conversions\n2. AI task delegation panel with approval workflow\n3. Calendar integration preview showing today's and upcoming appointments\n4. Quick action buttons for common tasks\n5. Wellness-specific metrics display\n\nImplementation details:\n- Use Next.js App Router for page structure\n- Implement React Server Components for static parts and Client Components for interactive elements\n- Use tRPC procedures to fetch dashboard data\n- Implement data fetching with SWR or React Query for real-time updates\n- Create responsive grid layout using Tailwind CSS grid system\n- Use Chart.js or Recharts for data visualization\n\nExample dashboard layout:\n```tsx\n// app/dashboard/page.tsx\nimport { Suspense } from 'react';\nimport { MetricCard } from '@codexcrm/ui/components/ui/metric-card';\nimport { CalendarPreview } from '@/components/dashboard/calendar-preview';\nimport { AiTaskPanel } from '@/components/dashboard/ai-task-panel';\nimport { QuickActions } from '@/components/dashboard/quick-actions';\nimport { BusinessMetrics } from '@/components/dashboard/business-metrics';\nimport { DashboardSkeleton } from '@/components/skeletons/dashboard-skeleton';\n\nexport default function DashboardPage() {\n  return (\n    <div className=\"container mx-auto p-6\">\n      <h1 className=\"text-3xl font-bold mb-6\">Dashboard</h1>\n      \n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 mb-6\">\n        <Suspense fallback={<DashboardSkeleton />}>\n          <BusinessMetrics />\n        </Suspense>\n      </div>\n      \n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n        <div className=\"md:col-span-2\">\n          <Suspense fallback={<DashboardSkeleton />}>\n            <AiTaskPanel />\n          </Suspense>\n        </div>\n        <div>\n          <Suspense fallback={<DashboardSkeleton />}>\n            <CalendarPreview />\n          </Suspense>\n          <QuickActions className=\"mt-6\" />\n        </div>\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Unit tests for individual dashboard components using React Testing Library\n2. Integration tests for data fetching with tRPC mocks\n3. End-to-end tests using Playwright or Cypress to verify dashboard functionality\n4. Performance testing for initial load and data refresh\n5. Responsive design testing across different viewport sizes\n6. Accessibility testing for all dashboard components\n7. User acceptance testing with wellness professionals to validate usefulness of metrics",
        "priority": "medium",
        "dependencies": ["212", "213", "224", "225"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Business Metrics Calculation",
            "description": "Implement core business metrics calculation engine including revenue tracking, user engagement metrics, conversion rates, and performance KPIs with real-time data processing capabilities",
            "dependencies": [],
            "details": "Create calculation functions for key business metrics, implement data aggregation logic, set up real-time metric updates, and establish metric validation rules",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Chart Implementation",
            "description": "Develop interactive data visualization components using charting libraries to display business metrics through various chart types including line graphs, bar charts, and pie charts",
            "dependencies": [1],
            "details": "Integrate charting library, create reusable chart components, implement interactive features like tooltips and zoom, and ensure charts update with real-time data",
            "status": "done"
          },
          {
            "id": 3,
            "title": "AI Task Panel",
            "description": "Build an intelligent task management panel that uses AI to prioritize tasks, suggest optimizations, and provide automated insights based on business metrics and user behavior",
            "dependencies": [1],
            "details": "Implement AI-powered task prioritization algorithms, create task suggestion engine, build interactive task management interface, and integrate with business metrics for intelligent recommendations",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Calendar Integration",
            "description": "Integrate calendar functionality to sync with business events, deadlines, and scheduled tasks while connecting with external calendar services and providing scheduling automation",
            "dependencies": [3],
            "details": "Implement calendar API integrations, create event synchronization logic, build calendar UI components, and establish automated scheduling based on AI task recommendations",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Responsive Layout Creation",
            "description": "Design and implement responsive layout system that adapts to different screen sizes while maintaining optimal user experience across all components including charts, metrics, and calendar views",
            "dependencies": [2, 3, 4],
            "details": "Create responsive grid system, implement mobile-first design approach, optimize component layouts for various screen sizes, and establish proper data fetching strategies for different devices",
            "status": "done"
          }
        ]
      },
      {
        "id": 215,
        "title": "Implement Contact Relationship Hub with Timeline Visualization",
        "description": "Develop the Contact Relationship Hub module with enhanced contact list, detailed contact cards, wellness journey timelines, and AI-powered relationship insights.",
        "details": "Create a comprehensive contact management system with the following features:\n\n1. Enhanced contact list with:\n   - Customizable columns\n   - Bulk actions\n   - Advanced filtering and sorting\n   - Quick action buttons\n2. Detailed contact cards with:\n   - Wellness journey timeline visualization\n   - Session history with note-taking capabilities\n   - Client-submitted media integration placeholder\n   - Referral tracking visualization\n3. AI-powered relationship insights panel\n4. Group management interface\n5. Quick email/message composers\n\nImplementation details:\n- Use TanStack Table v8+ for the contact list with advanced features\n- Implement virtualized lists for performance with large contact databases\n- Create a timeline visualization component using a custom React component\n- Use tRPC procedures for data fetching with proper pagination\n- Implement optimistic UI updates for better user experience\n- Use React Hook Form for quick message composers\n\nExample contact list implementation:\n```tsx\n// components/contacts/ContactList.tsx\nimport { useState } from 'react';\nimport {\n  useReactTable,\n  getCoreRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  getFilteredRowModel,\n  ColumnDef,\n  flexRender,\n} from '@tanstack/react-table';\nimport { trpc } from '@/lib/trpc';\n\nexport function ContactList() {\n  const [sorting, setSorting] = useState([]);\n  const [columnFilters, setColumnFilters] = useState([]);\n  const [pagination, setPagination] = useState({ pageIndex: 0, pageSize: 20 });\n  \n  const { data, isLoading } = trpc.contacts.list.useQuery({\n    page: pagination.pageIndex,\n    limit: pagination.pageSize,\n    filters: columnFilters,\n    sorting,\n  });\n  \n  const columns = [\n    // Define columns here\n  ];\n  \n  const table = useReactTable({\n    data: data?.contacts || [],\n    columns,\n    state: {\n      sorting,\n      columnFilters,\n      pagination,\n    },\n    onSortingChange: setSorting,\n    onColumnFiltersChange: setColumnFilters,\n    onPaginationChange: setPagination,\n    getCoreRowModel: getCoreRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    manualPagination: true,\n    pageCount: data?.pageCount || 0,\n  });\n  \n  // Render table UI\n}\n```",
        "testStrategy": "1. Unit tests for contact list filtering, sorting, and pagination\n2. Integration tests for contact data fetching and manipulation\n3. Component tests for timeline visualization with sample data\n4. End-to-end tests for contact creation, editing, and deletion workflows\n5. Performance testing with large datasets (1000+ contacts)\n6. Accessibility testing for all contact management interfaces\n7. Visual regression tests for timeline visualization\n8. User acceptance testing with wellness professionals to validate the relationship-focused approach",
        "priority": "high",
        "dependencies": ["212", "213", "226", "227"],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Contact List Table Implementation",
            "description": "Develop a comprehensive contact list table with advanced features including column sorting, resizing, virtual scrolling, bulk selection, and inline editing capabilities",
            "dependencies": [],
            "details": "Create a data table component with features like sortable columns, column reordering, row selection, pagination, search functionality, and support for custom cell renderers. Implement virtual scrolling for performance with large datasets.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Timeline Visualization Component",
            "description": "Build a custom timeline component to display contact interaction history, communication events, and relationship progression over time",
            "dependencies": [],
            "details": "Design and implement an interactive timeline with zoom capabilities, event markers, filtering by event types, and smooth animations. Support different view modes (daily, weekly, monthly) and event categorization.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Contact Detail Cards",
            "description": "Create detailed contact cards with comprehensive information display, edit modes, and relationship mapping",
            "dependencies": [1],
            "details": "Develop expandable contact cards showing personal information, communication history, tags, notes, and related contacts. Include quick action buttons, photo upload, and social media integration.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Filtering and Sorting System",
            "description": "Implement advanced filtering and sorting capabilities with multiple criteria, saved filters, and real-time search",
            "dependencies": [1],
            "details": "Build a comprehensive filtering system supporting multiple filter types (text, date ranges, tags, categories), boolean operators, saved filter presets, and dynamic search with autocomplete suggestions.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "AI Insights Integration",
            "description": "Integrate AI-powered features for contact analysis, relationship insights, communication suggestions, and predictive analytics",
            "dependencies": [1, 2, 3],
            "details": "Implement AI services for contact scoring, relationship strength analysis, communication pattern recognition, follow-up suggestions, and automated tagging. Include sentiment analysis and engagement predictions.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Performance Optimization for Large Datasets",
            "description": "Optimize application performance for handling large contact databases with efficient data loading, caching, and memory management",
            "dependencies": [1, 4],
            "details": "Implement lazy loading, data virtualization, efficient caching strategies, database indexing optimization, and memory leak prevention. Add performance monitoring and optimization for search and filter operations.",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "System Integration and Testing",
            "description": "Integrate all components, conduct comprehensive testing, and ensure seamless functionality across the entire contact management system",
            "dependencies": [1, 2, 3, 4, 5, 6],
            "details": "Perform integration testing, user acceptance testing, performance testing with large datasets, cross-browser compatibility testing, and accessibility compliance verification. Optimize component interactions and data flow.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 216,
        "title": "Develop Task Management System with Drag-and-Drop Functionality",
        "description": "Implement a drag-and-drop task organization system with AI-suggested tasks categorized by business area, including task prioritization based on business impact.",
        "details": "Create a comprehensive task management system with the following features:\n\n1. Task board with column layout (e.g., To Do, In Progress, Done)\n2. Drag-and-drop functionality for task organization\n3. Task cards with priority indicators and category labels\n4. Category filters for business areas (marketing, client follow-up, etc.)\n5. AI suggestion interface for task generation\n6. Task prioritization based on business impact\n\nImplementation details:\n- Use react-beautiful-dnd or @dnd-kit/core for drag-and-drop functionality\n- Implement optimistic UI updates for drag operations\n- Use tRPC procedures for task CRUD operations\n- Create a task suggestion algorithm based on business metrics\n- Implement task categorization system with color coding\n- Use React Context for managing task board state\n\nExample task board implementation:\n```tsx\n// components/tasks/TaskBoard.tsx\nimport { useState } from 'react';\nimport { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';\nimport { TaskCard } from '@/components/tasks/TaskCard';\nimport { trpc } from '@/lib/trpc';\n\nexport function TaskBoard() {\n  const [columns, setColumns] = useState({\n    'todo': { id: 'todo', title: 'To Do', taskIds: [] },\n    'in-progress': { id: 'in-progress', title: 'In Progress', taskIds: [] },\n    'done': { id: 'done', title: 'Done', taskIds: [] },\n  });\n  \n  const { data: tasks, isLoading } = trpc.tasks.list.useQuery();\n  const updateTaskMutation = trpc.tasks.update.useMutation();\n  \n  // Initialize columns with tasks from the server\n  useEffect(() => {\n    if (tasks) {\n      // Map tasks to columns\n    }\n  }, [tasks]);\n  \n  const onDragEnd = (result) => {\n    const { destination, source, draggableId } = result;\n    \n    if (!destination) return;\n    if (\n      destination.droppableId === source.droppableId &&\n      destination.index === source.index\n    ) return;\n    \n    // Update columns state\n    const startColumn = columns[source.droppableId];\n    const endColumn = columns[destination.droppableId];\n    \n    if (startColumn === endColumn) {\n      // Reordering within the same column\n    } else {\n      // Moving between columns\n    }\n    \n    // Update task status in the database\n    updateTaskMutation.mutate({\n      id: draggableId,\n      status: destination.droppableId,\n    });\n  };\n  \n  // Render board UI with DragDropContext, Droppable, and Draggable components\n}\n```",
        "testStrategy": "1. Unit tests for task state management logic\n2. Integration tests for task CRUD operations\n3. Component tests for drag-and-drop functionality using simulated drag events\n4. End-to-end tests for complete task workflows\n5. Performance testing with large numbers of tasks\n6. Accessibility testing for keyboard navigation of task board\n7. Visual regression tests for task cards and board layout\n8. User acceptance testing to validate task organization workflow",
        "priority": "medium",
        "dependencies": ["212", "213", "228"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Task Board Layout",
            "description": "Design and implement the overall layout structure for the task board including columns, headers, and responsive grid system",
            "dependencies": [],
            "details": "Create the foundational layout components including board container, column containers, column headers, and ensure responsive design across different screen sizes. Implement CSS Grid or Flexbox for proper alignment and spacing.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Task Card Components",
            "description": "Develop reusable task card components with proper styling, content display, and interaction states",
            "dependencies": [1],
            "details": "Build task card components that display task information, handle hover states, selection states, and provide visual feedback. Include task title, description, assignee, priority indicators, and action buttons.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "State Management",
            "description": "Implement centralized state management for task data, board state, and user interactions",
            "dependencies": [2],
            "details": "Set up state management system (Redux, Zustand, or Context API) to handle task data, board columns, drag states, loading states, and error handling. Implement actions and reducers for task operations.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Drag-and-Drop Implementation",
            "description": "Integrate drag-and-drop functionality using libraries like react-beautiful-dnd or dnd-kit for task movement",
            "dependencies": [3],
            "details": "Implement drag-and-drop functionality allowing users to move tasks between columns and reorder within columns. Handle drag start, drag over, and drop events with proper visual feedback and animations.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Backend Synchronization with Optimistic Updates",
            "description": "Implement real-time synchronization with backend API including optimistic updates and conflict resolution",
            "dependencies": [4],
            "details": "Set up API integration for task operations with optimistic updates for immediate UI feedback. Implement WebSocket or polling for real-time updates, error handling, rollback mechanisms, and conflict resolution for concurrent edits.",
            "status": "done"
          }
        ]
      },
      {
        "id": 217,
        "title": "Implement AI Assistant Integration with Natural Language Processing",
        "description": "Develop an AI co-pilot that assists with everyday CRM operations through natural language processing, including a global chat interface, command processing, and tRPC procedure mapping.",
        "details": "Create an AI assistant integration with the following features:\n\n1. Global chat interface accessible from any page\n2. Natural language command processing\n3. tRPC procedure mapping for executing CRM actions\n4. Contact enrichment background processing\n5. Email draft generation and assistance\n6. Approval workflow for critical actions\n\nImplementation details:\n- Integrate with a modern LLM API (OpenAI GPT-4, Anthropic Claude, or similar)\n- Create a persistent chat UI component with message history\n- Implement a command parser to translate natural language to CRM actions\n- Create a tRPC procedure mapper to execute actions based on parsed commands\n- Implement background processing for contact enrichment using Next.js API routes\n- Create an approval workflow UI for critical AI-suggested actions\n\nExample AI assistant implementation:\n```tsx\n// components/ai/AssistantChat.tsx\nimport { useState, useRef, useEffect } from 'react';\nimport { Button } from '@codexcrm/ui/components/ui/button';\nimport { Input } from '@codexcrm/ui/components/ui/input';\nimport { Card, CardContent } from '@codexcrm/ui/components/ui/card';\nimport { trpc } from '@/lib/trpc';\n\ntype Message = {\n  id: string;\n  role: 'user' | 'assistant';\n  content: string;\n  timestamp: Date;\n};\n\nexport function AssistantChat() {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState('');\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  \n  const sendMessageMutation = trpc.ai.sendMessage.useMutation({\n    onSuccess: (response) => {\n      setMessages(prev => [...prev, {\n        id: Date.now().toString(),\n        role: 'assistant',\n        content: response.message,\n        timestamp: new Date(),\n      }]);\n      \n      // Handle any actions returned by the AI\n      if (response.actions?.length) {\n        // Display action suggestions\n      }\n    }\n  });\n  \n  const handleSendMessage = () => {\n    if (!input.trim()) return;\n    \n    const userMessage: Message = {\n      id: Date.now().toString(),\n      role: 'user',\n      content: input,\n      timestamp: new Date(),\n    };\n    \n    setMessages(prev => [...prev, userMessage]);\n    setInput('');\n    \n    sendMessageMutation.mutate({\n      message: input,\n      context: {\n        currentPage: window.location.pathname,\n        // Additional context\n      }\n    });\n  };\n  \n  // Scroll to bottom when messages change\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n  \n  // Render chat UI\n}\n```\n\nBackend implementation for AI processing:\n```typescript\n// server/routers/ai.ts\nimport { z } from 'zod';\nimport { procedure, router } from '../trpc';\nimport { OpenAI } from 'openai';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport const aiRouter = router({\n  sendMessage: procedure\n    .input(z.object({\n      message: z.string(),\n      context: z.object({\n        currentPage: z.string(),\n        // Additional context schema\n      }).optional(),\n    }))\n    .mutation(async ({ input, ctx }) => {\n      // Process message with LLM\n      const completion = await openai.chat.completions.create({\n        model: \"gpt-4\",\n        messages: [\n          { role: \"system\", content: \"You are an AI assistant for a wellness professional CRM...\" },\n          { role: \"user\", content: input.message }\n        ],\n      });\n      \n      const response = completion.choices[0].message.content;\n      \n      // Parse for potential actions\n      const actions = parseActionsFromResponse(response);\n      \n      return {\n        message: response,\n        actions,\n      };\n    }),\n});\n```",
        "testStrategy": "1. Unit tests for AI message processing logic\n2. Integration tests for AI API communication\n3. Mock tests for tRPC procedure mapping\n4. End-to-end tests for complete conversation flows\n5. Performance testing for response times\n6. Security testing for user data handling\n7. User acceptance testing with sample queries and commands\n8. Regression testing when updating AI models or prompts",
        "priority": "high",
        "dependencies": ["212", "229"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "AI API Integration Setup",
            "description": "Integrate with AI service APIs (OpenAI, Anthropic, etc.) including authentication, rate limiting, error handling, and response parsing",
            "dependencies": [],
            "details": "Set up API clients, configure authentication tokens, implement retry logic, handle rate limits, parse AI responses, and establish fallback mechanisms for API failures",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Natural Language Command Parsing System",
            "description": "Build intelligent command parser that extracts intent, parameters, and context from natural language input",
            "dependencies": [1],
            "details": "Implement NLP preprocessing, intent classification, entity extraction, parameter validation, context awareness, and command disambiguation logic",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "tRPC Procedure Mapping Framework",
            "description": "Create dynamic mapping system between parsed commands and tRPC procedures with type safety and validation",
            "dependencies": [2],
            "details": "Build procedure registry, implement dynamic routing, ensure type safety, validate inputs/outputs, handle procedure discovery, and manage execution context",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Real-time Chat Interface",
            "description": "Develop responsive chat UI with message streaming, typing indicators, and conversation history management",
            "dependencies": [],
            "details": "Create chat components, implement WebSocket connections, handle message streaming, add typing indicators, manage conversation state, and optimize for real-time performance",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Command Approval Workflow System",
            "description": "Implement approval mechanism for sensitive operations with role-based permissions and audit trails",
            "dependencies": [3],
            "details": "Design approval states, implement role-based access control, create approval UI components, maintain audit logs, handle approval notifications, and manage timeout scenarios",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Background Processing Engine",
            "description": "Build asynchronous task processing system for long-running operations with progress tracking and error recovery",
            "dependencies": [3, 5],
            "details": "Implement job queue, create worker processes, add progress tracking, handle task failures, implement retry mechanisms, and provide status updates to chat interface",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Security Implementation for Sensitive Data",
            "description": "Implement comprehensive security measures including data encryption, access controls, and secure communication",
            "dependencies": [1, 4],
            "details": "Add end-to-end encryption, implement secure token management, create data sanitization, establish secure communication channels, add input validation, and implement security monitoring",
            "status": "pending"
          },
          {
            "id": 8,
            "title": "Integration Testing and Performance Optimization",
            "description": "Conduct comprehensive testing of all integrated components and optimize system performance",
            "dependencies": [4, 6, 7],
            "details": "Create integration tests, perform load testing, optimize AI response times, test security measures, validate chat functionality, and ensure system reliability under various conditions",
            "status": "pending"
          }
        ]
      },
      {
        "id": 218,
        "title": "Develop Contextual Navigation System with Module-Specific Sidebars",
        "description": "Implement a dynamic navigation system that adapts to the user's current context within the application, including global navigation, module-specific sidebars, and quick action buttons.",
        "details": "Create a contextual navigation system with the following features:\n\n1. Global navigation in the top bar\n2. Context-specific sidebars for each module\n3. Quick action buttons relevant to current view\n4. Recent items and favorites access\n5. AI assistant access point\n\nImplementation details:\n- Use Next.js App Router for route-based layouts\n- Create a responsive navigation system that adapts to different screen sizes\n- Implement context detection based on current route\n- Create module-specific sidebar components\n- Use React Context for managing navigation state\n- Implement keyboard shortcuts for common navigation actions\n\nExample navigation implementation:\n```tsx\n// components/layout/Navigation.tsx\nimport { usePathname } from 'next/navigation';\nimport { useState, useEffect } from 'react';\nimport Link from 'next/link';\nimport { Button } from '@codexcrm/ui/components/ui/button';\nimport { NavigationMenu } from '@codexcrm/ui/components/ui/navigation-menu';\nimport { DashboardSidebar } from '@/components/layout/DashboardSidebar';\nimport { ContactsSidebar } from '@/components/layout/ContactsSidebar';\nimport { TasksSidebar } from '@/components/layout/TasksSidebar';\nimport { AiAssistantButton } from '@/components/ai/AiAssistantButton';\n\nexport function Navigation() {\n  const pathname = usePathname();\n  const [activeModule, setActiveModule] = useState<string>('');\n  \n  useEffect(() => {\n    // Determine active module based on pathname\n    if (pathname.startsWith('/dashboard')) {\n      setActiveModule('dashboard');\n    } else if (pathname.startsWith('/contacts')) {\n      setActiveModule('contacts');\n    } else if (pathname.startsWith('/tasks')) {\n      setActiveModule('tasks');\n    } else {\n      setActiveModule('');\n    }\n  }, [pathname]);\n  \n  return (\n    <div className=\"flex h-screen\">\n      {/* Top Navigation */}\n      <div className=\"fixed top-0 left-0 right-0 h-16 bg-white border-b z-50\">\n        <div className=\"container mx-auto h-full flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <Link href=\"/dashboard\">\n              <span className=\"text-xl font-bold text-teal-600\">CodexCRM</span>\n            </Link>\n            <NavigationMenu className=\"ml-6\">\n              {/* Navigation items */}\n            </NavigationMenu>\n          </div>\n          <div className=\"flex items-center space-x-4\">\n            <AiAssistantButton />\n            {/* User menu */}\n          </div>\n        </div>\n      </div>\n      \n      {/* Sidebar */}\n      <div className=\"fixed left-0 top-16 bottom-0 w-64 border-r bg-gray-50\">\n        {activeModule === 'dashboard' && <DashboardSidebar />}\n        {activeModule === 'contacts' && <ContactsSidebar />}\n        {activeModule === 'tasks' && <TasksSidebar />}\n      </div>\n      \n      {/* Main Content */}\n      <div className=\"ml-64 mt-16 flex-1 p-6\">\n        {/* Page content will be rendered here */}\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Unit tests for navigation state management\n2. Integration tests for route-based sidebar rendering\n3. Component tests for responsive behavior\n4. End-to-end tests for navigation flows between modules\n5. Accessibility testing for keyboard navigation\n6. Performance testing for navigation rendering\n7. User acceptance testing for intuitive navigation experience\n8. Cross-browser compatibility testing",
        "priority": "medium",
        "dependencies": ["213", "231"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Global Navigation Component",
            "description": "Create a universal navigation component that provides consistent top-level navigation across all application modules and pages",
            "dependencies": [],
            "details": "Design and implement a global navigation bar with primary menu items, user profile access, search functionality, and application-wide actions. Include proper styling, hover states, and active page indicators.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Context Detection System",
            "description": "Develop a system to automatically detect the current application context and adjust navigation elements accordingly",
            "dependencies": [1],
            "details": "Implement route-based context detection that identifies the current module, page depth, and user permissions to dynamically show/hide navigation elements and update breadcrumbs or contextual information.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Module-Specific Sidebar Components",
            "description": "Build contextual sidebar navigation components that adapt based on the current module or section",
            "dependencies": [2],
            "details": "Create reusable sidebar components for different application modules with collapsible sections, nested menu items, and module-specific quick actions. Ensure consistent styling while allowing module customization.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Responsive Navigation Patterns with Keyboard Shortcuts",
            "description": "Implement responsive design patterns and keyboard navigation support for all navigation components",
            "dependencies": [1, 3],
            "details": "Add mobile-responsive behavior with hamburger menus, touch gestures, and collapsible elements. Implement comprehensive keyboard shortcuts for navigation (Tab, Arrow keys, Enter, Escape) and ensure WCAG accessibility compliance.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 219,
        "title": "Implement MCP Client Architecture for Third-Party Integrations",
        "description": "Develop the Multi-Channel Platform (MCP) client architecture for integrating with third-party services like Google, Calendly, MailChimp, and social media platforms.",
        "details": "Create a flexible MCP client architecture with the following features:\n\n1. Google services integration (Calendar, Contacts, Gmail) with two-way sync\n2. Email service integration (Gmail, MailChimp, custom SMTP, SendGrid)\n3. WhatsApp/Twilio for messaging\n4. Social Media Integration (Instagram, Facebook, LinkedIn)\n5. Configuration UI for connections\n\nImplementation details:\n- Create an abstract MCP client interface for consistent integration patterns\n- Implement OAuth flows for third-party authentication\n- Create service-specific adapters for each integration\n- Implement background sync processes using Next.js API routes\n- Create a configuration UI for managing integrations\n- Implement secure credential storage in Supabase\n\nExample MCP client architecture:\n```typescript\n// lib/mcp/types.ts\nexport interface McpClientConfig {\n  userId: string;\n  serviceId: string;\n  credentials: Record<string, any>;\n  settings: Record<string, any>;\n}\n\nexport interface McpClient<T = any> {\n  connect(): Promise<boolean>;\n  disconnect(): Promise<boolean>;\n  isConnected(): Promise<boolean>;\n  getData(options?: any): Promise<T[]>;\n  sendData(data: any): Promise<boolean>;\n  syncData(direction: 'push' | 'pull' | 'both'): Promise<SyncResult>;\n}\n\nexport interface SyncResult {\n  success: boolean;\n  itemsProcessed: number;\n  errors: Error[];\n  timestamp: Date;\n}\n\n// lib/mcp/google-calendar.ts\nimport { google } from 'googleapis';\nimport { McpClient, McpClientConfig, SyncResult } from './types';\n\nexport class GoogleCalendarClient implements McpClient<google.calendar.v3.Event> {\n  private config: McpClientConfig;\n  private auth: any;\n  private calendarClient: any;\n  \n  constructor(config: McpClientConfig) {\n    this.config = config;\n  }\n  \n  async connect(): Promise<boolean> {\n    try {\n      this.auth = new google.auth.OAuth2(\n        process.env.GOOGLE_CLIENT_ID,\n        process.env.GOOGLE_CLIENT_SECRET,\n        process.env.GOOGLE_REDIRECT_URI\n      );\n      \n      this.auth.setCredentials(this.config.credentials);\n      this.calendarClient = google.calendar({ version: 'v3', auth: this.auth });\n      return true;\n    } catch (error) {\n      console.error('Failed to connect to Google Calendar:', error);\n      return false;\n    }\n  }\n  \n  // Implement other interface methods\n}\n```\n\nConfiguration UI example:\n```tsx\n// components/integrations/IntegrationCard.tsx\nimport { useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\nimport { Button } from '@codexcrm/ui/components/ui/button';\nimport { Switch } from '@codexcrm/ui/components/ui/switch';\nimport { trpc } from '@/lib/trpc';\n\ninterface IntegrationCardProps {\n  integration: {\n    id: string;\n    name: string;\n    description: string;\n    isConnected: boolean;\n    icon: React.ReactNode;\n  };\n}\n\nexport function IntegrationCard({ integration }: IntegrationCardProps) {\n  const [isConnecting, setIsConnecting] = useState(false);\n  \n  const connectMutation = trpc.integrations.connect.useMutation({\n    onSuccess: () => {\n      // Handle successful connection\n    }\n  });\n  \n  const disconnectMutation = trpc.integrations.disconnect.useMutation({\n    onSuccess: () => {\n      // Handle successful disconnection\n    }\n  });\n  \n  const handleConnect = async () => {\n    setIsConnecting(true);\n    \n    if (integration.isConnected) {\n      await disconnectMutation.mutateAsync({ integrationId: integration.id });\n    } else {\n      // For OAuth flows, open a popup window\n      const width = 600;\n      const height = 600;\n      const left = window.screenX + (window.outerWidth - width) / 2;\n      const top = window.screenY + (window.outerHeight - height) / 2;\n      \n      window.open(\n        `/api/auth/${integration.id}`,\n        'Connect to ' + integration.name,\n        `width=${width},height=${height},left=${left},top=${top}`\n      );\n      \n      // Listen for message from popup\n      window.addEventListener('message', (event) => {\n        if (event.data.type === 'INTEGRATION_CONNECTED' && \n            event.data.integrationId === integration.id) {\n          connectMutation.mutate({\n            integrationId: integration.id,\n            credentials: event.data.credentials\n          });\n        }\n      }, { once: true });\n    }\n    \n    setIsConnecting(false);\n  };\n  \n  return (\n    <Card>\n      <CardHeader className=\"flex flex-row items-center justify-between pb-2\">\n        <CardTitle className=\"text-sm font-medium\">\n          <div className=\"flex items-center\">\n            <div className=\"mr-2\">{integration.icon}</div>\n            {integration.name}\n          </div>\n        </CardTitle>\n        <Switch\n          checked={integration.isConnected}\n          onCheckedChange={handleConnect}\n          disabled={isConnecting}\n        />\n      </CardHeader>\n      <CardContent>\n        <p className=\"text-sm text-muted-foreground\">{integration.description}</p>\n        {integration.isConnected && (\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"mt-4\"\n            onClick={() => {\n              // Open configuration dialog\n            }}\n          >\n            Configure\n          </Button>\n        )}\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Unit tests for each MCP client implementation\n2. Integration tests with mock third-party APIs\n3. OAuth flow testing in a sandbox environment\n4. End-to-end tests for complete integration workflows\n5. Security testing for credential handling\n6. Performance testing for sync operations\n7. Error handling and recovery testing\n8. User acceptance testing for integration configuration UI",
        "priority": "medium",
        "dependencies": ["212", "232"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Abstract MCP Interface Design",
            "description": "Design and implement the core abstract interface for MCP (Model Context Protocol) that defines the contract for all service integrations, including standardized methods for authentication, data retrieval, and service communication.",
            "dependencies": [],
            "details": "Create base classes and interfaces that establish common patterns for service integration, define standard response formats, implement protocol-level abstractions, and establish the foundation for extensible service architecture.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "OAuth Flow Implementation",
            "description": "Implement comprehensive OAuth 2.0 and OpenID Connect authentication flows supporting authorization code, PKCE, refresh tokens, and multi-tenant scenarios across different service providers.",
            "dependencies": [1],
            "details": "Build secure OAuth handlers, implement token lifecycle management, create authorization URL generation, handle callback processing, implement refresh token rotation, and ensure compliance with OAuth security best practices.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Service-Specific Adapters",
            "description": "Develop individual adapter implementations for each third-party service, translating service-specific APIs and data formats into the standardized MCP interface while handling service-unique requirements.",
            "dependencies": [1, 2],
            "details": "Create adapters for major services (Google, Microsoft, Slack, etc.), implement service-specific API calls, handle rate limiting and pagination, transform data formats to common schema, and manage service-specific authentication nuances.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Credential Management System",
            "description": "Build a secure credential storage and management system that handles encryption, token storage, credential rotation, and secure access patterns for multiple service accounts and users.",
            "dependencies": [2],
            "details": "Implement encrypted credential storage, create secure key management, build credential lifecycle management, implement access control mechanisms, and establish audit logging for credential operations.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Configuration UI",
            "description": "Design and implement user interface components for service configuration, authentication setup, permission management, and integration monitoring with intuitive workflows for non-technical users.",
            "dependencies": [3, 4],
            "details": "Create service connection wizards, build authentication flow UI, implement permission configuration screens, design integration status dashboards, and provide troubleshooting interfaces.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Error Handling Systems",
            "description": "Implement comprehensive error handling, logging, monitoring, and recovery mechanisms that provide detailed diagnostics, automatic retry logic, and graceful degradation across all integration points.",
            "dependencies": [3, 4],
            "details": "Build centralized error handling, implement retry mechanisms with exponential backoff, create detailed logging and monitoring, establish error categorization and reporting, and implement circuit breaker patterns for service resilience.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 220,
        "title": "Implement Advanced AI Features for Relationship Insights and Task Generation",
        "description": "Develop advanced AI features including relationship insights, notes analysis, contact enrichment, task generation, and email draft assistance.",
        "details": "Implement the following advanced AI features:\n\n1. AI-powered notes analysis and insights\n2. AI-powered contact enrichment and relationship insights\n3. AI-powered task generation and approval workflow\n4. AI-powered email draft generation and assistance\n5. Background processing for AI analysis\n\nImplementation details:\n- Create specialized AI prompts for each feature\n- Implement background processing using Next.js API routes or serverless functions\n- Create a feedback loop for AI model improvement\n- Implement proper error handling and fallback mechanisms\n- Use streaming responses where appropriate for better UX\n- Create approval workflows for AI-generated content\n\nExample implementation for AI-powered notes analysis:\n```typescript\n// server/services/ai-notes-analyzer.ts\nimport { OpenAI } from 'openai';\nimport { db } from '@/lib/db';\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n\nexport async function analyzeSessionNotes(noteId: string) {\n  // Fetch the note and related contact information\n  const note = await db.notes.findUnique({\n    where: { id: noteId },\n    include: {\n      contact: true,\n      previousNotes: {\n        take: 3,\n        orderBy: { createdAt: 'desc' },\n      },\n    },\n  });\n  \n  if (!note) throw new Error('Note not found');\n  \n  // Create a prompt for the AI\n  const prompt = `\n    Analyze the following session notes for a wellness client and extract key insights:\n    \n    CLIENT BACKGROUND:\n    ${note.contact.name}, ${note.contact.age} years old\n    \n    CURRENT SESSION NOTES:\n    ${note.content}\n    \n    PREVIOUS SESSION NOTES:\n    ${note.previousNotes.map(n => `[${n.createdAt.toISOString()}] ${n.content}`).join('\\n\\n')}\n    \n    Please provide:\n    1. Key emotional themes\n    2. Progress indicators\n    3. Potential concerns or red flags\n    4. Suggested follow-up actions\n    5. Topics to explore in next session\n  `;\n  \n  // Get AI analysis\n  const completion = await openai.chat.completions.create({\n    model: \"gpt-4\",\n    messages: [\n      { role: \"system\", content: \"You are an expert wellness practitioner assistant...\" },\n      { role: \"user\", content: prompt }\n    ],\n  });\n  \n  const analysis = completion.choices[0].message.content;\n  \n  // Parse the analysis into structured data\n  const structuredAnalysis = parseAnalysisIntoStructure(analysis);\n  \n  // Save the analysis to the database\n  await db.noteAnalysis.create({\n    data: {\n      noteId,\n      emotionalThemes: structuredAnalysis.emotionalThemes,\n      progressIndicators: structuredAnalysis.progressIndicators,\n      concerns: structuredAnalysis.concerns,\n      suggestedActions: structuredAnalysis.suggestedActions,\n      nextSessionTopics: structuredAnalysis.nextSessionTopics,\n      rawAnalysis: analysis,\n    },\n  });\n  \n  return structuredAnalysis;\n}\n\nfunction parseAnalysisIntoStructure(analysis: string) {\n  // Parse the free-text analysis into structured data\n  // This could use regex, simple parsing, or even another AI call\n  // to structure the data\n  \n  // Example implementation\n  const sections = analysis.split(/\\d+\\./g).filter(Boolean).map(s => s.trim());\n  \n  return {\n    emotionalThemes: extractSection(sections[0]),\n    progressIndicators: extractSection(sections[1]),\n    concerns: extractSection(sections[2]),\n    suggestedActions: extractSection(sections[3]),\n    nextSessionTopics: extractSection(sections[4]),\n  };\n}\n\nfunction extractSection(text: string) {\n  // Extract bullet points or comma-separated items\n  const items = text.split(/\\n-|\\n•|,/g).map(item => item.trim()).filter(Boolean);\n  return items;\n}\n```\n\nExample UI for displaying AI insights:\n```tsx\n// components/contacts/NoteInsights.tsx\nimport { useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\nimport { Badge } from '@codexcrm/ui/components/ui/badge';\nimport { Button } from '@codexcrm/ui/components/ui/button';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@codexcrm/ui/components/ui/tabs';\n\ninterface NoteInsightsProps {\n  analysis: {\n    emotionalThemes: string[];\n    progressIndicators: string[];\n    concerns: string[];\n    suggestedActions: string[];\n    nextSessionTopics: string[];\n  };\n  onActionApproved: (action: string) => void;\n}\n\nexport function NoteInsights({ analysis, onActionApproved }: NoteInsightsProps) {\n  return (\n    <Card>\n      <CardHeader>\n        <CardTitle>AI Insights</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Tabs defaultValue=\"themes\">\n          <TabsList>\n            <TabsTrigger value=\"themes\">Emotional Themes</TabsTrigger>\n            <TabsTrigger value=\"progress\">Progress</TabsTrigger>\n            <TabsTrigger value=\"concerns\">Concerns</TabsTrigger>\n            <TabsTrigger value=\"actions\">Suggested Actions</TabsTrigger>\n            <TabsTrigger value=\"next\">Next Session</TabsTrigger>\n          </TabsList>\n          \n          <TabsContent value=\"themes\">\n            <div className=\"flex flex-wrap gap-2 mt-2\">\n              {analysis.emotionalThemes.map((theme, i) => (\n                <Badge key={i} variant=\"outline\">{theme}</Badge>\n              ))}\n            </div>\n          </TabsContent>\n          \n          {/* Other tab contents */}\n          \n          <TabsContent value=\"actions\">\n            <ul className=\"space-y-2 mt-2\">\n              {analysis.suggestedActions.map((action, i) => (\n                <li key={i} className=\"flex items-center justify-between\">\n                  <span>{action}</span>\n                  <Button \n                    size=\"sm\" \n                    onClick={() => onActionApproved(action)}\n                  >\n                    Approve\n                  </Button>\n                </li>\n              ))}\n            </ul>\n          </TabsContent>\n        </Tabs>\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Unit tests for AI analysis parsing functions\n2. Integration tests with mock AI responses\n3. End-to-end tests for complete AI feature workflows\n4. Performance testing for background processing\n5. Security testing for handling sensitive client data\n6. User acceptance testing with wellness professionals\n7. A/B testing for different AI prompts to optimize results\n8. Regression testing when updating AI models or prompts",
        "priority": "medium",
        "dependencies": ["212", "217", "230"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Notes Analysis System",
            "description": "Develop AI-powered system to analyze meeting notes, extract key insights, action items, and sentiment analysis",
            "dependencies": [],
            "details": "Implement natural language processing to parse meeting transcripts, identify speakers, extract decisions, action items, and key topics. Include sentiment analysis and priority scoring for follow-up items.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Contact Enrichment Pipeline",
            "description": "Build automated pipeline to enrich contact information with additional data sources and AI-driven insights",
            "dependencies": [1],
            "details": "Create system to automatically gather additional contact information from various sources, analyze communication patterns, and generate contact profiles with engagement recommendations.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Task Generation Algorithms",
            "description": "Implement intelligent algorithms to automatically generate tasks and action items from analyzed content",
            "dependencies": [1],
            "details": "Develop AI algorithms that can identify actionable items from notes analysis, prioritize tasks based on context and urgency, and assign appropriate deadlines and owners.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Email Draft Assistance",
            "description": "Create AI-powered email drafting system that generates contextually appropriate email responses and follow-ups",
            "dependencies": [1, 2],
            "details": "Build system that uses analyzed notes and enriched contact data to generate personalized email drafts, suggest appropriate tone and content, and provide multiple draft options.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Background Processing Implementation",
            "description": "Develop robust background processing system to handle AI operations asynchronously without blocking user interface",
            "dependencies": [1, 2, 3],
            "details": "Implement queue-based background processing for AI analysis tasks, with proper error handling, retry mechanisms, and progress tracking for long-running operations.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Approval Workflows",
            "description": "Design and implement approval workflow system for AI-generated content and automated actions",
            "dependencies": [3, 4, 5],
            "details": "Create configurable approval workflows that allow users to review and approve AI-generated tasks, emails, and other automated actions before execution, with role-based permissions.",
            "status": "pending"
          },
          {
            "id": 7,
            "title": "Feedback Loop Systems",
            "description": "Establish feedback mechanisms to continuously improve AI performance based on user interactions and outcomes",
            "dependencies": [4, 5, 6],
            "details": "Implement system to collect user feedback on AI-generated content, track success rates of automated actions, and use this data to refine AI models and improve future recommendations.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 221,
        "title": "Implement Authentication and User Management with Enhanced Profiles",
        "description": "Develop enhanced user profiles for practitioners, subscription management capabilities, and settings for AI assistant preferences.",
        "details": "Create a comprehensive authentication and user management system with the following features:\n\n1. Enhanced user profiles for wellness practitioners\n2. Subscription management capabilities\n3. Settings for AI assistant preferences\n4. User onboarding flow\n5. Role-based access control\n\nImplementation details:\n- Use Supabase Auth for authentication\n- Create custom user profile tables in Supabase\n- Implement subscription management using Stripe or a similar service\n- Create a settings UI for configuring AI assistant preferences\n- Implement a step-by-step onboarding flow for new users\n\nExample user profile schema:\n```sql\nCREATE TABLE practitioner_profiles (\n  id UUID PRIMARY KEY REFERENCES auth.users(id),\n  display_name TEXT NOT NULL,\n  professional_title TEXT,\n  specialization TEXT,\n  bio TEXT,\n  profile_image_url TEXT,\n  business_name TEXT,\n  business_address JSONB,\n  contact_email TEXT,\n  contact_phone TEXT,\n  website_url TEXT,\n  social_links JSONB,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE TABLE user_settings (\n  user_id UUID PRIMARY KEY REFERENCES auth.users(id),\n  theme TEXT DEFAULT 'light',\n  notifications_enabled BOOLEAN DEFAULT TRUE,\n  ai_assistant_enabled BOOLEAN DEFAULT TRUE,\n  ai_assistant_voice TEXT DEFAULT 'neutral',\n  ai_suggestion_frequency TEXT DEFAULT 'medium',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE TABLE subscriptions (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  user_id UUID REFERENCES auth.users(id) NOT NULL,\n  stripe_customer_id TEXT,\n  stripe_subscription_id TEXT,\n  plan_id TEXT NOT NULL,\n  status TEXT NOT NULL,\n  current_period_start TIMESTAMP WITH TIME ZONE,\n  current_period_end TIMESTAMP WITH TIME ZONE,\n  cancel_at_period_end BOOLEAN DEFAULT FALSE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n```\n\nExample settings UI:\n```tsx\n// components/settings/UserSettings.tsx\nimport { useState } from 'react';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { Button } from '@codexcrm/ui/components/ui/button';\nimport { Form, FormControl, FormDescription, FormField, FormItem, FormLabel } from '@codexcrm/ui/components/ui/form';\nimport { Input } from '@codexcrm/ui/components/ui/input';\nimport { Switch } from '@codexcrm/ui/components/ui/switch';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@codexcrm/ui/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@codexcrm/ui/components/ui/tabs';\nimport { trpc } from '@/lib/trpc';\n\nconst profileFormSchema = z.object({\n  displayName: z.string().min(2).max(50),\n  professionalTitle: z.string().max(100).optional(),\n  specialization: z.string().max(100).optional(),\n  bio: z.string().max(500).optional(),\n  // Other fields\n});\n\nconst aiSettingsSchema = z.object({\n  aiAssistantEnabled: z.boolean(),\n  aiAssistantVoice: z.enum(['neutral', 'supportive', 'direct']),\n  aiSuggestionFrequency: z.enum(['low', 'medium', 'high']),\n});\n\nexport function UserSettings() {\n  const { data: user, isLoading } = trpc.users.getProfile.useQuery();\n  const updateProfileMutation = trpc.users.updateProfile.useMutation();\n  const updateSettingsMutation = trpc.users.updateSettings.useMutation();\n  \n  const profileForm = useForm({\n    resolver: zodResolver(profileFormSchema),\n    defaultValues: {\n      displayName: user?.displayName || '',\n      professionalTitle: user?.professionalTitle || '',\n      specialization: user?.specialization || '',\n      bio: user?.bio || '',\n      // Other fields\n    },\n  });\n  \n  const aiSettingsForm = useForm({\n    resolver: zodResolver(aiSettingsSchema),\n    defaultValues: {\n      aiAssistantEnabled: user?.settings?.aiAssistantEnabled ?? true,\n      aiAssistantVoice: user?.settings?.aiAssistantVoice || 'neutral',\n      aiSuggestionFrequency: user?.settings?.aiSuggestionFrequency || 'medium',\n    },\n  });\n  \n  const onProfileSubmit = (data) => {\n    updateProfileMutation.mutate(data);\n  };\n  \n  const onAiSettingsSubmit = (data) => {\n    updateSettingsMutation.mutate(data);\n  };\n  \n  if (isLoading) return <div>Loading...</div>;\n  \n  return (\n    <div className=\"container mx-auto py-10\">\n      <h1 className=\"text-3xl font-bold mb-6\">Settings</h1>\n      \n      <Tabs defaultValue=\"profile\">\n        <TabsList>\n          <TabsTrigger value=\"profile\">Profile</TabsTrigger>\n          <TabsTrigger value=\"ai\">AI Assistant</TabsTrigger>\n          <TabsTrigger value=\"subscription\">Subscription</TabsTrigger>\n        </TabsList>\n        \n        <TabsContent value=\"profile\">\n          <Form {...profileForm}>\n            <form onSubmit={profileForm.handleSubmit(onProfileSubmit)} className=\"space-y-6\">\n              {/* Form fields */}\n              <Button type=\"submit\">Save Profile</Button>\n            </form>\n          </Form>\n        </TabsContent>\n        \n        <TabsContent value=\"ai\">\n          <Form {...aiSettingsForm}>\n            <form onSubmit={aiSettingsForm.handleSubmit(onAiSettingsSubmit)} className=\"space-y-6\">\n              {/* AI settings fields */}\n              <Button type=\"submit\">Save AI Settings</Button>\n            </form>\n          </Form>\n        </TabsContent>\n        \n        <TabsContent value=\"subscription\">\n          {/* Subscription management UI */}\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Unit tests for form validation logic\n2. Integration tests for user profile CRUD operations\n3. End-to-end tests for complete user settings workflows\n4. Security testing for authentication flows\n5. Performance testing for profile data loading\n6. Accessibility testing for settings forms\n7. User acceptance testing for subscription management\n8. Cross-browser compatibility testing",
        "priority": "high",
        "dependencies": ["212", "213", "237"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Supabase Auth Setup",
            "description": "Configure Supabase authentication system with email/password, social logins, and security policies",
            "dependencies": [],
            "details": "Set up Supabase project, configure authentication providers (email, Google, GitHub), implement RLS policies, set up JWT configuration, and establish secure session management",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "User Profile Schema and UI",
            "description": "Design and implement user profile database schema and corresponding user interface components",
            "dependencies": [1],
            "details": "Create user profiles table with fields for personal info, preferences, and metadata. Build profile management UI with forms for editing profile information, avatar upload, and account settings",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Subscription Management Integration",
            "description": "Integrate subscription billing system with user accounts and implement subscription-based features",
            "dependencies": [1, 2],
            "details": "Set up Stripe/payment provider integration, create subscription plans table, implement billing webhooks, build subscription management UI, and handle plan upgrades/downgrades",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Settings Interface",
            "description": "Create comprehensive user settings interface for account preferences and configuration",
            "dependencies": [2],
            "details": "Build settings dashboard with sections for account preferences, notification settings, privacy controls, security options, and theme customization. Include data export/import functionality",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Onboarding Flow",
            "description": "Design and implement user onboarding experience for new account setup and feature introduction",
            "dependencies": [1, 2],
            "details": "Create multi-step onboarding wizard including account verification, profile completion, feature tour, initial setup guidance, and welcome messaging system",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Role-Based Access Control Implementation",
            "description": "Implement comprehensive role-based access control system with permissions and user roles",
            "dependencies": [1, 2, 3],
            "details": "Define user roles and permissions schema, implement middleware for route protection, create admin interface for role management, and establish fine-grained access controls for features and data",
            "status": "pending"
          }
        ]
      },
      {
        "id": 222,
        "title": "Database Schema Refactoring - Core Tables",
        "description": "Refactor Supabase database schema to support AI-powered features and enhanced contact management",
        "details": "Create enhanced database schema with the following tables: 1) Restructure contacts table with core fields (id, name, email, phone, created_at, updated_at) 2) Create contact_profiles table for extended information (wellness_goals, preferences, notes, ai_insights) 3) Create sessions table (id, contact_id, date, type, notes, ai_analysis) 4) Create ai_actions table (id, type, suggestion, status, approved_by, created_at) 5) Create notes table with AI tagging support 6) Add proper foreign key relationships and indexes for performance. Use Supabase CLI migrations and ensure RLS policies are properly configured.",
        "testStrategy": "Create comprehensive migration tests, verify foreign key constraints, test RLS policies, and validate data integrity with sample data insertion",
        "priority": "high",
        "dependencies": ["212"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Core Table Creation",
            "description": "Design and create the fundamental database tables with proper column definitions, data types, constraints, and primary keys",
            "dependencies": [],
            "details": "Define table schemas including column specifications, data types, null constraints, default values, primary keys, and basic table-level constraints. Create tables in logical order considering dependencies.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Relationship Establishment",
            "description": "Implement foreign key relationships, junction tables, and referential integrity constraints between core tables",
            "dependencies": [1],
            "details": "Create foreign key constraints, establish one-to-many and many-to-many relationships, implement cascade rules, and ensure referential integrity across all table relationships.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "RLS Policy Implementation",
            "description": "Design and implement Row Level Security policies for data access control and user authorization",
            "dependencies": [1, 2],
            "details": "Enable RLS on tables, create security policies for different user roles, implement tenant isolation, and establish fine-grained access controls based on user context and permissions.",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Performance Optimization with Indexing",
            "description": "Analyze query patterns and implement strategic indexing for optimal database performance",
            "dependencies": [1, 2],
            "details": "Create indexes on frequently queried columns, implement composite indexes for complex queries, optimize foreign key performance, and establish query execution monitoring and tuning strategies.",
            "status": "done"
          }
        ]
      },
      {
        "id": 223,
        "title": "tRPC API Layer Enhancement",
        "description": "Enhance tRPC procedures to support new database schema and AI integration endpoints",
        "details": "Create tRPC routers and procedures for: 1) Contact management (CRUD operations with enrichment data) 2) Session management with AI analysis 3) AI actions workflow (create, approve, reject) 4) Notes with AI tagging 5) Dashboard metrics aggregation. Use @trpc/server v10+ with Zod validation schemas. Implement proper error handling and type safety. Create middleware for authentication and rate limiting.",
        "testStrategy": "Unit tests for each procedure, integration tests with database, mock AI responses for testing, and API endpoint validation",
        "priority": "high",
        "dependencies": [222],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Domain-Specific Routers",
            "description": "Set up modular router structure with separate routers for each domain (users, products, orders, etc.) with proper route organization and RESTful endpoints",
            "dependencies": [],
            "details": "Create individual router files for each business domain, implement CRUD operations, set up proper HTTP methods and endpoints, ensure modular architecture for maintainability",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Implement Zod Schema Validation",
            "description": "Create comprehensive Zod schemas for request/response validation with proper type inference and validation rules for all API endpoints",
            "dependencies": [1],
            "details": "Define input/output schemas for each endpoint, implement request body validation, query parameter validation, and response schema validation with proper error messages",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Develop Middleware Implementation",
            "description": "Create reusable middleware functions for authentication, authorization, logging, rate limiting, and request processing with proper error propagation",
            "dependencies": [1, 2],
            "details": "Implement auth middleware, validation middleware, error handling middleware, logging middleware, and CORS configuration with proper middleware chaining",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Implement Comprehensive Error Handling",
            "description": "Set up centralized error handling system with proper error types, status codes, error formatting, and consistent error responses across all endpoints",
            "dependencies": [1, 2, 3],
            "details": "Create custom error classes, implement global error handler, set up proper HTTP status codes, error logging, and user-friendly error messages with stack trace handling",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Generate API Documentation with Type Safety",
            "description": "Create comprehensive API documentation using OpenAPI/Swagger with automatic type generation from Zod schemas and interactive documentation interface",
            "dependencies": [1, 2, 3, 4],
            "details": "Set up Swagger/OpenAPI documentation, integrate with Zod schemas for automatic type generation, create interactive API explorer, and ensure documentation stays in sync with code",
            "status": "done"
          }
        ]
      },
      {
        "id": 224,
        "title": "UI Component Library Setup",
        "description": "Establish reusable UI component library using Shadcn UI and Tailwind CSS with wellness aesthetic",
        "details": "Set up component library with: 1) Configure Tailwind CSS with custom color palette (teal primary, orange accent) 2) Install and configure Shadcn UI components 3) Create custom components: MetricCard, ContactCard, TaskCard, TimelineItem, AIChat components 4) Implement design system with rounded elements, generous whitespace 5) Create responsive grid layouts 6) Add nature-inspired iconography using Lucide React icons. Use CSS custom properties for theme consistency.",
        "testStrategy": "Storybook setup for component documentation, visual regression tests, responsive design testing across devices, and accessibility compliance testing",
        "priority": "medium",
        "dependencies": ["213"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Tailwind CSS Configuration Setup",
            "description": "Configure Tailwind CSS with custom theme settings, color palette, typography scales, spacing system, and responsive breakpoints for the design system foundation.",
            "dependencies": [],
            "details": "Set up tailwind.config.js with custom design tokens, configure CSS variables for theme switching, establish utility classes for consistent spacing and typography, and optimize for production builds.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Shadcn/ui Component Library Integration",
            "description": "Install and configure Shadcn/ui component library, set up component registry, and customize base components to match design system requirements.",
            "dependencies": [1],
            "details": "Initialize Shadcn/ui CLI, configure components.json, install core components (Button, Input, Card, etc.), customize component variants and styling to align with Tailwind configuration.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "Custom Component Development",
            "description": "Create custom reusable components extending Shadcn/ui base components with application-specific functionality and styling patterns.",
            "dependencies": [2],
            "details": "Develop custom components like DataTable, FormBuilder, NavigationMenu, and Modal components. Implement proper TypeScript interfaces, accessibility features, and consistent API patterns.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Storybook Documentation and Design System",
            "description": "Set up Storybook for component documentation, create comprehensive design system documentation, and establish component usage guidelines.",
            "dependencies": [3],
            "details": "Configure Storybook with Tailwind integration, create stories for all components, document design tokens, establish component composition patterns, and create interactive design system playground.",
            "status": "done"
          }
        ]
      },
      {
        "id": 225,
        "title": "Dashboard Module Implementation",
        "description": "Build the main dashboard serving as practitioner's 'second brain' with business metrics and AI task delegation",
        "details": "Implement dashboard with: 1) Business health visualization cards using Chart.js or Recharts 2) Upcoming sessions widget with calendar integration preview 3) Retention risk indicators with color-coded alerts 4) AI task delegation panel with approval workflow 5) Goal progress tracking components 6) Quick action buttons for common tasks. Use React Query for data fetching and caching. Implement real-time updates using Supabase realtime subscriptions.",
        "testStrategy": "Component testing with mock data, integration testing with tRPC endpoints, performance testing for real-time updates, and user acceptance testing for workflow efficiency",
        "priority": "high",
        "dependencies": ["223", "224", "214"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Metrics Visualization Implementation",
            "description": "Design and implement interactive charts, graphs, and visual components for displaying key performance metrics and analytics data",
            "dependencies": [],
            "details": "Create reusable chart components using libraries like Chart.js or D3.js, implement responsive design for different screen sizes, add interactive features like tooltips and drill-down capabilities, and ensure proper data formatting for visualization",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Real-time Data Integration",
            "description": "Establish WebSocket connections and implement real-time data streaming to keep dashboard metrics updated automatically",
            "dependencies": [1],
            "details": "Set up WebSocket or Server-Sent Events for live data feeds, implement data synchronization mechanisms, handle connection failures and reconnection logic, and ensure data consistency across all dashboard components",
            "status": "done"
          },
          {
            "id": 3,
            "title": "AI Task Panel Development",
            "description": "Create an intelligent task management panel with AI-powered recommendations and automated task prioritization",
            "dependencies": [1],
            "details": "Build task list components with filtering and sorting capabilities, integrate AI algorithms for task recommendations, implement natural language processing for task creation, and add smart notifications for task updates",
            "status": "done"
          },
          {
            "id": 4,
            "title": "Quick Actions Implementation",
            "description": "Develop a set of frequently-used action buttons and shortcuts for common dashboard operations",
            "dependencies": [2, 3],
            "details": "Create customizable quick action toolbar, implement keyboard shortcuts, add context-sensitive actions based on current view, and ensure actions integrate properly with real-time data and AI components",
            "status": "done"
          },
          {
            "id": 5,
            "title": "Performance Optimization for Dashboard Loading",
            "description": "Optimize dashboard loading times through code splitting, lazy loading, and efficient state management",
            "dependencies": [1, 2, 3, 4],
            "details": "Implement code splitting for dashboard modules, add lazy loading for non-critical components, optimize bundle sizes, implement efficient caching strategies, and add loading states with skeleton screens for better user experience",
            "status": "done"
          }
        ]
      },
      {
        "id": 226,
        "title": "Contact Relationship Hub - List View",
        "description": "Create enhanced contact list with customizable columns, filtering, and bulk actions",
        "details": "Build contact list interface with: 1) Data table using @tanstack/react-table v8 with sorting, filtering, pagination 2) Customizable column visibility and ordering 3) Bulk action toolbar (email, tag, delete) 4) Advanced filtering by tags, last contact date, session history 5) Search functionality with debounced input 6) Export functionality to CSV/Excel. Implement virtual scrolling for large datasets and optimize for performance with proper memoization.",
        "testStrategy": "Performance testing with large datasets (1000+ contacts), filtering and search functionality testing, bulk action validation, and accessibility testing for keyboard navigation",
        "priority": "high",
        "dependencies": ["223", "224", "215"],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Data Table Implementation",
            "description": "Build the core data table component with column configuration, row rendering, sorting capabilities, and responsive design",
            "dependencies": [],
            "details": "Create table structure with configurable columns, implement row and cell rendering, add column sorting functionality, ensure responsive layout, and establish data binding mechanisms",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Filtering System",
            "description": "Implement comprehensive filtering capabilities including column-specific filters, date ranges, and multi-criteria filtering",
            "dependencies": [1],
            "details": "Design filter UI components, implement filter logic for different data types, create filter persistence, add clear/reset functionality, and integrate with table data display",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Search Functionality",
            "description": "Develop global and column-specific search features with highlighting and advanced search options",
            "dependencies": [1],
            "details": "Implement search input components, create search algorithms for text matching, add search result highlighting, enable column-specific search, and optimize search performance",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Bulk Actions",
            "description": "Create bulk selection and action capabilities for performing operations on multiple table rows",
            "dependencies": [1],
            "details": "Implement row selection checkboxes, create select all/none functionality, design bulk action toolbar, add confirmation dialogs, and handle bulk operation processing",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Performance Optimization with Virtual Scrolling",
            "description": "Implement virtual scrolling and performance optimizations to handle large datasets efficiently",
            "dependencies": [1, 2, 3, 4],
            "details": "Implement virtual scrolling for large datasets, optimize rendering performance, add lazy loading capabilities, implement data pagination strategies, and ensure smooth scrolling experience with filtering and search",
            "status": "pending"
          }
        ]
      },
      {
        "id": 227,
        "title": "Contact Detail Cards with Timeline",
        "description": "Implement detailed contact view with wellness journey timeline and session history",
        "details": "Create contact detail interface with: 1) Tabbed layout for contact info, sessions, notes, media 2) Interactive timeline using libraries like vis-timeline or custom implementation 3) Session history with expandable notes 4) AI-powered relationship insights display 5) Quick action buttons for email, call, schedule 6) Referral tracking visualization 7) Client-submitted media placeholder integration. Use React Hook Form for editing capabilities and implement optimistic updates.",
        "testStrategy": "Timeline rendering performance testing, form validation testing, real-time update testing, and cross-browser compatibility testing",
        "priority": "medium",
        "dependencies": ["223", "224", "215"],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Tabbed Interface Creation",
            "description": "Design and implement a multi-tab interface structure with navigation controls, tab switching logic, and responsive layout for organizing different content sections",
            "dependencies": [],
            "details": "Create tab components with active/inactive states, implement tab switching functionality, ensure accessibility compliance, and establish consistent styling across all tabs",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Timeline Visualization",
            "description": "Develop a custom timeline component with interactive elements, data plotting capabilities, and smooth animations for displaying chronological information",
            "dependencies": [1],
            "details": "Build timeline rendering engine, implement zoom/pan functionality, create data point markers, add hover interactions, and ensure performance optimization for large datasets",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Session History Display",
            "description": "Create a comprehensive session history interface that shows past interactions, allows filtering and searching, and provides detailed session information",
            "dependencies": [1],
            "details": "Design history list components, implement search and filter functionality, create session detail views, add pagination for large datasets, and ensure data persistence",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "AI Insights Integration",
            "description": "Integrate AI-powered analytics and insights generation, including data processing, visualization of AI recommendations, and real-time updates",
            "dependencies": [2, 3],
            "details": "Connect to AI services, implement insight generation algorithms, create visualization components for AI data, add real-time update mechanisms, and handle API error states",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Form Handling",
            "description": "Implement comprehensive form management system with validation, submission handling, error management, and user feedback mechanisms",
            "dependencies": [1],
            "details": "Create form components with validation rules, implement submission workflows, add error handling and user notifications, ensure data sanitization, and provide form state management",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Media Placeholder Implementation",
            "description": "Develop media placeholder system for images, videos, and other media content with lazy loading, fallback handling, and responsive design",
            "dependencies": [1, 5],
            "details": "Create placeholder components for different media types, implement lazy loading mechanisms, add fallback content for failed loads, ensure responsive media handling, and optimize for performance",
            "status": "pending"
          }
        ]
      },
      {
        "id": 228,
        "title": "Task Management System with Drag-and-Drop",
        "description": "Build intuitive task board with AI-suggested tasks and category-based organization",
        "details": "Implement task management with: 1) Drag-and-drop board using @dnd-kit/core for accessibility 2) Column-based layout (To Do, In Progress, Done) 3) Task cards with priority indicators and due dates 4) AI suggestion integration with approval workflow 5) Category filtering (marketing, client follow-up, admin) 6) Task creation modal with rich text editor. Implement local state management with Zustand for smooth interactions and sync with backend.",
        "testStrategy": "Drag-and-drop functionality testing across browsers, AI suggestion workflow testing, state synchronization testing, and mobile touch interaction testing",
        "priority": "medium",
        "dependencies": ["223", "224", "216"],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Task Board Layout Implementation",
            "description": "Create the foundational layout structure for the task board with columns, cards, and responsive design elements",
            "dependencies": [],
            "details": "Design and implement the visual layout including column headers, card containers, spacing, and responsive grid system. Set up basic styling and ensure proper accessibility features.",
            "status": "done"
          },
          {
            "id": 2,
            "title": "Drag-and-Drop Functionality",
            "description": "Implement drag-and-drop mechanics for moving tasks between columns and reordering within columns",
            "dependencies": [1],
            "details": "Add drag-and-drop event handlers, visual feedback during dragging, drop zone highlighting, and smooth animations. Handle edge cases like invalid drop targets and touch device support.",
            "status": "done"
          },
          {
            "id": 3,
            "title": "State Synchronization with Optimistic Updates",
            "description": "Implement state management system with optimistic updates for immediate UI feedback and proper error handling",
            "dependencies": [2],
            "details": "Create state management logic that immediately updates the UI when users perform actions, while handling backend synchronization and rollback mechanisms for failed operations.",
            "status": "done"
          },
          {
            "id": 4,
            "title": "AI Suggestion Integration",
            "description": "Integrate AI-powered suggestions for task organization, priority recommendations, and workflow optimization",
            "dependencies": [3],
            "details": "Implement AI service integration to provide intelligent suggestions for task placement, priority adjustments, and workflow improvements based on user behavior and task patterns.",
            "status": "done"
          }
        ]
      },
      {
        "id": 229,
        "title": "AI Assistant Chat Interface",
        "description": "Develop global AI chat interface with natural language command processing",
        "details": "Build AI assistant with: 1) Persistent chat bubble using floating UI components 2) Chat interface with message history and typing indicators 3) Natural language processing integration with OpenAI GPT-4 or Claude 4) Command suggestion chips for common actions 5) tRPC procedure mapping for CRM actions 6) Approval workflow for critical operations 7) Message persistence and conversation threading. Use WebSocket or Server-Sent Events for real-time communication.",
        "testStrategy": "AI response accuracy testing, command execution validation, real-time communication testing, approval workflow testing, and conversation persistence testing",
        "priority": "high",
        "dependencies": ["223", "224", "217"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Chat UI Implementation",
            "description": "Design and develop the user interface components for the chat system including message display, input fields, user avatars, typing indicators, and responsive layout",
            "dependencies": [],
            "details": "Create React/Vue components for chat bubbles, message threading, emoji support, file attachments, and mobile-responsive design with accessibility features",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "AI Integration",
            "description": "Integrate AI/ML services for natural language processing, intent recognition, and automated response generation",
            "dependencies": [],
            "details": "Set up connections to AI APIs (OpenAI, Claude, etc.), implement prompt engineering, context management, and response filtering mechanisms",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Command Processing",
            "description": "Develop the command parsing and execution system to handle user inputs, AI commands, and system operations",
            "dependencies": [2],
            "details": "Build command interpreter, parameter validation, error handling, and command routing logic with support for custom commands and macros",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Real-time Communication",
            "description": "Implement WebSocket connections and real-time messaging infrastructure for instant message delivery and live updates",
            "dependencies": [1],
            "details": "Set up WebSocket servers, message queuing, connection management, reconnection logic, and real-time presence indicators",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Approval Workflow",
            "description": "Create the approval system for AI-generated responses and actions requiring human oversight before execution",
            "dependencies": [2, 3],
            "details": "Design approval queues, notification systems, role-based permissions, escalation procedures, and audit trails for approved/rejected actions",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Conversation Persistence",
            "description": "Implement database storage and retrieval system for chat history, user preferences, and conversation context",
            "dependencies": [4, 5],
            "details": "Design database schema, implement CRUD operations, conversation threading, search functionality, data encryption, and backup/restore capabilities",
            "status": "pending"
          }
        ]
      },
      {
        "id": 230,
        "title": "AI Background Processing System",
        "description": "Implement background AI processing for contact enrichment and automated insights",
        "details": "Create background processing system with: 1) Queue system using Supabase Edge Functions or Vercel background functions 2) Contact enrichment pipeline using external APIs (Clearbit, FullContact) 3) AI-powered note analysis and tagging 4) Relationship insight generation 5) Email draft assistance 6) Automated task suggestions based on contact interactions. Implement proper error handling, retry logic, and monitoring with logging.",
        "testStrategy": "Queue processing reliability testing, API integration testing, error handling validation, performance monitoring, and data accuracy verification",
        "priority": "medium",
        "dependencies": ["222", "223", "220"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Queue System Setup",
            "description": "Implement and configure a robust message queue system to handle asynchronous processing of contact data and AI analysis tasks",
            "dependencies": [],
            "details": "Set up message broker (Redis/RabbitMQ), define queue structures, implement job serialization/deserialization, configure queue persistence and durability settings",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Contact Enrichment Pipeline",
            "description": "Build automated pipeline to enrich contact data from multiple external sources and APIs",
            "dependencies": [1],
            "details": "Integrate with data providers, implement data validation and normalization, create contact scoring algorithms, handle rate limiting and API quotas",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "AI Analysis Processing",
            "description": "Develop AI-powered analysis engine to process enriched contact data and generate insights",
            "dependencies": [2],
            "details": "Implement machine learning models, create analysis workflows, build prediction algorithms, optimize processing performance and resource usage",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Error Handling",
            "description": "Implement comprehensive error handling and recovery mechanisms across all system components",
            "dependencies": [1, 2, 3],
            "details": "Create error classification system, implement graceful degradation, build error logging and alerting, design fallback strategies for failed operations",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Monitoring Implementation",
            "description": "Deploy monitoring and observability infrastructure to track system health and performance metrics",
            "dependencies": [1, 2, 3],
            "details": "Set up metrics collection, implement health checks, create dashboards and alerts, establish SLA monitoring and performance benchmarks",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Retry Logic",
            "description": "Implement intelligent retry mechanisms with exponential backoff and circuit breaker patterns",
            "dependencies": [4, 5],
            "details": "Design retry strategies for different failure types, implement exponential backoff algorithms, create circuit breaker patterns, configure dead letter queues",
            "status": "pending"
          }
        ]
      },
      {
        "id": 231,
        "title": "Contextual Navigation System",
        "description": "Build dynamic navigation system that adapts to user context within the application",
        "details": "Implement navigation with: 1) Top navigation bar with global actions 2) Context-specific sidebars for each module 3) Breadcrumb navigation for deep pages 4) Quick action button groups relevant to current view 5) Recent items and favorites access 6) AI assistant access point integration 7) Mobile-responsive hamburger menu. Use React Router v6 for routing and implement proper navigation state management.",
        "testStrategy": "Navigation flow testing, responsive design validation, accessibility testing for screen readers, and user experience testing for context switching",
        "priority": "medium",
        "dependencies": ["224", "218"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Navigation Component Creation",
            "description": "Create the core navigation component structure with routing capabilities and menu items",
            "dependencies": [],
            "details": "Build the main navigation component with proper routing integration, menu item configuration, and basic navigation logic. Include support for nested routes and dynamic menu generation.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Context Detection Implementation",
            "description": "Implement context-aware navigation that adapts based on current route and user state",
            "dependencies": [1],
            "details": "Add context detection logic to highlight active navigation items, manage navigation state, and provide contextual navigation options based on current application state and user permissions.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Responsive Design Implementation",
            "description": "Implement responsive navigation design for mobile, tablet, and desktop viewports",
            "dependencies": [1],
            "details": "Create responsive navigation layouts including mobile hamburger menu, tablet navigation patterns, and desktop navigation bar. Implement breakpoint-based styling and touch-friendly interactions for mobile devices.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Accessibility Features with Keyboard Navigation",
            "description": "Implement comprehensive accessibility features including keyboard navigation and screen reader support",
            "dependencies": [2, 3],
            "details": "Add ARIA labels, keyboard navigation support (Tab, Enter, Arrow keys), focus management, screen reader compatibility, and ensure WCAG compliance. Include skip links and proper semantic markup for assistive technologies.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 232,
        "title": "MCP Client Architecture Foundation",
        "description": "Establish Model Context Protocol client architecture for third-party integrations",
        "details": "Build MCP client foundation with: 1) Abstract MCP client interface for standardized integration 2) Authentication flow management for OAuth providers 3) Configuration management for API keys and settings 4) Error handling and retry mechanisms 5) Rate limiting and quota management 6) Integration status monitoring 7) Webhook handling for real-time updates. Create base classes that can be extended for specific integrations.",
        "testStrategy": "Authentication flow testing, error handling validation, rate limiting verification, webhook processing testing, and integration status monitoring",
        "priority": "medium",
        "dependencies": ["223", "219"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Abstract Interface Design",
            "description": "Design and implement abstract interfaces and base classes for third-party integrations to ensure consistent API contracts and enable polymorphic behavior across different service providers.",
            "dependencies": [],
            "details": "Create abstract base classes, define common interface methods, establish data transfer objects, implement factory patterns for integration instantiation, and design extensible plugin architecture for future integrations.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Authentication Management System",
            "description": "Develop a comprehensive authentication management system to handle various authentication methods (OAuth, API keys, tokens) across different third-party services securely.",
            "dependencies": [1],
            "details": "Implement OAuth 2.0 flows, secure credential storage and rotation, token refresh mechanisms, multi-tenant authentication support, and authentication middleware for request interception.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Configuration System Implementation",
            "description": "Build a flexible configuration system that allows dynamic configuration of third-party integrations without code changes, supporting environment-specific settings and runtime modifications.",
            "dependencies": [1],
            "details": "Create configuration schema validation, environment-based config loading, hot-reload capabilities, configuration versioning, and admin interface for configuration management.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Error Handling Framework",
            "description": "Implement a robust error handling framework that provides consistent error responses, retry mechanisms, circuit breakers, and graceful degradation for third-party integration failures.",
            "dependencies": [1, 2],
            "details": "Design error classification system, implement exponential backoff retry logic, create circuit breaker patterns, establish fallback mechanisms, and build error reporting and alerting systems.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Monitoring and Observability Implementation",
            "description": "Develop comprehensive monitoring and observability features including metrics collection, logging, tracing, and health checks for all third-party integrations to ensure system reliability and performance.",
            "dependencies": [1, 2, 3, 4],
            "details": "Implement distributed tracing, create custom metrics and dashboards, establish structured logging, build health check endpoints, set up alerting rules, and create performance monitoring for API calls and response times.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 233,
        "title": "Google Services Integration",
        "description": "Implement two-way sync with Google Calendar, Contacts, and Gmail using MCP client",
        "details": "Create Google integration with: 1) Google Calendar API v3 integration for session scheduling 2) Google Contacts API for contact synchronization 3) Gmail API for email management and drafts 4) Two-way sync with conflict resolution 5) Incremental sync using change tokens 6) Batch operations for efficiency 7) OAuth 2.0 flow with proper scope management. Use Google APIs Node.js client library and implement proper error handling for API limits.",
        "testStrategy": "Two-way sync validation, conflict resolution testing, incremental sync verification, OAuth flow testing, and API rate limit handling",
        "priority": "high",
        "dependencies": [232],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "OAuth Implementation",
            "description": "Implement OAuth 2.0 authentication flow for Google APIs including token management, refresh handling, and secure credential storage",
            "dependencies": [],
            "details": "Set up Google OAuth 2.0 client configuration, implement authorization code flow, handle token refresh automatically, store credentials securely, and manage authentication state across application sessions",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Calendar API Integration",
            "description": "Integrate Google Calendar API to read, create, update, and delete calendar events with proper error handling and rate limiting",
            "dependencies": [1],
            "details": "Implement Calendar API client, handle event CRUD operations, manage calendar permissions, implement pagination for large datasets, and add proper error handling for API rate limits and quota exceeded scenarios",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Contacts API Sync",
            "description": "Implement Google Contacts API integration for synchronizing contact information with bidirectional data flow",
            "dependencies": [1],
            "details": "Set up People API client, implement contact retrieval and modification operations, handle contact groups and labels, manage contact photo synchronization, and implement proper data mapping between local and Google contact formats",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Gmail Integration",
            "description": "Integrate Gmail API for email synchronization, search, and management capabilities with proper scope handling",
            "dependencies": [1],
            "details": "Implement Gmail API client, handle email retrieval with filters and search, manage email labels and threads, implement attachment handling, and ensure proper scope management for different Gmail operations",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Two-way Sync Logic",
            "description": "Develop bidirectional synchronization logic to keep local data in sync with Google services while maintaining data integrity",
            "dependencies": [2, 3, 4],
            "details": "Implement change detection mechanisms, create sync scheduling system, handle incremental updates, manage sync state persistence, implement rollback mechanisms for failed syncs, and ensure data consistency across all integrated services",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Conflict Resolution Handling",
            "description": "Implement comprehensive conflict resolution strategies for handling data conflicts during synchronization processes",
            "dependencies": [5],
            "details": "Design conflict detection algorithms, implement resolution strategies (last-write-wins, user-choice, merge), create conflict logging and reporting, handle edge cases like simultaneous updates, and provide user interface for manual conflict resolution when automatic resolution fails",
            "status": "pending"
          }
        ]
      },
      {
        "id": 234,
        "title": "Email Service Integration Hub",
        "description": "Build unified email service integration supporting multiple providers",
        "details": "Implement email integration with: 1) Gmail API integration (already covered in Google services) 2) MailChimp API v3 for marketing campaigns 3) SendGrid API for transactional emails 4) Custom SMTP configuration support 5) Email template management 6) Campaign tracking and analytics 7) Unified interface for different providers. Use adapter pattern for provider abstraction and implement proper email validation.",
        "testStrategy": "Multi-provider email sending testing, template rendering validation, campaign tracking verification, SMTP configuration testing, and delivery status monitoring",
        "priority": "medium",
        "dependencies": [232],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Provider Abstraction Layer",
            "description": "Design and implement the core abstraction layer that defines common interfaces and contracts for email service providers",
            "dependencies": [],
            "details": "Create abstract base classes, interfaces, and common data structures that all email providers must implement. Define standard methods for sending emails, managing templates, handling responses, and error handling across different providers.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "MailChimp Integration",
            "description": "Implement MailChimp-specific adapter that integrates with their API and conforms to the abstraction layer",
            "dependencies": [1],
            "details": "Develop MailChimp adapter class that implements the provider interface, handles authentication, API calls, template management, and response parsing specific to MailChimp's service requirements.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "SendGrid Setup",
            "description": "Create SendGrid adapter implementation that integrates with SendGrid API following the established abstraction pattern",
            "dependencies": [1],
            "details": "Build SendGrid-specific adapter that handles their API authentication, email sending, template processing, webhook handling, and error management while conforming to the common interface.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "SMTP Configuration",
            "description": "Implement generic SMTP adapter for traditional email server integration with configurable settings",
            "dependencies": [1],
            "details": "Create SMTP adapter that supports various SMTP servers with configurable host, port, authentication, and security settings. Handle connection management, email formatting, and delivery status tracking.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Unified Interface Implementation",
            "description": "Develop the main service class that provides a single interface to interact with all email providers seamlessly",
            "dependencies": [2, 3, 4],
            "details": "Create the primary email service that manages provider selection, failover logic, configuration switching, and provides a consistent API for the application to send emails regardless of the underlying provider.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 235,
        "title": "Messaging Integration (WhatsApp/Twilio)",
        "description": "Integrate WhatsApp Business API and Twilio for client messaging capabilities",
        "details": "Build messaging integration with: 1) WhatsApp Business API integration for client communication 2) Twilio SMS API for text messaging 3) Message thread management and history 4) Template message support for WhatsApp 5) Delivery status tracking 6) Media message support (images, documents) 7) Webhook handling for incoming messages. Implement proper message queuing and retry mechanisms.",
        "testStrategy": "Message delivery testing, webhook processing validation, media message handling, template message verification, and delivery status accuracy",
        "priority": "low",
        "dependencies": [232],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "WhatsApp Business API Integration",
            "description": "Set up WhatsApp Business API integration including authentication, message sending capabilities, and API client configuration",
            "dependencies": [],
            "details": "Configure WhatsApp Business API credentials, implement message sending functions, handle API rate limits, set up media message support, and establish proper error handling for API responses",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Twilio SMS Setup",
            "description": "Configure Twilio SMS service integration with account setup, phone number provisioning, and SMS sending functionality",
            "dependencies": [],
            "details": "Set up Twilio account credentials, configure SMS sending endpoints, implement phone number validation, handle SMS delivery receipts, and establish fallback mechanisms for failed messages",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Webhook Handling Implementation",
            "description": "Develop webhook endpoints to receive incoming messages and delivery status updates from both WhatsApp and Twilio services",
            "dependencies": [1, 2],
            "details": "Create secure webhook endpoints with proper authentication, implement message parsing for different formats, set up webhook validation and signature verification, handle concurrent webhook requests, and establish proper logging for debugging",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Message Thread Management and Delivery Tracking",
            "description": "Build comprehensive message thread management system with real-time delivery tracking and status monitoring",
            "dependencies": [1, 2, 3],
            "details": "Implement message threading logic to group conversations, create delivery status tracking system with real-time updates, build message history storage and retrieval, set up notification system for delivery failures, and establish analytics for message performance monitoring",
            "status": "pending"
          }
        ]
      },
      {
        "id": 236,
        "title": "Social Media Integration Framework",
        "description": "Create framework for Instagram, Facebook, and LinkedIn integration",
        "details": "Implement social media integration with: 1) Instagram Basic Display API for profile insights 2) Facebook Graph API for page management 3) LinkedIn API for professional networking 4) Social media post scheduling (placeholder) 5) Engagement metrics tracking 6) Content calendar integration 7) OAuth flows for each platform. Focus on read-only operations initially with framework for future write operations.",
        "testStrategy": "OAuth flow testing for each platform, API data retrieval validation, engagement metrics accuracy, and rate limit compliance testing",
        "priority": "low",
        "dependencies": [232],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Instagram API Integration",
            "description": "Implement Instagram Basic Display API integration with OAuth 2.0 authentication, user profile data retrieval, and media content access functionality",
            "dependencies": [],
            "details": "Set up Instagram app registration, implement OAuth flow for user authorization, create endpoints for fetching user profile information and media posts, handle API rate limits and error responses, implement token refresh mechanism",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Facebook Graph API Setup",
            "description": "Configure Facebook Graph API integration with proper permissions, user data access, and page management capabilities",
            "dependencies": [],
            "details": "Register Facebook app and configure Graph API permissions, implement Facebook Login OAuth flow, create services for user profile data, friends list, and page information retrieval, handle API versioning and deprecation notices",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "LinkedIn API Connection",
            "description": "Establish LinkedIn API integration for professional profile data access and network information retrieval",
            "dependencies": [],
            "details": "Set up LinkedIn app credentials and API access, implement LinkedIn OAuth 2.0 authorization flow, create endpoints for profile data, connections, and company information, handle LinkedIn-specific rate limiting and data access restrictions",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Unified Social Media Interface with OAuth Flows",
            "description": "Create a centralized interface that abstracts all social media APIs with standardized OAuth management and extensible architecture",
            "dependencies": [1, 2, 3],
            "details": "Design unified API interface for all social platforms, implement centralized OAuth token management system, create abstract base classes for future platform extensions, build configuration management for API credentials, implement unified error handling and logging across all platforms",
            "status": "pending"
          }
        ]
      },
      {
        "id": 237,
        "title": "User Authentication and Profile Management",
        "description": "Enhance user authentication system with practitioner profiles and subscription management",
        "details": "Build authentication system with: 1) Supabase Auth integration with email/password and OAuth providers 2) Enhanced user profiles for wellness practitioners 3) Subscription tier management and feature gating 4) AI assistant preferences and settings 5) Integration connection management 6) Security settings and two-factor authentication 7) Profile customization for branding. Implement proper role-based access control and session management.",
        "testStrategy": "Authentication flow testing, subscription tier validation, security settings verification, profile customization testing, and session management validation",
        "priority": "high",
        "dependencies": ["222", "221"],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Supabase Auth Setup",
            "description": "Configure Supabase authentication system including OAuth providers, email/password authentication, and session management",
            "dependencies": [],
            "details": "Set up Supabase project, configure authentication providers (Google, GitHub, email), implement auth hooks, configure RLS policies, and establish secure session handling",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Profile Management UI",
            "description": "Create user interface components for profile creation, editing, and management functionality",
            "dependencies": [1],
            "details": "Build profile forms, avatar upload functionality, personal information management, account settings interface, and profile validation logic",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Subscription Integration",
            "description": "Implement subscription management system with payment processing and plan management",
            "dependencies": [1],
            "details": "Integrate payment gateway (Stripe/PayPal), create subscription plans, implement billing cycles, handle payment webhooks, and manage subscription status updates",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Security Settings",
            "description": "Develop comprehensive security settings and controls for user accounts",
            "dependencies": [1, 2],
            "details": "Implement two-factor authentication, password change functionality, login history tracking, device management, security notifications, and account recovery options",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "Role-Based Access Control Implementation",
            "description": "Create role-based permission system with granular access controls and user role management",
            "dependencies": [1, 2, 3],
            "details": "Define user roles and permissions, implement middleware for access control, create admin interfaces for role management, establish resource-level permissions, and integrate with subscription tiers",
            "status": "pending"
          }
        ]
      },
      {
        "id": 238,
        "title": "Performance Optimization and Caching",
        "description": "Implement comprehensive performance optimization and caching strategies",
        "details": "Optimize application performance with: 1) React Query for server state management and caching 2) Next.js Image optimization for contact photos and media 3) Database query optimization with proper indexing 4) Component lazy loading and code splitting 5) Virtual scrolling for large lists 6) Service worker for offline capabilities 7) CDN configuration for static assets. Implement performance monitoring with Web Vitals and error tracking.",
        "testStrategy": "Performance benchmarking, cache hit rate monitoring, lazy loading verification, offline functionality testing, and Web Vitals measurement",
        "priority": "medium",
        "dependencies": [223, 224],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Caching Strategy Implementation",
            "description": "Design and implement comprehensive caching mechanisms including in-memory caching, Redis/Memcached setup, cache invalidation strategies, and cache hierarchy for different data types and access patterns.",
            "dependencies": [],
            "details": "Set up multi-level caching with browser cache, application cache, and distributed cache. Implement cache-aside, write-through, and write-behind patterns. Configure cache expiration policies and cache warming strategies.",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Database Optimization",
            "description": "Optimize database performance through query optimization, indexing strategies, connection pooling, and database schema improvements to reduce query execution time and resource usage.",
            "dependencies": [],
            "details": "Analyze slow queries, create appropriate indexes, implement database connection pooling, optimize table structures, and set up read replicas. Configure query caching and database-level optimizations.",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Lazy Loading Setup",
            "description": "Implement lazy loading mechanisms for images, components, and data to reduce initial page load time and improve perceived performance by loading content on-demand.",
            "dependencies": [],
            "details": "Set up image lazy loading with intersection observer, implement code splitting for components, configure dynamic imports, and establish lazy data fetching patterns with pagination and infinite scroll.",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Service Worker Configuration",
            "description": "Configure service workers for offline functionality, background sync, push notifications, and advanced caching strategies to enhance user experience and application reliability.",
            "dependencies": [1],
            "details": "Implement service worker registration, cache management strategies, offline fallbacks, background synchronization, and push notification handling. Integrate with existing caching strategy.",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "CDN Setup",
            "description": "Configure Content Delivery Network to distribute static assets globally, reduce latency, and improve load times by serving content from geographically distributed edge servers.",
            "dependencies": [1, 3],
            "details": "Set up CDN for static assets, configure cache headers, implement asset optimization and compression, establish CDN purging strategies, and integrate with lazy loading mechanisms.",
            "status": "pending"
          },
          {
            "id": 6,
            "title": "Performance Monitoring",
            "description": "Implement comprehensive performance monitoring and analytics to track application performance metrics, identify bottlenecks, and measure the effectiveness of optimization strategies.",
            "dependencies": [1, 2, 3, 4, 5],
            "details": "Set up performance monitoring tools, configure real user monitoring (RUM), implement synthetic monitoring, create performance dashboards, and establish alerting for performance degradation across all optimization layers.",
            "status": "pending"
          }
        ]
      },
      {
        "id": 239,
        "title": "Mobile Responsive Design Implementation",
        "description": "Ensure full mobile responsiveness across all modules and components",
        "details": "Implement mobile responsiveness with: 1) Responsive breakpoints using Tailwind CSS 2) Touch-friendly interface elements 3) Mobile-optimized navigation patterns 4) Swipe gestures for task management 5) Mobile-specific AI chat interface 6) Optimized forms for mobile input 7) Progressive Web App capabilities. Use CSS Grid and Flexbox for flexible layouts and implement proper touch targets.",
        "testStrategy": "Cross-device testing on various screen sizes, touch interaction validation, PWA functionality testing, and mobile performance optimization",
        "priority": "medium",
        "dependencies": [224],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Responsive Breakpoint Implementation",
            "description": "Implement CSS media queries and responsive design breakpoints for different screen sizes including mobile, tablet, and desktop viewports",
            "dependencies": [],
            "details": "Define breakpoint system (320px, 768px, 1024px, 1200px), create fluid grid layouts, implement responsive typography scaling, optimize images for different resolutions, and ensure content reflows properly across all device sizes",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "Touch Interface Optimization",
            "description": "Optimize user interface elements and interactions for touch-based devices with appropriate sizing and gesture support",
            "dependencies": [1],
            "details": "Implement minimum 44px touch targets, add touch feedback states, optimize button and link spacing, implement swipe gestures where appropriate, add haptic feedback support, and ensure smooth scrolling performance on touch devices",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Mobile Navigation Patterns",
            "description": "Design and implement mobile-specific navigation patterns including hamburger menus, bottom navigation, and collapsible sections",
            "dependencies": [1, 2],
            "details": "Create responsive hamburger menu with smooth animations, implement bottom tab navigation for key sections, add collapsible accordion menus, optimize menu item spacing for touch, and ensure navigation accessibility on mobile devices",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "PWA Capabilities Setup",
            "description": "Configure Progressive Web App features including service workers, manifest file, offline functionality, and app-like experience",
            "dependencies": [1, 2, 3],
            "details": "Create web app manifest with icons and theme colors, implement service worker for caching and offline support, add install prompt functionality, configure push notifications if needed, optimize loading performance, and ensure PWA audit compliance",
            "status": "pending"
          }
        ]
      },
      {
        "id": 240,
        "title": "Testing Infrastructure and Quality Assurance",
        "description": "Establish comprehensive testing infrastructure for the entire application",
        "details": "Set up testing infrastructure with: 1) Jest and React Testing Library for unit tests 2) Playwright for end-to-end testing 3) Storybook for component documentation and testing 4) MSW (Mock Service Worker) for API mocking 5) Accessibility testing with axe-core 6) Visual regression testing with Percy or Chromatic 7) Performance testing with Lighthouse CI. Implement CI/CD pipeline with GitHub Actions for automated testing.",
        "testStrategy": "Test coverage reporting, automated test execution in CI/CD, accessibility compliance validation, visual regression detection, and performance regression monitoring",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Unit Testing Setup",
            "description": "Configure unit testing framework, establish testing patterns, and create foundational test utilities for component and function testing",
            "dependencies": [],
            "details": "Set up Jest/Vitest testing framework, configure test environment, create test utilities and mocks, establish testing conventions, implement code coverage reporting, and create initial unit tests for core components and utilities",
            "status": "pending"
          },
          {
            "id": 2,
            "title": "E2E Testing Implementation",
            "description": "Implement end-to-end testing framework and create comprehensive user journey tests",
            "dependencies": [1],
            "details": "Set up Playwright/Cypress framework, configure test environments, create page object models, implement user flow tests, set up test data management, and establish E2E testing best practices",
            "status": "pending"
          },
          {
            "id": 3,
            "title": "Accessibility Testing",
            "description": "Implement automated accessibility testing and establish compliance validation processes",
            "dependencies": [1],
            "details": "Integrate axe-core or similar accessibility testing tools, create automated a11y tests, implement WCAG compliance checks, set up screen reader testing, and establish accessibility testing guidelines",
            "status": "pending"
          },
          {
            "id": 4,
            "title": "Visual Regression Testing",
            "description": "Set up visual regression testing framework to detect unintended UI changes",
            "dependencies": [2],
            "details": "Configure visual testing tools (Percy, Chromatic, or Playwright visual comparisons), create baseline screenshots, implement visual diff detection, set up cross-browser visual testing, and establish visual review workflows",
            "status": "pending"
          },
          {
            "id": 5,
            "title": "CI/CD Pipeline Configuration",
            "description": "Configure automated testing pipeline and deployment workflows with comprehensive quality gates",
            "dependencies": [1, 2, 3, 4],
            "details": "Set up GitHub Actions/Jenkins pipeline, configure automated test execution, implement quality gates and coverage thresholds, set up parallel test execution, configure deployment automation, and establish testing reporting and notifications",
            "status": "pending"
          }
        ]
      },
      {
        "id": 241,
        "title": "Database Migration Scripts with Rollback and Version Control",
        "description": "Create comprehensive database migration scripts with rollback capabilities, version tracking, and environment-specific configurations to handle schema changes safely across development, staging, and production environments.",
        "details": "Implement a robust database migration system with the following components:\n\n1. **Migration Script Structure**:\n   - Create numbered migration files (e.g., 001_initial_schema.sql, 002_add_ai_features.sql)\n   - Each migration file contains both UP (forward) and DOWN (rollback) operations\n   - Include metadata headers with version, description, author, and timestamp\n   - Use transaction blocks to ensure atomicity\n\n2. **Version Control System**:\n   - Create schema_migrations table to track applied migrations\n   - Store migration version, applied_at timestamp, and checksum for integrity\n   - Implement migration status tracking (pending, applied, failed, rolled_back)\n   - Add migration dependency tracking for complex schema changes\n\n3. **Environment-Specific Configurations**:\n   - Create separate configuration files for dev/staging/production\n   - Include environment-specific connection strings and parameters\n   - Implement conditional logic for environment-specific data seeding\n   - Support different backup strategies per environment\n\n4. **Safety Mechanisms**:\n   - Implement dry-run mode to preview changes without execution\n   - Add data backup procedures before destructive operations\n   - Include rollback time limits and dependency checks\n   - Implement idempotent operations using IF EXISTS/IF NOT EXISTS\n   - Add data validation checks before and after migrations\n\n5. **Migration Tools**:\n   - Create CLI tool for running migrations (migrate up/down/status)\n   - Implement automatic rollback on failure\n   - Add migration locking to prevent concurrent executions\n   - Include progress reporting and detailed logging\n\n6. **Integration with Existing Schema**:\n   - Create migrations for the AI-enhanced CRM schema changes from Tasks 212/222\n   - Handle existing data preservation during schema modifications\n   - Implement gradual migration strategies for large datasets",
        "testStrategy": "1. **Unit Testing**: Test individual migration scripts in isolated database instances, verify both forward and rollback operations execute correctly, validate idempotent behavior by running migrations multiple times. 2. **Integration Testing**: Test complete migration sequences from clean database to current schema, verify rollback chains work in reverse order, test environment-specific configurations across dev/staging/production. 3. **Data Integrity Testing**: Populate test database with sample data, run migrations and verify data preservation, test rollback operations maintain data consistency, validate foreign key constraints and indexes. 4. **Failure Scenario Testing**: Simulate migration failures at various points, verify automatic rollback mechanisms, test recovery from partial migration states, validate locking mechanisms prevent concurrent executions. 5. **Performance Testing**: Measure migration execution times on large datasets, test backup and restore procedures, validate migration performance across different environments. 6. **Production Readiness**: Test complete deployment pipeline with migration scripts, verify monitoring and alerting for migration status, validate backup procedures before production deployment.",
        "status": "pending",
        "dependencies": [212, 222],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 242,
        "title": "Error Handling and User Feedback System",
        "description": "Implement a comprehensive error handling and user feedback system across the application to provide clear, actionable messages for both system errors and user actions.",
        "details": "Develop a robust error handling and user feedback system with the following components:\n\n1. **Global Error Handling**:\n   - Implement a centralized error handling service that captures and processes errors from all parts of the application\n   - Create error severity levels (critical, error, warning, info)\n   - Set up error logging to both client-side storage and server-side logs\n   - Implement automatic error reporting to monitoring systems\n\n2. **User-Facing Error Messages**:\n   - Design a consistent toast/notification component with appropriate styling for different message types\n   - Create a message queue system to handle multiple notifications\n   - Implement auto-dismissal with configurable timeouts based on message importance\n   - Add ability for users to manually dismiss notifications\n\n3. **Form Validation Feedback**:\n   - Enhance form validation with inline error messages\n   - Implement real-time validation feedback where appropriate\n   - Add field highlighting for invalid inputs\n   - Provide clear instructions for correcting errors\n\n4. **Success Confirmations**:\n   - Design success confirmation messages for completed actions\n   - Implement visual indicators for successful operations (checkmarks, animations)\n   - Add progress indicators for longer operations\n\n5. **Offline/Connectivity Handling**:\n   - Detect and notify users of connectivity issues\n   - Implement graceful degradation when offline\n   - Provide clear recovery instructions\n\n6. **Integration with Existing Components**:\n   - Update all forms, import workflows, and authentication screens to use the new system\n   - Ensure consistent error handling across the application\n\n7. **Accessibility Considerations**:\n   - Ensure all notifications are accessible (screen reader compatible)\n   - Use appropriate ARIA attributes\n   - Implement keyboard navigation for dismissing notifications\n\n8. **Internationalization Support**:\n   - Structure error messages for easy translation\n   - Implement placeholder support for dynamic content in messages",
        "testStrategy": "1. **Unit Testing**:\n   - Write unit tests for the error handling service\n   - Test message queue functionality\n   - Verify proper error categorization and processing\n\n2. **Component Testing**:\n   - Test toast/notification components in isolation\n   - Verify proper rendering of different message types\n   - Test auto-dismissal and manual dismissal functionality\n   - Ensure proper stacking/queuing of multiple notifications\n\n3. **Integration Testing**:\n   - Test error handling across form submissions\n   - Verify API error responses are properly captured and displayed\n   - Test offline mode error handling\n   - Verify file import error handling\n\n4. **End-to-End Testing**:\n   - Create E2E tests that trigger various error conditions\n   - Test user flows with validation errors\n   - Verify success messages appear after completed actions\n\n5. **Accessibility Testing**:\n   - Test with screen readers to ensure notifications are properly announced\n   - Verify keyboard navigation works for dismissing notifications\n   - Check color contrast for different message types\n\n6. **Cross-Browser Testing**:\n   - Verify consistent behavior across Chrome, Firefox, Safari, and Edge\n   - Test on mobile browsers\n\n7. **Manual Testing Scenarios**:\n   - Simulate network failures during operations\n   - Test with various form validation errors\n   - Verify proper error handling during CSV import\n   - Test authentication error scenarios",
        "status": "pending",
        "dependencies": [224, 237, 238, 177, 175],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 243,
        "title": "Refactor Codebase to Use Relative Paths for Monorepo Structure",
        "description": "Refactor the codebase to change absolute filepaths to relative paths to better align with the monorepo structure, improving maintainability and reducing import errors.",
        "details": "This task involves systematically updating file imports throughout the codebase to use relative paths instead of absolute paths, ensuring compatibility with the monorepo architecture:\n\n1. Identify all files using absolute paths:\n   - Scan the entire codebase for import statements using absolute paths (e.g., imports starting with '@/' or '/' or referencing packages by name)\n   - Focus on key directories: apps/web, packages/server, and shared libraries\n\n2. Establish consistent path resolution rules:\n   - For imports within the same package/app: Use relative paths (e.g., `import { Component } from '../components/Component'`)\n   - For imports across packages: Use package references defined in tsconfig paths (e.g., `import { type } from '@myapp/shared'`)\n\n3. Update import statements:\n   - Replace absolute paths with relative paths\n   - Example:\n     ```typescript\n     // Before\n     import { ContactForm } from '@/components/contacts/ContactForm';\n     \n     // After\n     import { ContactForm } from '../../components/contacts/ContactForm';\n     ```\n\n4. Update tsconfig.json files:\n   - Ensure path aliases are correctly configured in all tsconfig.json files\n   - Verify baseUrl and paths settings are consistent across packages\n\n5. Update build configurations:\n   - Ensure webpack, vite, or other bundler configurations properly resolve the relative paths\n   - Update any path-related plugins or settings\n\n6. Special considerations:\n   - Handle dynamic imports correctly\n   - Ensure test files maintain correct imports\n   - Update any path utilities or helper functions that construct file paths\n\n7. Documentation:\n   - Update documentation to reflect the new path resolution strategy\n   - Create guidelines for future development to maintain consistency",
        "testStrategy": "1. Static Analysis:\n   - Run ESLint with import/no-absolute-path rule enabled to verify no absolute paths remain\n   - Use TypeScript compiler to check for any type errors resulting from path changes\n\n2. Build Verification:\n   - Run the build process for all packages to ensure no build errors\n   - Verify that all imports are correctly resolved during build time\n\n3. Runtime Testing:\n   - Start the application and navigate through major features\n   - Verify that all components load correctly without console errors related to imports\n\n4. Cross-Package Testing:\n   - Test functionality that relies on imports between different packages\n   - Verify that shared components and utilities are correctly imported and function as expected\n\n5. CI/CD Pipeline:\n   - Ensure CI/CD pipeline successfully builds and tests the application\n   - Verify that deployment processes work correctly with the updated path structure\n\n6. Code Review:\n   - Have team members review the changes to ensure consistency\n   - Verify that the established path conventions are followed throughout\n\n7. Documentation Testing:\n   - Verify that any path examples in documentation are updated\n   - Test that developer onboarding processes work with the new path structure",
        "status": "pending",
        "dependencies": [184, 210],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 244,
        "title": "Refactor Tasks Module to Emulate Things App Functionality",
        "description": "Overhaul the current tasks module in the CodexCRM application to replicate the core features, user interface, and user experience of the 'Things' app for macOS. This includes specific functionalities based on a detailed summary to be provided by the user.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "details": "This task involves a comprehensive refactoring of the existing tasks module within the CodexCRM application. The goal is to align its functionality, UI, and UX closely with the 'Things' application for macOS:\n\n1. Core Design Principles:\n   - Minimalist Interface: Clean, uncluttered design prioritizing simplicity\n   - Efficient Navigation: Every action accessible within a few clicks from any screen\n\n2. Dashboard Structure:\n   - Primary Categories:\n     1. Inbox – Default for unscheduled tasks\n     2. Today – Tasks due today\n     3. Upcoming – Tasks with future due dates\n     4. Anytime – No deadline, but need completion\n     5. Someday – No urgency, eventual completion\n     6. Logbook – Archive for completed tasks\n   - Secondary Sections:\n     - Projects – Task collections with internal headings\n     - Plus Button – For new task creation\n\n3. Task Management:\n   - Task Entry: Simple input for name, optional notes\n   - Scheduling Options:\n     - Specific Date (Today, Upcoming)\n     - Anytime, Someday, or No Date (Inbox)\n   - Additional Features:\n     - Checklists (subtasks), Tags, Notes\n     - Completion auto-moves to Logbook\n     - Editing, Deletion, and Moving between categories\n\n4. Projects:\n   - Appear in dashboard with categories\n   - Tasks can be grouped under headings\n   - Project properties: Due dates, repeat, tags, notes\n\n5. UI/UX Design:\n   - List-based navigation\n   - Plus button opens instant task entry\n   - Natural language date entry supported\n\n6. Integrations:\n   - Calendar sync (Google Calendar)\n   - Google Tasks native import\n   - Manual import from Reminders, Todoist, etc.\n\n7. AI & NLP Enhancements:\n   - NLP for auto-scheduling and contact-based suggestions\n   - AI task delegation and follow-up automation\n\n8. Technical Architecture:\n   - Organizational Hierarchy:\n     ├── Projects\n     │   ├── Headings\n     │   └── Tasks\n     └── Direct Tasks (not in projects)\n   - System Categories:\n     ├── Inbox\n     ├── Today\n     ├── Upcoming\n     ├── Anytime\n     ├── Someday\n     └── Logbook\n   - Task Schema:\n     - Core: Title, Notes, Completion Status\n     - Scheduling: Due Date, Repeat, Priority\n     - Metadata: Created/Completed Dates, Modification History\n\n9. Design Principles:\n   - Clean and intuitive UI\n   - Consistent and fast navigation\n   - Visual hierarchy for categories and projects\n   - Contextual task menus\n   - Smart defaults (Inbox for new tasks)",
        "testStrategy": "1. Functional Testing:\n   - Create tasks across all categories and verify correct placement\n   - Move tasks between states and ensure integrity\n   - Complete tasks and verify appearance in Logbook\n\n2. UI/UX Testing:\n   - Validate minimalist layout and 1-click access\n   - Confirm category and project visual clarity\n\n3. AI/NLP Testing:\n   - Test NLP-driven scheduling and contact linking\n   - Review AI-assigned tasks and automated actions\n\n4. Integration Testing:\n   - Connect Google Calendar and Google Tasks\n   - Perform manual import/export flows\n\n5. Regression Testing:\n   - Verify no existing task functionality is broken\n\n6. Usability Testing:\n   - Run through standard workflows with new UI\n   - Gather feedback from early users for refinement",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Database Schema for Things-like Task Structure",
            "description": "Create comprehensive database schema supporting the hierarchical structure of Projects > Headings > Tasks, with system categories (Inbox, Today, Upcoming, Anytime, Someday, Logbook) and all required task metadata fields. Current Status is the schema design exists as a png image at the root of the monorepo called database-schema.png Use this as the base  and follow it 100% accurately to write the migrations necessary to migrate the tables to supabase. they are currently not in the database.",
            "dependencies": [],
            "details": "Design tables for tasks, projects, headings, categories, tags, and relationships. Include fields for title, notes, completion status, due dates, repeat patterns, priority, creation/completion timestamps, and modification history. Ensure proper indexing for performance.",
            "status": "completed",
            "testStrategy": "Validate schema with sample data covering all use cases, test foreign key constraints, and verify query performance for common operations."
          },
          {
            "id": 2,
            "title": "Implement Core Task Model and Data Access Layer",
            "description": "Build the foundational data models and repository classes for tasks, projects, headings, and categories with full CRUD operations and business logic validation.",
            "dependencies": [1],
            "details": "Create model classes with proper validation, implement repository pattern for data access, add methods for task categorization, project assignment, and status transitions. Include soft delete functionality for completed tasks moving to Logbook.",
            "status": "done",
            "testStrategy": "Unit tests for all model methods, integration tests for database operations, and validation tests for business rules."
          },
          {
            "id": 3,
            "title": "Create Minimalist Dashboard UI Layout",
            "description": "Design and implement the main dashboard interface with clean, uncluttered layout featuring primary categories sidebar, main content area, and plus button for task creation.",
            "dependencies": [],
            "details": "Build responsive layout with sidebar navigation (this needs to be the main sidebar for the tasks page similar to the context based sidebars for both contacts and dashboard and is in the same style that is based onthe app-sidebar.tsx and must keep the nav-user.tsx in the sidebar at the very bottom) for Inbox, Today, Upcoming, Anytime, Someday, Logbook, and Projects. Implement visual hierarchy, consistent spacing, and Things-inspired design elements. Include collapsible sections and smooth transitions.",
            "status": "done",
            "testStrategy": "Visual regression testing, responsive design validation across devices, and accessibility compliance testing."
          },
          {
            "id": 4,
            "title": "Implement Task List Views and Navigation",
            "description": "Build dynamic task list components for each category with efficient filtering, sorting, and navigation between different views while maintaining performance.",
            "dependencies": [2, 3],
            "details": "Create reusable list components with virtual scrolling for large datasets, implement category-specific filtering logic, add smooth transitions between views, and ensure consistent task display formatting across all categories.",
            "status": "in-progress",
            "testStrategy": "Performance testing with large datasets, navigation flow testing, and UI consistency validation across all categories."
          },
          {
            "id": 5,
            "title": "Build Quick Task Entry System with Plus Button",
            "description": "Develop instant task creation interface accessible via plus button with natural language processing for date entry and smart categorization defaults.",
            "dependencies": [2, 3],
            "details": "Implement modal/inline task entry form with auto-focus, natural language date parsing (e.g., 'tomorrow', 'next week'), smart defaults for category assignment, and keyboard shortcuts for quick entry. Include validation and error handling.",
            "status": "pending",
            "testStrategy": "Test natural language parsing accuracy, validate keyboard shortcuts, and verify default categorization logic with various input scenarios."
          },
          {
            "id": 6,
            "title": "Implement Task Scheduling and Category Management",
            "description": "Build the core scheduling system that automatically categorizes tasks based on due dates and allows manual movement between categories with proper validation.",
            "dependencies": [2, 4],
            "details": "Create scheduling engine that moves tasks between Today, Upcoming, Anytime, and Someday based on due dates. Implement drag-and-drop functionality for manual categorization, add repeat task handling, and ensure proper validation for category transitions.",
            "status": "pending",
            "testStrategy": "Test automatic categorization with various date scenarios, validate manual category changes, and verify repeat task generation accuracy."
          },
          {
            "id": 7,
            "title": "Develop Projects and Headings Management System",
            "description": "Create comprehensive project management functionality allowing task grouping under projects with internal headings, project properties, and hierarchical organization.",
            "dependencies": [2, 4],
            "details": "Build project creation/editing interface, implement heading management within projects, add project-level properties (due dates, tags, notes), and create drag-and-drop task organization. Include project templates and bulk operations.",
            "status": "pending",
            "testStrategy": "Test project hierarchy operations, validate task assignment to projects/headings, and verify project-level property inheritance."
          },
          {
            "id": 8,
            "title": "Build Task Detail Management with Subtasks and Tags",
            "description": "Implement comprehensive task editing interface supporting notes, checklists (subtasks), tags, and all metadata fields with intuitive user experience.",
            "dependencies": [2, 5],
            "details": "Create expandable task detail view with rich text notes, checklist functionality for subtasks, tag management with autocomplete, priority settings, and modification history. Include keyboard shortcuts and quick actions.",
            "status": "pending",
            "testStrategy": "Test all task property modifications, validate subtask completion logic, and verify tag functionality with large tag sets."
          },
          {
            "id": 9,
            "title": "Implement Calendar Integration and External Sync",
            "description": "Build integration system for Google Calendar synchronization, Google Tasks import, and manual import capabilities from other task management applications.",
            "dependencies": [2, 6],
            "details": "Develop OAuth integration for Google Calendar, implement bidirectional sync for due dates and completion status, create import wizards for Google Tasks and other formats (CSV, JSON), and add conflict resolution for sync issues.",
            "status": "pending",
            "testStrategy": "Test OAuth flow, validate sync accuracy with various calendar scenarios, and verify import functionality with sample data from different sources."
          },
          {
            "id": 10,
            "title": "Add AI-Powered Features and Natural Language Processing",
            "description": "Integrate AI capabilities for smart task scheduling, contact-based suggestions, automated task delegation, and follow-up automation to enhance user productivity.",
            "dependencies": [2, 5, 8],
            "details": "Implement NLP for intelligent date parsing and task categorization, add AI-powered scheduling suggestions based on user patterns, create contact integration for task delegation, and build automated follow-up systems with customizable rules.",
            "status": "pending",
            "testStrategy": "Test NLP accuracy with diverse input patterns, validate AI suggestion relevance, and verify automation rules with various user scenarios."
          },
          {
            "id": 11,
            "title": "Implement Database Migration Strategy",
            "description": "Execute the migration plan to transition from the old task structure to the new 'Things'-like schema while preserving existing user data.",
            "dependencies": [1, 2],
            "details": "Implement migration scripts to transfer data from the old schema to the new one, ensuring proper mapping of tasks, categories, and metadata. Include validation checks, rollback procedures, and user communication about the migration process.",
            "status": "pending",
            "testStrategy": "Test migration with sample datasets of varying sizes, verify data integrity post-migration, and validate edge cases like incomplete or corrupted task records."
          },
          {
            "id": 12,
            "title": "Integrate Task Dependencies and History Tracking",
            "description": "Implement the task dependencies and history tracking features that were designed in the database schema.",
            "dependencies": [2, 4],
            "details": "Build UI and backend logic for creating and managing task dependencies, implement circular dependency prevention, and create a comprehensive history tracking system for all task modifications. Include visualization of dependencies and history logs in the task detail view.",
            "status": "pending",
            "testStrategy": "Test dependency creation/removal with various scenarios, validate circular dependency prevention, and verify history tracking accuracy for all types of task modifications."
          },
          {
            "id": 13,
            "title": "Enhance Existing UI Components with Interactive Features",
            "description": "Build upon the implemented UI components to add interactive features like drag-and-drop, context menus, and keyboard shortcuts.",
            "dependencies": [3, 4],
            "details": "Enhance ThingsSidebar.tsx, ThingsTaskCard.tsx, and ThingsMainContent.tsx with drag-and-drop functionality for task organization, implement context menus for quick actions, and add comprehensive keyboard shortcuts for power users. Ensure all interactions have appropriate visual feedback and accessibility support.",
            "status": "pending",
            "testStrategy": "Test drag-and-drop operations across different categories and projects, validate context menu functionality in various states, and verify keyboard shortcut effectiveness and discoverability."
          },
          {
            "id": 14,
            "title": "Create Initial Data Seeding for New Database Schema",
            "description": "Develop and implement data seeding scripts to populate the newly created database tables with initial system categories and test data.",
            "dependencies": [1],
            "details": "Create scripts to seed the database with the required system categories (Inbox, Today, Upcoming, Anytime, Someday, Logbook), add sample projects, headings, and tasks for testing purposes. Ensure proper relationships between entities and validate data integrity after seeding.",
            "status": "pending",
            "testStrategy": "Verify all system categories are properly created, test relationships between seeded entities, and validate that the seeded data follows the schema constraints and business rules."
          }
        ]
      },
      {
        "id": 245,
        "title": "Create packages/config for shared constants",
        "description": "Create a new package at packages/config to house shared application constants including route paths and authentication-related constants",
        "details": "1. Create packages/config directory structure with package.json, tsconfig.json, and index.ts\n2. Create paths.ts file exporting AUTH_PAGES array, SIGN_IN_PATH, and DASHBOARD_PATH constants\n3. Set up proper TypeScript configuration with module resolution\n4. Export all constants from index.ts for easy importing\n5. Use modern ES modules with proper type definitions",
        "testStrategy": "Verify package can be imported in other packages, constants are properly typed and exported, and TypeScript compilation succeeds without errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 246,
        "title": "Create LoadingSpinner component in packages/ui",
        "description": "Create a reusable LoadingSpinner component in the packages/ui library to serve as the global loading indicator throughout the application",
        "details": "1. Create LoadingSpinner.tsx component in packages/ui/src/components\n2. Implement centered, animated spinner using modern CSS animations or Tailwind CSS\n3. Make component accessible with proper ARIA labels\n4. Export component from packages/ui index file\n5. Use React 19 compatible patterns",
        "testStrategy": "",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 247,
        "title": "Create packages/auth with AuthProvider and useAuth hook",
        "description": "Create a new authentication package containing AuthProvider component and useAuth hook using React 19's use() hook for context consumption",
        "details": "1. Create packages/auth directory with proper package.json and TypeScript config\n2. Create provider.tsx with AuthProvider component using Supabase auth\n3. Implement useAuth hook using React 19's use() hook for context consumption\n4. Handle onAuthStateChange events from Supabase\n5. Provide user state, loading state, and auth methods\n6. Use Supabase v2 latest patterns with proper TypeScript types",
        "testStrategy": "Test AuthProvider initializes correctly, useAuth hook returns proper values, auth state changes are handled, and React 19 use() hook works as expected",
        "priority": "high",
        "dependencies": [245],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 248,
        "title": "Update pnpm-workspace.yaml for new packages",
        "description": "Update the pnpm-workspace.yaml file to recognize the new packages/config and packages/auth packages in the monorepo",
        "details": "1. Add packages/config and packages/auth to the pnpm-workspace.yaml packages array\n2. Ensure proper glob patterns are used for package discovery\n3. Verify workspace configuration follows PNPM v8+ best practices\n4. Test that pnpm install recognizes new packages\n```\n\nEnsure all new packages have proper package.json with correct naming convention",
        "testStrategy": "Run pnpm install and verify new packages are recognized, check pnpm list shows new packages, and ensure cross-package imports work correctly",
        "priority": "medium",
        "dependencies": [245, 247],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 249,
        "title": "Migrate apps/web from src/ directory structure to root-level",
        "description": "Move all contents from apps/web/src to the root of apps/web directory following Next.js 15 App Router conventions",
        "details": "1. Move apps/web/src to apps/web\n2. Move apps/web/src/lib to apps/web/lib\n3. Move any other directories from src/ to root level\n6. Remove empty src/ directory\n4. Ensure all internal imports still work after the move\n\nDirectory structure after migration:\n```\napps/web/\n├── app/\n├── components/\n├── lib/\n├── hooks/\n├── package.json\n├── tsconfig.json\n└── tailwind.config.js\n```",
        "testStrategy": "Verify all files moved correctly, no broken imports exist, Next.js can find all files in new locations, and application builds successfully",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 250,
        "title": "Update apps/web configuration files for new directory structure",
        "description": "Update tsconfig.json and tailwind.config.js in apps/web to reflect the new root-level directory structure",
        "details": "1. Update tsconfig.json paths configuration to change @/* from './src/*' to './*'\n2. Update tailwind.config.js content paths to remove src/ references\n3. Ensure all path aliases work correctly with new structure\n4. Update any other config files that reference src/ directory\n5. Test that TypeScript compilation and Tailwind CSS work properly\n\nImplementation:\n```json\n// apps/web/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  }\n}\n```\n\n```javascript\n// apps/web/tailwind.config.js\nmodule.exports = {\n  content: [\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    '../../packages/ui/src/**/*.{js,ts,jsx,tsx,mdx}'\n  ]\n}\n```",
        "testStrategy": "Verify TypeScript compilation succeeds, imports with @/ alias work correctly, Tailwind CSS classes are applied properly, and no build errors occur",
        "priority": "high",
        "dependencies": [249],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 251,
        "title": "Refactor RootLayout to pure Server Component",
        "description": "Refactor apps/web/app/layout.tsx to be a pure Server Component by removing all client-side hooks and authentication logic",
        "details": "1. Remove 'use client' directive from layout.tsx\n2. Remove all useState and useEffect hooks for auth management\n3. Remove user state management and prop drilling\n4. Keep only static HTML shell (html, body tags) and global providers\n5. Import and render new AppContent component\n6. Ensure Server Component compatibility with Next.js 15",
        "testStrategy": "Verify layout is a Server Component, no client-side hooks remain, application renders correctly, and Next.js build succeeds without warnings",
        "priority": "high",
        "dependencies": [246, 247, 250],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 252,
        "title": "Create AppContent client component for auth state management",
        "description": "Create a new AppContent.tsx client component to handle authentication state management and conditional rendering logic",
        "details": "1. Create apps/web/components/layout/AppContent.tsx with 'use client' directive\n2. Use useAuth hook to get user authentication state\n3. Use usePathname and useRouter for routing logic\n4. Implement loading state with LoadingSpinner component\n5. Handle routing rules for authenticated/unauthenticated users\n6. Conditionally render MainLayout for authenticated users on protected pages\n7. Use constants from @codexcrm/config for route paths",
        "testStrategy": "Test authentication redirects work correctly, loading states display properly, MainLayout renders for authenticated users, and routing logic handles all scenarios",
        "priority": "high",
        "dependencies": [245, 246, 247, 251],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 253,
        "title": "Update ClientProviders to include AuthProvider",
        "description": "Update the ClientProviders component in apps/web/app/providers-client.tsx to include the new AuthProvider as the top-level provider",
        "details": "1. Import AuthProvider from @codexcrm/auth package\n2. Wrap existing providers with AuthProvider as the outermost provider\n3. Ensure proper provider hierarchy with AuthProvider > TRPCReactProvider\n4. Maintain existing TanStack Query and other provider configurations\n5. Test that all providers work together correctly",
        "testStrategy": "Verify AuthProvider is the top-level provider, all existing functionality works, tRPC and TanStack Query integration remains functional, and no provider conflicts occur",
        "priority": "medium",
        "dependencies": [247, 252],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 254,
        "title": "Remove user prop from MainLayout and update related components",
        "description": "Remove the user prop from MainLayout component and update any child components that were receiving user data through prop drilling",
        "details": "1. Remove user prop from MainLayout component interface\n2. Update MainLayout to use useAuth hook instead of props\n3. Find and update any child components that were receiving user via props\n4. Replace prop drilling with useAuth hook usage in components that need user data\n5. Ensure all components that need auth state use the useAuth hook directly\n6. Test that user data is accessible throughout the component tree",
        "testStrategy": "Verify MainLayout no longer receives user prop, all components can access user data via useAuth hook, no prop drilling remains, and user data is consistent across components",
        "priority": "medium",
        "dependencies": [252, 253],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 255,
        "title": "Migrate from @supabase/auth-helpers-nextjs to @supabase/ssr Package",
        "description": "Update the application to use the new @supabase/ssr package instead of the deprecated @supabase/auth-helpers-nextjs, ensuring compatibility with Next.js App Router patterns.",
        "details": "This migration requires several key changes to the codebase:\n\n1. Install the new package:\n```bash\nnpm install @supabase/ssr\nnpm uninstall @supabase/auth-helpers-nextjs\n```\n\n2. Update the Supabase client creation in lib/supabase:\n   - Replace createClientComponentClient and createServerComponentClient with new methods\n   - Update the client creation in lib/supabase/client.ts to use the new pattern:\n   ```typescript\n   import { createBrowserClient } from '@supabase/ssr'\n\n   export const createClient = () => {\n     return createBrowserClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n     )\n   }\n   ```\n\n   - Update the server-side client in lib/supabase/server.ts:\n   ```typescript\n   import { createServerClient } from '@supabase/ssr'\n   import { cookies } from 'next/headers'\n\n   export const createClient = () => {\n     const cookieStore = cookies()\n     \n     return createServerClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n       {\n         cookies: {\n           get(name) {\n             return cookieStore.get(name)?.value\n           },\n           set(name, value, options) {\n             cookieStore.set({ name, value, ...options })\n           },\n           remove(name, options) {\n             cookieStore.set({ name, value: '', ...options })\n           },\n         },\n       }\n     )\n   }\n   ```\n\n3. Update middleware.ts to use the new package:\n   ```typescript\n   import { createServerClient } from '@supabase/ssr'\n   import { NextResponse } from 'next/server'\n   import type { NextRequest } from 'next/server'\n   \n   export async function middleware(request: NextRequest) {\n     let response = NextResponse.next({\n       request: {\n         headers: request.headers,\n       },\n     })\n     \n     const supabase = createServerClient(\n       process.env.NEXT_PUBLIC_SUPABASE_URL!,\n       process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,\n       {\n         cookies: {\n           get(name) {\n             return request.cookies.get(name)?.value\n           },\n           set(name, value, options) {\n             request.cookies.set({\n               name,\n               value,\n               ...options,\n             })\n             response = NextResponse.next({\n               request: {\n                 headers: request.headers,\n               },\n             })\n             response.cookies.set({\n               name,\n               value,\n               ...options,\n             })\n           },\n           remove(name, options) {\n             request.cookies.set({\n               name,\n               value: '',\n               ...options,\n             })\n             response = NextResponse.next({\n               request: {\n                 headers: request.headers,\n               },\n             })\n             response.cookies.set({\n               name,\n               value: '',\n               ...options,\n             })\n           },\n         },\n       }\n     )\n     \n     // Authentication logic here\n     \n     return response\n   }\n   ```\n\n4. Update authentication flows:\n   - Modify sign-in, sign-up, and sign-out functions to use the new client\n   - Update any components that use the auth helpers\n   - Ensure session handling is updated to use the new methods\n\n5. Update the AuthProvider component to use the new package:\n   - Modify the context provider to use the new client methods\n   - Update any hooks that depend on the auth helpers\n\n6. Test all authentication flows to ensure they work correctly with the new package\n   - Sign-in\n   - Sign-up\n   - Sign-out\n   - Session persistence\n   - Protected routes\n\n7. Update any documentation or comments to reflect the new package usage",
        "testStrategy": "1. Unit Testing:\n   - Create unit tests for the updated Supabase client creation functions\n   - Verify that the client is properly initialized with the correct environment variables\n   - Test that the cookie handling functions work as expected\n\n2. Integration Testing:\n   - Test the complete authentication flow (sign-up, sign-in, sign-out)\n   - Verify that sessions are properly maintained across page refreshes\n   - Test protected routes to ensure they still require authentication\n   - Verify that redirects work correctly for authenticated and unauthenticated users\n\n3. Manual Testing:\n   - Perform a complete sign-up process with a new user\n   - Test sign-in with existing credentials\n   - Verify that the user remains signed in after browser refresh\n   - Test sign-out functionality\n   - Verify that protected routes redirect unauthenticated users\n   - Test on different browsers to ensure cross-browser compatibility\n\n4. Regression Testing:\n   - Verify that all existing authentication-related features continue to work\n   - Check that user profile data is still accessible\n   - Ensure that any components that relied on the previous auth helpers still function\n\n5. Error Handling:\n   - Test error scenarios (invalid credentials, network issues)\n   - Verify that appropriate error messages are displayed\n   - Check that the application gracefully handles authentication failures\n\n6. Performance Testing:\n   - Compare authentication response times before and after the migration\n   - Ensure that the new implementation doesn't introduce performance regressions",
        "status": "pending",
        "dependencies": [4, 209, 249, 252, 253],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": 256,
        "title": "Create Dedicated MobileMenu Component",
        "description": "Extract the mobile Sheet-based navigation logic from the existing Navbar.tsx into a new MobileMenu.tsx component.",
        "details": "1. Create a new file at apps/web/components/layout/MobileMenu.tsx\n2. Extract the following from Navbar.tsx:\n   - The Sheet component and its related SheetTrigger and SheetContent\n   - All JSX related to the mobile slide-out panel\n   - The logo and navigation links for mobile view\n3. Move the mainNavItems constant into this file\n4. Implement the component structure",
        "testStrategy": "1. Render the MobileMenu component in isolation using React Testing Library\n2. Verify the Sheet, SheetTrigger, and SheetContent components are properly rendered\n3. Test that clicking the menu button opens the sheet\n4. Verify all navigation items from mainNavItems are correctly displayed\n5. Test that navigation links have the correct href attributes\n6. Ensure the component is only visible on mobile viewports using responsive testing",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 257,
        "title": "Refactor Navbar.tsx into Header.tsx",
        "description": "Rename Navbar.tsx to Header.tsx and refactor it to be the primary desktop header, delegating mobile concerns to the new MobileMenu component.",
        "details": "1. Rename the file from apps/web/components/layout/Navbar.tsx to Header.tsx\n2. Update the component's function name from Navbar to Header\n3. Remove all mobile Sheet JSX that was extracted to MobileMenu\n4. Import and render the new MobileMenu component\n5. Refactor the component to focus on desktop header responsibilities",
        "testStrategy": "1. Verify the component renders correctly with all expected elements\n2. Test that the MobileMenu component is properly imported and rendered\n3. Ensure desktop navigation links are displayed correctly and only on desktop viewports\n4. Test that the user profile and settings buttons are functional\n5. Verify the header is sticky and has the correct z-index\n6. Test that all links have the correct href attributes\n7. Update any imports in other files that referenced Navbar.tsx to now use Header.tsx",
        "priority": "high",
        "dependencies": [256],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 258,
        "title": "Implement Floating OmniBot UI (OmniBotFloat.tsx)",
        "description": "Create a new component OmniBotFloat.tsx that provides a floating action button (FAB) to trigger the AI assistant sidebar.",
        "details": "1. Create a new file at apps/web/components/layout/OmniBotFloat.tsx\n2. Implement a floating action button fixed to the bottom-right of the viewport\n3. Use Sheet components to create a floating panel that appears when the FAB is clicked\n4. Style the panel to appear as a floating element rather than a full-height sidebar\n5. Import and render the existing OmniBot component inside the panel",
        "testStrategy": "1. Render the OmniBotFloat component in isolation\n2. Verify the floating action button is positioned correctly at the bottom-right\n3. Test that clicking the FAB opens the sheet panel\n4. Ensure the panel is styled correctly with margins, rounded corners, and proper dimensions\n5. Verify the OmniBot component is properly rendered inside the panel\n6. Test that the panel can be closed\n7. Verify the z-index ensures the component appears above other page elements",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 259,
        "title": "Create Shared UserNav Component",
        "description": "Create a UserNav.tsx component that displays the current user's avatar and name/email, to be reused across different sidebars.",
        "details": "1. Create a new file at apps/web/components/layout/UserNav.tsx\n2. Use the useAuth() hook to fetch user data\n3. Design a self-contained component that displays user avatar and information\n4. Ensure it can be easily placed at the bottom of any sidebar",
        "testStrategy": "1. Render the UserNav component with a mocked useAuth hook\n2. Test with different user data scenarios (full profile, missing avatar, etc.)\n3. Verify the component correctly displays user name, email, and avatar\n4. Test that the dropdown menu opens when clicked\n5. Verify all dropdown menu items are present and functional\n6. Test that the signOut function is called when the Log out option is clicked\n7. Ensure the component returns null when no user is present",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 260,
        "title": "Create AppSidebarController Component",
        "description": "Create a new AppSidebarController.tsx component to manage the display of contextual sidebars based on the current route.",
        "details": "1. Create a new file at apps/web/components/layout/AppSidebarController.tsx\n2. Use the usePathname hook to determine the current route\n3. Implement logic to decide which sidebar to render based on the route\n4. Import all potential sidebar components",
        "testStrategy": "1. Test the component with various mocked pathname values\n2. Verify that the correct sidebar component is rendered for each route\n3. Test edge cases like unknown routes\n4. Ensure the component correctly handles nested routes\n5. Verify that the component updates when the pathname changes\n6. Test with a real router context to ensure integration with Next.js routing",
        "priority": "high",
        "dependencies": [259],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 261,
        "title": "Update ContactsSidebar Component",
        "description": "Refactor the existing ContactsSidebar.tsx to conform to the new pattern, ensuring it's a self-contained component with its specific links and includes the UserNav component.",
        "details": "1. Update the existing ContactsSidebar.tsx file\n2. Ensure it contains all contacts-specific navigation links\n3. Import and render the UserNav component at the bottom\n4. Make it a self-contained component with clear responsibilities",
        "testStrategy": "1. Render the ContactsSidebar component\n2. Verify all contact-specific navigation links are present\n3. Test that the links have the correct href attributes\n4. Ensure the UserNav component is properly imported and rendered at the bottom\n5. Verify the sidebar has the correct dimensions and styling\n6. Test that the 'New' button is present and correctly positioned\n7. Check that the component is responsive and handles overflow correctly",
        "priority": "medium",
        "dependencies": [259],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 262,
        "title": "Update TasksSidebar Component",
        "description": "Refactor the existing TasksSidebar.tsx to conform to the new pattern, ensuring it's a self-contained component with its specific links and includes the UserNav component.",
        "details": "1. Update the existing TasksSidebar.tsx file\n2. Ensure it contains all tasks-specific navigation links\n3. Import and render the UserNav component at the bottom\n4. Make it a self-contained component with clear responsibilities",
        "testStrategy": "1. Render the TasksSidebar component\n2. Verify all task-specific navigation links are present\n3. Test that the links have the correct href attributes\n4. Ensure the UserNav component is properly imported and rendered at the bottom\n5. Verify the sidebar has the correct dimensions and styling\n6. Test that the 'New' button is present and correctly positioned\n7. Check that the component is responsive and handles overflow correctly",
        "priority": "medium",
        "dependencies": [259],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 263,
        "title": "Create DashboardSidebar Component",
        "description": "Create a new DashboardSidebar.tsx component for the dashboard route, following the established pattern with specific links and the UserNav component.",
        "details": "1. Create a new file at apps/web/components/sidebars/DashboardSidebar.tsx\n2. Implement dashboard-specific navigation links\n3. Import and render the UserNav component at the bottom\n4. Follow the established pattern for sidebar components",
        "testStrategy": "1. Render the DashboardSidebar component\n2. Verify all dashboard-specific navigation links are present\n3. Test that the links have the correct href attributes\n4. Ensure the UserNav component is properly imported and rendered at the bottom\n5. Verify the sidebar has the correct dimensions and styling\n6. Check that the component is responsive and handles overflow correctly\n7. Test that the component follows the same pattern as other sidebar components",
        "priority": "medium",
        "dependencies": [259],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 264,
        "title": "Create SettingsSidebar Component",
        "description": "Create a new SettingsSidebar.tsx component for the settings route, following the established pattern with specific links and the UserNav component.",
        "details": "1. Create a new file at apps/web/components/sidebars/SettingsSidebar.tsx\n2. Implement settings-specific navigation links\n3. Import and render the UserNav component at the bottom\n4. Follow the established pattern for sidebar components",
        "testStrategy": "1. Render the SettingsSidebar component\n2. Verify all settings-specific navigation links are present\n3. Test that the links have the correct href attributes\n4. Ensure the UserNav component is properly imported and rendered at the bottom\n5. Verify the sidebar has the correct dimensions and styling\n6. Check that the component is responsive and handles overflow correctly\n7. Test that the component follows the same pattern as other sidebar components",
        "priority": "medium",
        "dependencies": [259],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 265,
        "title": "Simplify MainLayout.tsx to a Skeleton",
        "description": "Strip MainLayout.tsx down to its essential structural role, integrating all the new components to create a clean, modular layout structure.",
        "details": "1. Refactor the MainLayout.tsx file to remove all complex logic and state management\n2. Import and render the new Header, AppSidebarController, and OmniBotFloat components\n3. Define the primary page grid structure\n4. Ensure the layout is responsive and accessible",
        "testStrategy": "1. Render the MainLayout component with mock children\n2. Verify that Header, AppSidebarController, and OmniBotFloat components are properly imported and rendered\n3. Test the layout structure with different viewport sizes\n4. Ensure the main content area correctly adjusts based on sidebar presence\n5. Verify that the layout is accessible and follows best practices\n6. Test that the component is significantly simpler than the original version\n7. Perform integration tests with actual page content to ensure the layout works correctly in a real application context",
        "priority": "high",
        "dependencies": [257, 258, 260],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 266,
        "title": "Setup ESLint and Prettier with Naming Convention Rules",
        "description": "Configure ESLint and Prettier with specific naming convention rules to enforce consistency across the codebase",
        "details": "Install and configure ESLint with @typescript-eslint/naming-convention rules. Setup Prettier for consistent formatting. Create .eslintrc.js with rules for camelCase variables, PascalCase components, snake_case database fields, and kebab-case file/folder names. Configure pre-commit hooks using husky and lint-staged to enforce rules. Example ESLint config: { '@typescript-eslint/naming-convention': [{ selector: 'variableLike', format: ['camelCase'] }, { selector: 'typeLike', format: ['PascalCase'] }] }",
        "testStrategy": "Run ESLint on sample files with various naming patterns to verify rules are enforced. Test pre-commit hooks by attempting commits with naming violations.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 267,
        "title": "Create TypeScript Type Definitions for Database Schema",
        "description": "Define comprehensive TypeScript interfaces and types that map database snake_case columns to camelCase JavaScript properties",
        "details": "Create types/database.ts with interfaces for all database tables using snake_case naming. Create types/api.ts with corresponding camelCase interfaces for frontend consumption. Use utility types like CamelCase<T> or libraries like type-fest for automatic conversion. Example: interface UserRow { user_id: string; first_name: string; created_at: Date } and interface User { userId: string; firstName: string; createdAt: Date }. Leverage Supabase CLI to generate types: supabase gen types typescript --project-id YOUR_PROJECT_ID",
        "testStrategy": "Compile TypeScript without errors. Create unit tests that verify type compatibility between database and API types. Test with sample data transformations.",
        "priority": "high",
        "dependencies": [266],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 268,
        "title": "Implement Next.js 15 App Router File Structure",
        "description": "Create proper Next.js App Router file structure following kebab-case for routes and required file naming conventions",
        "details": "Create app directory structure with proper naming: app/page.tsx, app/layout.tsx, app/loading.tsx, app/error.tsx, app/not-found.tsx. Create route segments using kebab-case: app/user-profile/[user-id]/page.tsx, app/dashboard/settings/page.tsx. Implement dynamic routes with proper bracket notation. Create API routes as app/api/users/route.ts. Use Next.js 15 features like partial prerendering and improved caching. Ensure all special files use exact lowercase naming as required by App Router.",
        "testStrategy": "Test routing by navigating to all defined routes. Verify dynamic routes work with various parameters. Test loading, error, and not-found states. Use Next.js development tools to verify proper file recognition.",
        "priority": "high",
        "dependencies": [266],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 269,
        "title": "Setup React 19 Component Architecture with Naming Standards",
        "description": "Create React component architecture following PascalCase naming and proper hook conventions",
        "details": "Create components directory with PascalCase naming: components/UserProfile/UserProfileCard.tsx, components/Dashboard/DashboardLayout.tsx. Implement custom hooks with 'use' prefix: hooks/useAuth.ts, hooks/useFormValidation.ts. Follow React 19 patterns including new use() hook for data fetching, improved Suspense boundaries, and server components. Create component templates with proper prop naming (camelCase), event handlers (handleXxx), and state management (useState with setXxx). Use React.forwardRef and React.memo where appropriate.",
        "testStrategy": "Test component rendering and prop passing. Verify custom hooks work correctly with React DevTools. Test server and client components separately. Ensure proper TypeScript integration with component props.",
        "priority": "medium",
        "dependencies": [267, 268],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 270,
        "title": "Configure tRPC 11 with Proper Procedure Naming",
        "description": "Setup tRPC 11 with camelCase procedures and PascalCase input/output schemas following naming conventions",
        "details": "Install @trpc/server@11, @trpc/client@11, @trpc/next@11, and @trpc/react-query@11. Create server/routers with camelCase naming: userRouter, postRouter, authRouter. Implement procedures with descriptive verbs: getUser, createUser, updateUser, deleteUser. Use Zod for input validation with PascalCase schemas: CreateUserInput, UpdateUserInput. Setup tRPC context with proper typing. Configure Next.js API handler at app/api/trpc/[trpc]/route.ts. Implement proper error handling and middleware.",
        "testStrategy": "Test all tRPC procedures with various inputs. Verify type safety between client and server. Test error handling and validation. Use tRPC panel for API testing during development.",
        "priority": "high",
        "dependencies": [267],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 271,
        "title": "Implement TanStack Query 5 with Consistent Query Keys",
        "description": "Setup TanStack Query 5 with standardized query key patterns and proper caching strategies",
        "details": "Install @tanstack/react-query@5 and @tanstack/react-query-devtools. Create query key factory functions for consistent naming: queryKeys.users.all(), queryKeys.users.detail(id), queryKeys.posts.list(filters). Implement query and mutation hooks with proper naming: useGetUser, useCreateUser, useUpdateUser. Setup QueryClient with proper defaults for staleTime, cacheTime, and retry logic. Configure optimistic updates and proper invalidation patterns. Use TanStack Query 5 features like infinite queries and suspense integration.",
        "testStrategy": "Test query caching and invalidation. Verify optimistic updates work correctly. Test infinite queries and pagination. Use React Query DevTools to monitor cache behavior and query states.",
        "priority": "medium",
        "dependencies": [270],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 272,
        "title": "Setup Supabase Database Schema with snake_case Conventions",
        "description": "Create Supabase database schema following PostgreSQL snake_case naming conventions and implement RLS policies",
        "details": "Create database tables with snake_case naming: users, user_profiles, posts, comments. Use proper column naming: user_id, first_name, last_name, created_at, updated_at. Implement foreign key relationships with consistent naming: user_id references users(id). Create database functions using snake_case: get_user_profile(), update_user_status(). Setup Row Level Security policies with descriptive names: enable_read_access_for_authenticated_users. Use Supabase migrations for version control. Configure proper indexes for performance.",
        "testStrategy": "Test database operations through Supabase client. Verify RLS policies work correctly with different user roles. Test database functions and triggers. Run performance tests on queries with proper indexing.",
        "priority": "high",
        "dependencies": [267],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 273,
        "title": "Create Data Transformation Layer for snake_case to camelCase",
        "description": "Implement utilities to transform data between database snake_case and JavaScript camelCase conventions",
        "details": "Create utility functions for case conversion: toCamelCase(), toSnakeCase(), transformKeys(). Implement database query wrappers that automatically transform results. Use libraries like lodash.camelcase or create custom transformation functions. Setup Supabase client configuration to handle automatic case conversion. Create type-safe transformation functions that maintain TypeScript inference. Handle nested objects and arrays in transformations. Consider using libraries like humps or change-case for robust conversion.",
        "testStrategy": "Test transformation functions with various data structures. Verify type safety is maintained through transformations. Test with real database queries and API responses. Create unit tests for edge cases like nested objects and arrays.",
        "priority": "medium",
        "dependencies": [267, 272],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 274,
        "title": "Implement Shared Constants and Configuration Package",
        "description": "Create centralized configuration package with consistent naming for paths, constants, and shared values",
        "details": "Create @codexcrm/config package with shared constants: AUTH_PAGES, DASHBOARD_PATH, LOG_IN_PATH, API_ENDPOINTS. Use SCREAMING_SNAKE_CASE for constants and camelCase for configuration objects. Setup proper TypeScript exports and imports. Create environment-specific configurations. Implement validation for configuration values using Zod. Setup monorepo workspace configuration in package.json. Create proper tsconfig.json path aliases for easy imports across packages.",
        "testStrategy": "Test imports of shared constants across different packages. Verify TypeScript path resolution works correctly. Test environment-specific configuration loading. Validate configuration values with Zod schemas.",
        "priority": "medium",
        "dependencies": [266],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 275,
        "title": "Create Documentation and Style Guide",
        "description": "Document naming conventions and create comprehensive style guide for team consistency",
        "details": "Create CONTRIBUTING.md with detailed naming conventions for each technology stack. Document file structure patterns, component organization, and database schema conventions. Create examples for common patterns: React components, tRPC procedures, database queries, API routes. Setup automated documentation generation using tools like Storybook for components and Swagger/OpenAPI for APIs. Create naming convention checklists for code reviews. Include migration guides for converting existing code to follow conventions.",
        "testStrategy": "Review documentation with team members for clarity and completeness. Test examples provided in documentation. Verify automated documentation generation works correctly. Create onboarding checklist to test documentation effectiveness.",
        "priority": "low",
        "dependencies": [266, 267, 268, 269, 270, 271, 272, 273, 274],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 276,
        "title": "Finalize MainLayout.tsx for Floating Sidebar",
        "description": "Modify the main layout to support the 'floating' sidebar aesthetic by adding padding around the SidebarInset component.",
        "details": "1. Open `apps/web/components/layout/MainLayout.tsx`\n2. Locate the root div element\n3. Add a background color or gradient (e.g., `bg-muted/40`) to create contrast for the floating elements\n4. Find the `<SidebarInset>` component\n5. Add padding classes (e.g., `p-2` or `p-4`) to create margin between the sidebar content and the edges\n6. Ensure the layout maintains responsiveness across different screen sizes\n7. Test the visual appearance to confirm the floating effect is achieved",
        "testStrategy": "1. Visually inspect the layout in different viewport sizes to ensure the floating effect is consistent\n2. Verify that the sidebar appears to float above the background\n3. Check that the padding is applied correctly and creates the intended visual separation\n4. Test in multiple browsers to ensure cross-browser compatibility",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 277,
        "title": "Finalize sidebar.tsx for Floating Style",
        "description": "Modify the sidebar.tsx component to give the sidebar rounded corners, making it appear to float.",
        "details": "1. Open `apps/web/components/ui/sidebar.tsx`\n2. Locate the `<div data-sidebar=\"sidebar\" ...>` element within the Sidebar component\n3. Add `rounded-lg` or `rounded-xl` to its class list to round the corners\n4. Consider adding a subtle shadow effect (e.g., `shadow-md`) to enhance the floating appearance\n5. Ensure the rounded corners are consistent with the design language of the application\n6. Verify that the modifications don't break any existing sidebar functionality",
        "testStrategy": "1. Visually inspect the sidebar to confirm the rounded corners are applied correctly\n2. Test the sidebar in both expanded and collapsed states to ensure the floating style is maintained\n3. Verify that the sidebar still functions correctly after the style changes\n4. Check the appearance in different browsers to ensure consistent rendering",
        "priority": "high",
        "dependencies": [276],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 278,
        "title": "Create DashboardSidebar.tsx using Demo Content",
        "description": "Create the specific sidebar for the Dashboard section using placeholder navigation components that were downloaded with the sidebar-07 block.",
        "details": "1. Create a new file at `apps/web/components/layout/sidebars/DashboardSidebar.tsx`\n2. Import the necessary components from ui/sidebar.tsx: `SidebarHeader`, `SidebarContent`, and `SidebarFooter`\n3. Import the placeholder navigation components: `NavMain` and `NavProjects`\n4. Structure the component as follows:\n```tsx\nexport function DashboardSidebar() {\n  return (\n    <>\n      <SidebarHeader>\n        {/* Brand logo/name */}\n        <SidebarTrigger />\n      </SidebarHeader>\n      <SidebarContent>\n        <NavMain />\n        <NavProjects />\n      </SidebarContent>\n      <SidebarFooter>\n        <UserNav />\n      </SidebarFooter>\n    </>\n  );\n}\n```\n5. Ensure the component is exported properly for use in the AppSidebarController",
        "testStrategy": "1. Verify that the DashboardSidebar component renders without errors\n2. Check that all imported components (NavMain, NavProjects, etc.) display correctly\n3. Test the sidebar's responsiveness and interaction with the SidebarTrigger\n4. Ensure the UserNav component in the footer functions as expected",
        "priority": "medium",
        "dependencies": [277],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 279,
        "title": "Create the Dashboard Page Entry Point",
        "description": "Create the main server component for the dashboard route (/), which will serve as the application's homepage, replacing the old redirect logic.",
        "details": "1. Create or update `apps/web/app/page.tsx`\n2. Import the necessary components including PageHeader and the new DashboardWidgets component\n3. Structure the component as follows:\n```tsx\nimport { PageHeader } from '@/components/layout/PageHeader';\nimport { DashboardWidgets } from '@/app/dashboard/components/DashboardWidgets';\n\nexport default function DashboardPage() {\n  return (\n    <>\n      <PageHeader breadcrumbs={[{ label: 'Dashboard' }]} />\n      <main className=\"p-4 md:p-6\">\n        <DashboardWidgets />\n      </main>\n    </>\n  );\n}\n```\n4. Ensure the page is properly configured as a Next.js server component\n5. Remove any old redirect logic that was previously used for the homepage",
        "testStrategy": "1. Verify that the dashboard page renders correctly at the root URL (/)\n2. Check that the PageHeader displays the correct breadcrumb\n3. Ensure the DashboardWidgets component is properly imported and rendered\n4. Test navigation to and from the dashboard page to confirm routing is working correctly",
        "priority": "high",
        "dependencies": [278],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 280,
        "title": "Create DashboardWidgets.tsx Container",
        "description": "Create a container component that lays out the five primary dashboard widgets using a responsive CSS grid.",
        "details": "1. Create a new file at `apps/web/app/dashboard/components/DashboardWidgets.tsx`\n2. Import the five widget components (to be created in the next task)\n3. Implement a responsive grid layout using Tailwind CSS:\n```tsx\nexport function DashboardWidgets() {\n  return (\n    <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-4\">\n      {/* First row: spans 2 columns on large screens */}\n      <div className=\"lg:col-span-2\">\n        <AiClientInsights />\n      </div>\n      <div>\n        <DailyInspirationCard />\n      </div>\n      \n      {/* Second row */}\n      <div>\n        <TherapistCheckIn />\n      </div>\n      <div>\n        <UpcomingAppointments />\n      </div>\n      <div>\n        <KeyMetrics />\n      </div>\n    </div>\n  );\n}\n```\n4. Ensure the grid is responsive and adapts well to different screen sizes\n5. Consider adding gap spacing between widgets for better visual separation",
        "testStrategy": "1. Test the responsive behavior of the grid layout across different viewport sizes\n2. Verify that the widgets are arranged correctly in both mobile and desktop views\n3. Check that the grid maintains proper spacing and alignment\n4. Ensure all widget components are properly imported and rendered",
        "priority": "medium",
        "dependencies": [279],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 281,
        "title": "Implement the 5 Dashboard Widget Components",
        "description": "Create the five individual, self-contained widget components for the dashboard: AiClientInsights, DailyInspirationCard, TherapistCheckIn, UpcomingAppointments, and KeyMetrics.",
        "details": "1. Create a new folder at `apps/web/app/dashboard/components/widgets/`\n2. Create the following component files:\n\n**AiClientInsights.tsx:**\n```tsx\n'use client';\nimport { Carousel, CarouselContent, CarouselItem, CarouselNext, CarouselPrevious } from '@codexcrm/ui/components/ui/carousel';\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\n\n// Mock data - replace with actual API call later\nconst mockInsights = [\n  { id: 1, title: 'Client Engagement', content: 'Sarah has missed 2 consecutive appointments. Consider reaching out.' },\n  { id: 2, title: 'Treatment Progress', content: 'Alex has shown significant improvement in anxiety symptoms over the last month.' },\n];\n\nexport function AiClientInsights() {\n  return (\n    <Card className=\"h-full\">\n      <CardHeader>\n        <CardTitle>AI Client Insights</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <Carousel>\n          <CarouselContent>\n            {mockInsights.map((insight) => (\n              <CarouselItem key={insight.id}>\n                <div className=\"p-1\">\n                  <Card>\n                    <CardHeader>\n                      <CardTitle className=\"text-sm font-medium\">{insight.title}</CardTitle>\n                    </CardHeader>\n                    <CardContent>{insight.content}</CardContent>\n                  </Card>\n                </div>\n              </CarouselItem>\n            ))}\n          </CarouselContent>\n          <CarouselPrevious />\n          <CarouselNext />\n        </Carousel>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n**DailyInspirationCard.tsx:**\n```tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\n\nexport function DailyInspirationCard() {\n  return (\n    <Card className=\"h-full bg-primary/10\">\n      <CardHeader>\n        <CardTitle>Daily Inspiration</CardTitle>\n      </CardHeader>\n      <CardContent className=\"flex flex-col items-center justify-center space-y-4\">\n        <blockquote className=\"text-lg italic text-center\">\n          \"The good life is a process, not a state of being. It is a direction, not a destination.\"\n        </blockquote>\n        <cite className=\"font-medium\">— Carl Rogers</cite>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n**TherapistCheckIn.tsx:**\n```tsx\n'use client';\nimport { useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\nimport { Button } from '@codexcrm/ui/components/ui/button';\n\nexport function TherapistCheckIn() {\n  const [mood, setMood] = useState<string | null>(null);\n  const [connections, setConnections] = useState<number | null>(null);\n  \n  return (\n    <Card className=\"h-full\">\n      <CardHeader>\n        <CardTitle>Daily Check-In</CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div>\n          <p className=\"mb-2 font-medium\">How are you feeling today?</p>\n          <div className=\"flex space-x-2\">\n            {['Great', 'Good', 'Okay', 'Stressed'].map((option) => (\n              <Button \n                key={option} \n                variant={mood === option ? 'default' : 'outline'}\n                onClick={() => setMood(option)}\n                size=\"sm\"\n              >\n                {option}\n              </Button>\n            ))}\n          </div>\n        </div>\n        \n        <div>\n          <p className=\"mb-2 font-medium\">Client connections today:</p>\n          <div className=\"flex space-x-2\">\n            {[0, 1, 2, 3, '4+'].map((option) => (\n              <Button \n                key={option.toString()} \n                variant={connections === option ? 'default' : 'outline'}\n                onClick={() => setConnections(typeof option === 'string' ? 4 : option)}\n                size=\"sm\"\n              >\n                {option}\n              </Button>\n            ))}\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n**UpcomingAppointments.tsx:**\n```tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\n\n// Mock data - replace with actual API call later\nconst mockAppointments = [\n  { id: 1, client: 'Emma Thompson', time: '10:00 AM', type: 'Initial Consultation' },\n  { id: 2, client: 'James Wilson', time: '11:30 AM', type: 'Follow-up' },\n  { id: 3, client: 'Sophia Garcia', time: '2:15 PM', type: 'Therapy Session' },\n];\n\nexport function UpcomingAppointments() {\n  return (\n    <Card className=\"h-full\">\n      <CardHeader>\n        <CardTitle>Today's Appointments</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-4\">\n          {mockAppointments.map((appointment) => (\n            <div key={appointment.id} className=\"flex justify-between items-center border-b pb-2\">\n              <div>\n                <p className=\"font-medium\">{appointment.client}</p>\n                <p className=\"text-sm text-muted-foreground\">{appointment.type}</p>\n              </div>\n              <div className=\"text-right\">\n                <p className=\"font-medium\">{appointment.time}</p>\n              </div>\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n```\n\n**KeyMetrics.tsx:**\n```tsx\nimport { Card, CardContent, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\n\n// Mock data - replace with actual API call later\nconst mockMetrics = [\n  { id: 1, label: 'Weekly Revenue', value: '$2,850', change: '+12%' },\n  { id: 2, label: 'Client Retention', value: '94%', change: '+2%' },\n  { id: 3, label: 'New Clients', value: '6', change: 'Same' },\n];\n\nexport function KeyMetrics() {\n  return (\n    <Card className=\"h-full\">\n      <CardHeader>\n        <CardTitle>Key Metrics</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"space-y-4\">\n          {mockMetrics.map((metric) => (\n            <div key={metric.id} className=\"flex justify-between items-center\">\n              <p className=\"text-muted-foreground\">{metric.label}</p>\n              <div className=\"text-right\">\n                <p className=\"font-medium text-lg\">{metric.value}</p>\n                <p className={`text-xs ${metric.change.includes('+') ? 'text-green-500' : 'text-muted-foreground'}`}>\n                  {metric.change}\n                </p>\n              </div>\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n```",
        "testStrategy": "1. Verify that each widget component renders correctly and matches the design requirements\n2. Test the interactive components (TherapistCheckIn buttons, AiClientInsights carousel) to ensure they function properly\n3. Check that the mock data is displayed correctly in each widget\n4. Verify responsive behavior of each widget on different screen sizes\n5. Test accessibility features like keyboard navigation for interactive elements\n6. Ensure that the components are properly exported and can be imported by the DashboardWidgets container",
        "priority": "high",
        "dependencies": [280],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 282,
        "title": "Update MainSectionNav.tsx",
        "description": "Update the main header navigation to include the new 'Marketing' section.",
        "details": "1. Open `apps/web/components/layout/MainSectionNav.tsx`\n2. Locate the mainNavItems array\n3. Add a new item to the array:\n```tsx\n{ title: 'Marketing', href: '/marketing', icon: ShoppingBag }\n```\n4. Ensure the ShoppingBag icon is imported from the appropriate icon library:\n```tsx\nimport { ShoppingBag } from 'lucide-react'; // or your preferred icon library\n```\n5. Verify that the navigation item appears correctly in the header\n6. Check that the link navigates to the correct route",
        "testStrategy": "1. Verify that the Marketing navigation item appears in the header\n2. Test that clicking the item navigates to the /marketing route\n3. Check that the icon displays correctly\n4. Ensure the navigation maintains proper spacing and alignment with the new item added\n5. Test the responsive behavior of the header with the additional navigation item",
        "priority": "medium",
        "dependencies": [276],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 283,
        "title": "Create Marketing Placeholder Page",
        "description": "Create the placeholder page for the new Marketing section with a 'Coming Soon' message and a brief preview of future marketing features.",
        "details": "1. Create a new file at `apps/web/app/marketing/page.tsx`\n2. Import the necessary components including PageHeader\n3. Structure the component as follows:\n```tsx\nimport { PageHeader } from '@/components/layout/PageHeader';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@codexcrm/ui/components/ui/card';\n\nexport default function MarketingPage() {\n  return (\n    <>\n      <PageHeader breadcrumbs={[{ label: 'Marketing' }]} />\n      <main className=\"p-4 md:p-6\">\n        <Card className=\"max-w-3xl mx-auto\">\n          <CardHeader>\n            <CardTitle>Marketing Hub</CardTitle>\n            <CardDescription>Coming Soon</CardDescription>\n          </CardHeader>\n          <CardContent className=\"space-y-4\">\n            <p>The Marketing Hub will provide tools to help grow your practice, including:</p>\n            <ul className=\"list-disc pl-6 space-y-2\">\n              <li>Email campaign management</li>\n              <li>Social media scheduling</li>\n              <li>Content creation tools</li>\n              <li>Client acquisition analytics</li>\n              <li>Referral program management</li>\n            </ul>\n            <p className=\"text-muted-foreground italic mt-6\">This section is currently under development and will be available in a future update.</p>\n          </CardContent>\n        </Card>\n      </main>\n    </>\n  );\n}\n```\n4. Ensure the page is properly configured as a Next.js server component",
        "testStrategy": "1. Verify that the Marketing page renders correctly at the /marketing route\n2. Check that the PageHeader displays the correct breadcrumb\n3. Ensure the 'Coming Soon' message and feature preview are displayed correctly\n4. Test navigation to and from the Marketing page to confirm routing is working correctly\n5. Verify the page layout is responsive across different screen sizes",
        "priority": "low",
        "dependencies": [282],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 284,
        "title": "Create a Project README.md",
        "description": "Create a README.md file in the apps/web directory to document the new architecture for future developers.",
        "details": "1. Create a new file at `apps/web/README.md`\n2. Structure the documentation to include the following sections:\n\n```markdown\n# Web Application Architecture\n\nThis document outlines the architecture and component structure of the web application.\n\n## Core Layout Components\n\n### MainLayout\n\nThe `MainLayout` component is the root layout for the application. It provides the overall structure including the floating sidebar and main content area.\n\n**Location:** `components/layout/MainLayout.tsx`\n\n### AppContent\n\nThe `AppContent` component renders the main content area of the application, including the header and the page content.\n\n**Location:** `components/layout/AppContent.tsx`\n\n### AppSidebarController\n\nThe `AppSidebarController` determines which sidebar to display based on the current route. It dynamically imports the appropriate sidebar component.\n\n**Location:** `components/layout/AppSidebarController.tsx`\n\n### PageHeader\n\nThe `PageHeader` component displays the page title, breadcrumbs, and any page-specific actions.\n\n**Location:** `components/layout/PageHeader.tsx`\n\n## File Structure\n\nThe application follows these conventions:\n\n- Components use PascalCase for both filenames and component names\n- Page components are defined in `page.tsx` files within their respective route directories\n- Shared UI components are in `components/ui/`\n- Layout components are in `components/layout/`\n- Section-specific components are organized in directories under their respective route folders\n\n## Adding a New Section\n\nTo add a new section to the application:\n\n1. Create a new directory for the section under `app/` (e.g., `app/new-section/`)\n2. Create a `page.tsx` file in this directory\n3. Create a sidebar component in `components/layout/sidebars/NewSectionSidebar.tsx`\n4. Add the new section to the `AppSidebarController` component\n5. Add the section to the navigation in `components/layout/MainSectionNav.tsx`\n\n## Dashboard Widgets\n\nThe dashboard uses a modular widget system. Widgets are self-contained components that display specific information or functionality.\n\n**Location:** `app/dashboard/components/widgets/`\n\nTo add a new widget:\n\n1. Create a new component in the widgets directory\n2. Import and add it to the grid in `DashboardWidgets.tsx`\n```\n\n3. Ensure the README is comprehensive but concise, focusing on the most important architectural aspects\n4. Include any additional information that would be helpful for new developers joining the project",
        "testStrategy": "1. Review the README for clarity, completeness, and accuracy\n2. Verify that all key components and architectural concepts are documented\n3. Check that the file structure conventions are clearly explained\n4. Ensure the instructions for adding new sections are complete and easy to follow\n5. Have another team member review the documentation for any gaps or unclear explanations",
        "priority": "low",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 285,
        "title": "Scan Monorepo File System for Code Files and Directory Structure",
        "description": "Run CLI commands to collect file paths matching specified patterns and aggregate into a JSON report with focus on CodexApp core components.",
        "details": "Execute `find . -type f -name '*.tsx'` and `find app -type f -name 'page.tsx'` commands to gather file paths. Aggregate results into a JSON file with keys for each file pattern. Priority focus on the 8 main sections: Dashboard, Contacts, Tasks, Messages, Calendar, Marketing, Analytics, Settings. Also prioritize core components: layout.tsx, appcontent.tsx, mainlayout.tsx, appsidebarcontroller.tsx, omnibot.tsx, mainsectionnav.tsx, and section sidebars (contactssection, settingssidebar, etc.). The JSON should include arrays of file paths for each pattern with special categorization for business-critical vs generic components.",
        "testStrategy": "Confirm the JSON report contains a verified list of files by comparing with manual `find` command results. Ensure counts match and core application components are properly categorized.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Run CLI command for TSX files discovery",
            "description": "Execute find commands to collect all TSX file paths",
            "dependencies": [],
            "details": "Run `find . -type f -name '*.tsx'` and `find app -type f -name 'page.tsx'` to collect file paths",
            "status": "pending",
            "testStrategy": "Verify command execution and output capture"
          },
          {
            "id": 2,
            "title": "Aggregate results into JSON with CodexApp categorization",
            "description": "Process file paths and categorize by application section and component criticality",
            "dependencies": [1],
            "details": "Aggregate results into a JSON file with keys for each file pattern, special focus on the 8 main sections and core components",
            "status": "pending",
            "testStrategy": "Validate JSON structure and component categorization"
          }
        ]
      },
      {
        "id": 286,
        "title": "Identify Naming Convention Violations in Code Files",
        "description": "Check file names against regex pattern for naming conventions and generate a Markdown report of violations with business-critical component prioritization.",
        "details": "For each file in `src/components/**` and `app/**/page.tsx` from the JSON file list (Task 285 output), use regex `^[A-Z][a-zA-Z0-9]+\\.tsx$` to validate file names. Generate a Markdown report with sections for: file path, expected pattern, violation status, and application section (Dashboard, Contacts, Tasks, Messages, Calendar, Marketing, Analytics, Settings). Prioritize violations in core navigation components (AppSidebarController, MainLayout, UserNav) and authentication flow components first.",
        "testStrategy": "Validate that each file name is checked against the regex. The Markdown report must list all deviations with business impact assessment. Re-run the check on a sample to confirm accuracy.",
        "priority": "medium",
        "dependencies": [285],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Apply regex validation to core application components",
            "description": "Check file names against naming convention regex with business-critical priority",
            "dependencies": [],
            "details": "For each file in specified directories, use regex matcher to check compliance and categorize by application section",
            "status": "pending",
            "testStrategy": "Regex validation accuracy and application section categorization correctness"
          },
          {
            "id": 2,
            "title": "Generate Markdown report with business impact assessment",
            "description": "Create comprehensive violations report with business criticality scoring",
            "dependencies": [1],
            "details": "Generate Markdown report recording violations, file paths, and business impact scores for core vs generic components",
            "status": "pending",
            "testStrategy": "Markdown format validation and impact scoring accuracy"
          }
        ]
      },
      {
        "id": 287,
        "title": "Validate App Router Compliance for Next.js 15 Standards",
        "description": "Analyze app router files for compliance with Next.js 15 structural conventions focusing on authentication flow and main section routing optimization.",
        "details": "Scan `app/*/page.tsx` and `app/*/layout.tsx` files with special attention to protected/unprotected page routing: dashboard (protected), login/signup (unprotected with auth redirects), and the 8 main sections with nested routing (contacts/groups, messages/email, settings/billing, etc.). Use a custom script or linter to verify each directory contains a page.tsx and optionally layout.tsx following Next.js 15 patterns. Ensure proper auth redirects, loading states for protected pages, and optimal routing for sidebar navigation efficiency. Output a JSON report with directory compliance status and deviations.",
        "testStrategy": "Verify the JSON report indicates 100% compliance with special validation for auth flow and section routing patterns. Manually check protected page samples to confirm script accuracy.",
        "priority": "medium",
        "dependencies": [285],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Execute App Router compliance check with auth flow focus",
            "description": "Run automated linter on page and layout files with protected/unprotected route prioritization",
            "dependencies": [],
            "details": "Execute automated linter or custom script focusing on auth flow and main section routing patterns",
            "status": "pending",
            "testStrategy": "Linter execution and auth flow route pattern validation"
          },
          {
            "id": 2,
            "title": "Compile routing compliance report with auth patterns",
            "description": "Generate JSON report with authentication flow and section routing compliance details",
            "dependencies": [1],
            "details": "Compile results into JSON report detailing directory compliance with auth flow and nested routing considerations",
            "status": "pending",
            "testStrategy": "JSON report accuracy and auth flow compliance verification"
          }
        ]
      },
      {
        "id": 288,
        "title": "Identify and Report Dead Code in the Monorepo",
        "description": "Run ESLint to detect unused variables and functions with focus on deprecated features and unused business logic across the 8 main sections.",
        "details": "Execute `npx eslint **/*.tsx --rule 'no-unused-vars: error'` to capture dead code warnings. Parse the ESLint output into a JSON report with file paths, line numbers, and dead code segments. Special focus on identifying unused utility functions, deprecated authentication methods, obsolete sidebar components, unused dashboard widgets, and deprecated notification/toast implementations. Categorize dead code by application section and business impact.",
        "testStrategy": "Validate the report logs unused variables/functions with application context. Check known deprecated authentication and notification features to ensure detection. Verify business logic categorization accuracy.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Run ESLint with application section focus",
            "description": "Execute ESLint and capture output with focus on core business logic components",
            "dependencies": [],
            "details": "Run ESLint with no-unused-vars rule and capture output, prioritizing main application sections",
            "status": "pending",
            "testStrategy": "ESLint execution and core component coverage verification"
          },
          {
            "id": 2,
            "title": "Parse output with business impact categorization",
            "description": "Structure ESLint output into JSON with application section and business logic assessment",
            "dependencies": [1],
            "details": "Parse ESLint output into structured JSON with business impact categories by application section",
            "status": "pending",
            "testStrategy": "JSON structure validation and business impact accuracy"
          }
        ]
      },
      {
        "id": 289,
        "title": "Establish a Performance Baseline for the Current Monorepo Build",
        "description": "Build the Next.js application with profiling to capture baseline performance metrics focusing on core user journey scenarios.",
        "details": "Run `npx next build --profile` to generate performance metrics (build time, bundle size, TTI). Extract and structure the profiling data into a JSON baseline report with special focus on critical user scenarios: authentication flow (login → dashboard redirect), sidebar navigation responsiveness, protected page loading, main section transitions (Dashboard → Contacts → Tasks, etc.), and core component rendering (AppSidebarController, MainLayout, Omnibot). Include metrics for nested routing performance and toast notification responsiveness.",
        "testStrategy": "Confirm the JSON report includes key metrics with core user journey benchmarks. Ensure baseline values are recorded for authentication flow and main section navigation, stored securely for future comparison.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Execute Next.js build with user journey profiling",
            "description": "Run profiling build with focus on authentication and navigation scenarios",
            "dependencies": [],
            "details": "Execute `npx next build --profile` and capture performance logs with user journey scenario focus",
            "status": "pending",
            "testStrategy": "Build execution and user journey scenario profiling verification"
          },
          {
            "id": 2,
            "title": "Structure application-focused baseline report",
            "description": "Extract and organize profiling data with core user flow performance metrics",
            "dependencies": [1],
            "details": "Extract and structure profiling data into JSON baseline report with application-specific metrics",
            "status": "pending",
            "testStrategy": "JSON structure validation and core metrics completeness"
          }
        ]
      },
      {
        "id": 290,
        "title": "Perform Risk Assessment on Code Modules Based on Audit Findings",
        "description": "Compute risk scores for modules based on naming violations and performance impact with application continuity focus.",
        "details": "Use the Markdown naming violations report (Task 286) and JSON performance baseline (Task 289). Run static analysis for code complexity with special attention to authentication flow logic, sidebar navigation components, protected page routing, and core user journey components. Combine data to calculate a risk score (1-10) per module based on violation density, performance impact, and application criticality. Prioritize modules handling authentication, navigation (AppSidebarController), main layout rendering, and the 8 main section entry points. Output a JSON risk assessment report with business continuity categorization.",
        "testStrategy": "Confirm each module has a risk score with application context. Validate that scores correlate with violation density, performance impact, and user journey criticality.",
        "priority": "medium",
        "dependencies": [286, 289],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Run static analysis with core application logic focus",
            "description": "Compute code complexity metrics with authentication and navigation workflow prioritization",
            "dependencies": [],
            "details": "Run static analysis tool to compute complexity metrics for each module with core application focus",
            "status": "pending",
            "testStrategy": "Static analysis execution and core workflow coverage"
          },
          {
            "id": 2,
            "title": "Calculate application-weighted risk scores",
            "description": "Combine audit data to create risk scores with business continuity impact weighting",
            "dependencies": [1],
            "details": "Combine naming and performance data with application criticality to calculate risk scores",
            "status": "pending",
            "testStrategy": "Risk score accuracy and business continuity impact correlation"
          }
        ]
      },
      {
        "id": 291,
        "title": "Score Module Impact and Estimate Refactoring Effort",
        "description": "Assign impact scores and estimate refactoring effort per module with application value prioritization.",
        "details": "Use dead code report (Task 288) and risk assessment (Task 290). Map each module to an impact score using a standardized matrix weighted for application value: authentication flow reliability, navigation responsiveness, main section performance, toast notification system efficiency, and protected page loading speed. Estimate refactoring effort (hours) based on lines of code, interdependency density, and business logic complexity. Prioritize core user journey components and the 8 main sections. Output a Markdown report with module, impact score, effort, application section, and priority.",
        "testStrategy": "Validate each module has an impact score and effort estimate with application justification. Check that estimates are numerically defined, reasonable, and aligned with user journey priorities.",
        "priority": "medium",
        "dependencies": [288, 290],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Map modules to application impact scores",
            "description": "Assign quantitative impact scores using application-weighted standardized matrix",
            "dependencies": [],
            "details": "Map each module to impact score using standardized matrix with application value weighting",
            "status": "pending",
            "testStrategy": "Impact scoring accuracy and application alignment"
          },
          {
            "id": 2,
            "title": "Estimate refactoring effort with application complexity factors",
            "description": "Calculate effort estimates incorporating core business logic complexity",
            "dependencies": [1],
            "details": "Estimate refactoring effort based on LOC, dependencies, and application business logic complexity",
            "status": "pending",
            "testStrategy": "Effort estimation accuracy and application complexity factor validation"
          }
        ]
      },
      {
        "id": 292,
        "title": "Map Inter-module Dependencies Within the Monorepo",
        "description": "Generate a dependency graph and JSON map of module dependencies with application workflow visualization.",
        "details": "Run `npx madge --json .` to generate a JSON dependency map. Convert the JSON to Graphviz DOT format for visualization with special highlighting of core application workflow dependencies: authentication flow (login → dashboard → protected pages), sidebar navigation dependencies (AppSidebarController → section sidebars), main layout component relationships, and cross-section data flow. Include application-specific dependency categorization and critical path identification for user journey continuity. Output both JSON and DOT files with workflow annotations.",
        "testStrategy": "Confirm the JSON map lists correct dependencies with application workflow context. Run `npx madge --json .` and compare output. Check that the DOT file is valid and includes application workflow visualization.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Execute madge with application workflow focus",
            "description": "Generate JSON dependency mapping with core user journey context",
            "dependencies": [],
            "details": "Execute madge to generate JSON dependency mapping with application workflow identification",
            "status": "pending",
            "testStrategy": "Madge execution and application workflow dependency detection"
          },
          {
            "id": 2,
            "title": "Convert to DOT format with workflow visualization",
            "description": "Create Graphviz visualization highlighting core application workflows",
            "dependencies": [1],
            "details": "Convert JSON output to Graphviz DOT format with application workflow annotations",
            "status": "pending",
            "testStrategy": "DOT format validation and workflow visualization accuracy"
          }
        ]
      },
      {
        "id": 293,
        "title": "Execute Automated Code Fixes for Naming Convention Violations",
        "description": "Automatically rename files to comply with naming conventions prioritizing core navigation and authentication components.",
        "details": "Use the Markdown violations report (Task 286) to identify files with priority on core application components: authentication flow, sidebar navigation (AppSidebarController, section sidebars), main layout components, and the 8 main section entry points. Run an automated renaming script that applies regex-based renames to make file names match `^[A-Z][a-zA-Z0-9]+\\.tsx$`. Ensure component naming reflects functionality (ContactsSection, TasksSidebar, DashboardLayout, etc.). Log all changes in JSON with business impact assessment and update import statements across the codebase.",
        "testStrategy": "Re-run the file scanner (Task 285) to confirm updated file names conform and maintain application context. Check that all violations are resolved and component names reflect their functionality within the application.",
        "priority": "medium",
        "dependencies": [286],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Run automated renaming with application context",
            "description": "Execute renaming script prioritizing core application component functionality naming",
            "dependencies": [],
            "details": "Run automated renaming script with regex-based renames and application context",
            "status": "done",
            "testStrategy": "Renaming execution and functional naming validation"
          },
          {
            "id": 2,
            "title": "Perform file system diff with component verification",
            "description": "Validate naming changes and component functionality appropriateness",
            "dependencies": [1],
            "details": "Perform file system diff to confirm updated names conform and reflect component function",
            "status": "done",
            "testStrategy": "File system validation and functional naming accuracy"
          }
        ]
      },
      {
        "id": 294,
        "title": "Refactor App Router Components to Align with Next.js 15 Standards",
        "description": "Update app router files to Next.js 15 patterns with authentication flow and navigation optimization.",
        "details": "Apply an AST transformation script to update `page.tsx` and `layout.tsx` files to Next.js 15 standards (e.g., export defaults, metadata) with special focus on application experience: proper metadata for protected/unprotected pages, loading states for authentication transitions, error boundaries for the 8 main sections, and performance optimization for sidebar navigation and nested routing. Ensure proper metadata for main sections, implement Suspense boundaries for data loading, and optimize routing for authentication flow efficiency. Enhance toast integration with Sonner for better user feedback. Run `npx next build` to ensure no routing errors. Output a JSON change log with user experience improvements.",
        "testStrategy": "Run `npx next build` to confirm no errors with special validation for authentication flow and section navigation. Check the JSON report for successful transformations and user experience enhancements.",
        "priority": "medium",
        "dependencies": [287],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Apply AST transformation with authentication and navigation focus",
            "description": "Update app router files with Next.js 15 patterns and application optimizations",
            "dependencies": [],
            "details": "Apply AST transformation script with user experience optimizations and Next.js 15 patterns",
            "status": "done",
            "testStrategy": "AST transformation execution and user experience enhancement validation"
          },
          {
            "id": 2,
            "title": "Execute build validation for authentication workflows",
            "description": "Validate Next.js build success with authentication flow and section navigation testing",
            "dependencies": [1],
            "details": "Execute Next.js build and validate authentication routing and section navigation functionality",
            "status": "done",
            "testStrategy": "Build validation and workflow functionality verification"
          }
        ]
      },
      {
        "id": 295,
        "title": "Migrate React Components to Leverage React 19 Features",
        "description": "Update React components to use React 19 features with authentication and navigation optimization.",
        "details": "Scan `src/components/**` files for legacy patterns with priority on core application components: authentication forms (login/signup), protected page wrappers, sidebar navigation components (AppSidebarController, section sidebars), main layout components (MainLayout, AppContent), dashboard widgets, and toast notification implementations. Run an automated transformation to update hooks and patterns to React 19 with focus on Server Components for improved loading, Suspense integration for protected page transitions, concurrent features for better navigation responsiveness, and optimized state management for authentication flow. Implement React 19 form actions for auth forms and enhance Sonner toast integration. Output a JSON change log identifying components updated with application-specific optimizations.",
        "testStrategy": "Run unit tests and static analysis to confirm React 19 compliance with authentication and navigation validation. Check the change log for updated components and application-specific optimizations.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan core application components for legacy patterns",
            "description": "Identify legacy patterns in authentication and navigation components requiring React 19 updates",
            "dependencies": [],
            "details": "Scan React components to identify legacy patterns with core application component prioritization",
            "status": "done",
            "testStrategy": "Component scanning accuracy and core pattern identification"
          },
          {
            "id": 2,
            "title": "Apply React 19 transformation with application optimizations",
            "description": "Update components to React 19 with authentication and navigation enhancements",
            "dependencies": [1],
            "details": "Run automated transformation for React 19 features with application-specific optimizations",
            "status": "done",
            "testStrategy": "Transformation execution and application optimization validation"
          }
        ]
      },
      {
        "id": 296,
        "title": "Update tRPC API Endpoints to tRPC v11 Standards",
        "description": "Refactor tRPC endpoints to use tRPC v11 patterns with authentication and application data security focus.",
        "details": "Scan `src/trpc/**` files for legacy patterns with special attention to application API endpoints: authentication endpoints (login, signup, forgot password), protected data operations for the 8 main sections (Dashboard, Contacts, Tasks, Messages, Calendar, Marketing, Analytics, Settings), user session management, and notification/toast data endpoints. Apply an automated script to update to tRPC v11 with enhanced type safety for application data models, improved error handling for authentication operations, optimized query performance for section data loading, and enhanced security for user session management. Implement proper input validation and sanitization for all user data. Run `tsc` to validate and ensure integration tests pass. Output a JSON diff report showing API endpoint improvements.",
        "testStrategy": "Compile with `tsc` and run integration tests with focus on authentication and section data operations. Ensure the diff report shows updates and application-specific security enhancements.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Scan application API endpoints for legacy tRPC patterns",
            "description": "Identify legacy tRPC patterns in authentication and section data endpoints",
            "dependencies": [],
            "details": "Scan API endpoint files for legacy tRPC patterns with application endpoint prioritization",
            "status": "done",
            "testStrategy": "API scanning accuracy and application endpoint pattern identification"
          },
          {
            "id": 2,
            "title": "Apply tRPC v11 updates with application security enhancements",
            "description": "Update to tRPC v11 with authentication and user data security optimizations",
            "dependencies": [1],
            "details": "Apply automated script for tRPC v11 updates with application-specific security and performance improvements",
            "status": "done",
            "testStrategy": "tRPC update execution and application security enhancement validation"
          }
        ]
      },
      {
        "id": 297,
        "title": "Optimize Bundle and Improve Performance Metrics",
        "description": "Analyze bundle, apply optimizations, and measure performance improvements with core user experience focus.",
        "details": "Use webpack-bundle-analyzer to analyze the bundle with special attention to core application component bundles: authentication components, sidebar navigation (AppSidebarController, section sidebars), main layout components, dashboard widgets, and the 8 main section entry points. Apply code splitting for main section routes, dynamic imports for heavy components (Analytics, Marketing), and lazy loading for non-critical features. Optimize authentication flow performance, implement efficient caching for section data, and reduce bundle size for faster page transitions. Enhance Sonner toast loading performance and Omnibot responsiveness. Re-run `npx next build --profile` and capture metrics. Output a JSON report with improvements focusing on user experience metrics: authentication flow speed, sidebar responsiveness, and section transition times.",
        "testStrategy": "Compare new metrics to baseline (Task 289) with focus on core user scenarios. Confirm at least 10% bundle size reduction, improved TTI for protected pages, and enhanced performance for authentication flow and section navigation.",
        "priority": "medium",
        "dependencies": [289, 294, 295],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze bundle with core component focus",
            "description": "Use webpack analyzer to examine core application component bundle optimization opportunities",
            "dependencies": [],
            "details": "Analyze bundle using webpack-bundle-analyzer with focus on core component optimization",
            "status": "done",
            "testStrategy": "Bundle analysis accuracy and core component optimization identification"
          },
          {
            "id": 2,
            "title": "Apply application-focused performance optimizations",
            "description": "Implement code splitting and optimizations for core user experience",
            "dependencies": [1],
            "details": "Apply code splitting, dynamic imports, and application-specific performance optimizations",
            "status": "done",
            "testStrategy": "Optimization implementation and user experience improvement validation"
          }
        ]
      },
      {
        "id": 298,
        "title": "Run Comprehensive Automated Test Suite",
        "description": "Execute the test suite and generate coverage report with focus on core application logic validation.",
        "details": "Run `npx jest --coverage` to execute tests and generate coverage report in JSON with special validation for core application logic: authentication flow integrity, protected page access control, sidebar navigation functionality, main section routing accuracy, toast notification system reliability, and user session management. Ensure all critical user journeys are tested, authentication rules are validated, and edge cases for protected/unprotected page transitions are covered. Validate test coverage meets thresholds (≥90%) with higher requirements (≥95%) for authentication and session management code.",
        "testStrategy": "Check that all tests pass with special validation for core application logic. Coverage thresholds must be met with enhanced requirements for authentication and session operations. Inspect the JSON coverage report for core component completeness.",
        "priority": "high",
        "dependencies": [293, 294, 295, 296, 297],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Execute test suite with core application logic focus",
            "description": "Run comprehensive tests with emphasis on authentication and navigation critical paths",
            "dependencies": [],
            "details": "Run test suite using designated test runner with core application logic validation",
            "status": "done",
            "testStrategy": "Test execution completeness and core logic coverage"
          },
          {
            "id": 2,
            "title": "Generate and validate application-focused coverage report",
            "description": "Create coverage report with core application component analysis",
            "dependencies": [1],
            "details": "Generate and validate test coverage report with core component focus and enhanced thresholds",
            "status": "done",
            "testStrategy": "Coverage report accuracy and core component threshold validation"
          }
        ]
      },
      {
        "id": 299,
        "title": "Verify Performance Improvements Against Baselines",
        "description": "Compare post-refactoring performance metrics with baseline focusing on core user experience improvements.",
        "details": "Run `npx next build --profile` to get current metrics. Compare with baseline (Task 289) in a JSON report showing percentage improvements in bundle size, TTI, FCP, and application-specific metrics: authentication flow speed, sidebar navigation responsiveness, protected page loading time, section transition performance, toast notification speed, and Omnibot loading efficiency. Validate that core user workflows show measurable performance gains and overall user experience improvements.",
        "testStrategy": "Confirm improvements meet targets (e.g., 10% bundle reduction, 15% faster authentication flow) with special focus on core user experience metrics. Validate metrics are comparable to baseline methodology and show meaningful improvements for user-facing operations.",
        "priority": "high",
        "dependencies": [289, 297],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Run performance profiling with core scenario focus",
            "description": "Execute profiling build with emphasis on authentication and navigation scenarios",
            "dependencies": [],
            "details": "Run performance profiling build and capture updated metrics with core scenario focus",
            "status": "done",
            "testStrategy": "Profiling execution and core scenario metrics capture"
          },
          {
            "id": 2,
            "title": "Compare metrics with user experience analysis",
            "description": "Analyze performance improvements with core user workflow impact assessment",
            "dependencies": [1],
            "details": "Compare new metrics against baseline with user experience improvement analysis",
            "status": "done",
            "testStrategy": "Metrics comparison accuracy and user experience improvement validation"
          }
        ]
      },
      {
        "id": 300,
        "title": "Update Documentation and Perform Repository Cleanup",
        "description": "Revise documentation and remove temporary files with focus on application implementation guidance.",
        "details": "Update README.md with CodexApp-specific setup instructions, best practices docs with application development guidelines, and architecture diagrams showing authentication flow, sidebar navigation structure, and the 8 main section relationships. Include API documentation for the main sections, user workflow guides, and core component documentation (AppSidebarController, MainLayout, Omnibot). Update TypeScript best practices with application data model guidelines and Sonner toast implementation patterns. Run a cleanup script to delete temporary files (e.g., old logs, reports, deprecated components). Output a JSON cleanup log with documentation improvements and application implementation guidance.",
        "testStrategy": "Check that documentation reflects current application architecture and implementation. Verify no temporary files remain and that application-specific documentation is comprehensive and accurate. Validate that new developers can understand authentication flow and section architecture from documentation.",
        "priority": "medium",
        "dependencies": [298, 299],
        "status": "in-progress",
        "subtasks": [
          {
            "id": 1,
            "title": "Update documentation with application implementation guidance",
            "description": "Revise all documentation to include application-specific architecture and workflows",
            "dependencies": [],
            "details": "Update documentation files to include application practices, architecture diagrams, and core component guidance",
            "status": "pending",
            "testStrategy": "Documentation completeness and application implementation guidance accuracy"
          },
          {
            "id": 2,
            "title": "Execute repository cleanup with component validation",
            "description": "Clean temporary files and validate core component organization",
            "dependencies": [1],
            "details": "Execute cleanup script and generate final JSON log with component organization validation",
            "status": "pending",
            "testStrategy": "Cleanup completion and component organization verification"
          }
        ]
      },
      {
        "id": 301,
        "title": "Epic 1: Implement Core Database Schema",
        "description": "Create the foundational Supabase database migration scripts for all tables required by the V1 Tasks and Calendar modules.",
        "details": "Using the existing monorepo and Supabase project, write and apply a new migration script. This script will create the `projects`, `tasks`, `task_assignees`, and `calendar_events` tables. This is a pure database task and is the bedrock for all subsequent backend work. Ensure all columns, types, and foreign key constraints are implemented as per the provided schema.",
        "testStrategy": "After the AI confirms the migration is complete, connect to the Supabase Studio dashboard. In the Table Editor, verify that all four tables (`projects`, `tasks`, `task_assignees`, `calendar_events`) exist and that their schemas (columns, types, foreign keys) exactly match the specification.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `projects` and `tasks` Tables",
            "description": "Write the SQL for the `projects` and `tasks` tables in a new migration file.",
            "details": "Define the `projects` table (id, user_id, name, etc.) and the `tasks` table (id, user_id, project_id FK, title, status, due_date, etc.). The `status` on the `tasks` table should be a TEXT type to accommodate future values.",
            "testStrategy": "Inspect the generated SQL migration file to confirm the CREATE TABLE statements are correct before applying. After applying, check the tables in Supabase Studio."
          },
          {
            "id": 2,
            "title": "Create `task_assignees` and `calendar_events` Tables",
            "description": "Write the SQL for the `task_assignees` and `calendar_events` tables in the same migration file.",
            "details": "Define the `task_assignees` join table with FKs to `tasks.id` and `contacts.id`. Define the `calendar_events` table (id, user_id, title, start_time, end_time, google_calendar_event_id, etc.).",
            "testStrategy": "Verify the foreign key constraints for both tables are correctly defined in the migration script and are shown as active relationships in the Supabase Studio's table view."
          }
        ]
      },
      {
        "id": 302,
        "title": "Epic 1: Implement Foundational tRPC Routers",
        "description": "Create the boilerplate for all necessary tRPC routers with initial, mock data-returning procedures for Tasks, Projects, and Contacts.",
        "details": "In the `packages/server/src/routers/` directory, create the files for `task.ts`, `project.ts`, and `contact.ts`. Implement `taskRouter`, `projectRouter`, and `contactRouter`. Define the initial procedures (`task.list`, `project.list`, `contact.search`) that return hardcoded, mock data conforming to the database schema. This unblocks frontend development.",
        "testStrategy": "Once the AI completes the task, use an API client (like Thunder Client in VS Code) to send a request to each new endpoint (e.g., `task.list`, `project.list`). Verify that each endpoint returns a 200 OK status and the expected mock JSON array.",
        "priority": "high",
        "dependencies": [301],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `taskRouter` and `projectRouter`",
            "description": "Create the routers and list procedures for tasks and projects.",
            "details": "Create `taskRouter` with a `list` procedure. Create `projectRouter` with a `list` procedure. Both should be `publicProcedure` for now and return an array of 2-3 mock objects.",
            "testStrategy": "Call `task.list` via an API client and verify the mock task data is returned. Repeat for `project.list`."
          },
          {
            "id": 2,
            "title": "Implement `contactRouter` search procedure",
            "description": "Create the `contactRouter` with a `search` procedure needed for task assignment.",
            "details": "Create `contactRouter` with a `search(input: { query: string })` procedure. It should take a search query and return a mock array of matching contacts.",
            "testStrategy": "Call `contact.search` via an API client with a query string like `{'query': 'john'}`. Verify the mock contact data is returned."
          }
        ]
      },
      {
        "id": 303,
        "title": "Epic 2: Build Core Task UI - Display",
        "description": "Build the main UI for the Tasks module, focusing on displaying tasks in a 'Things-inspired' list view.",
        "details": "Refactor the existing files in `app/tasks/` to create a clean layout. The main page component will use the `task.list` tRPC hook to fetch data and pass it to a `ThingsTaskCard` component for rendering each task. This task focuses purely on displaying data.",
        "testStrategy": "Navigate to the `/tasks` route in your browser. Verify that the list of mock tasks from your tRPC endpoint is being displayed correctly, with each task rendered as a distinct `ThingsTaskCard`.",
        "priority": "high",
        "dependencies": [302],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor `app/tasks/page.tsx`",
            "description": "Clean up the main tasks page to orchestrate the data fetching and rendering.",
            "details": "The component should use the `api.task.list.useQuery()` hook from tRPC. It should handle loading and error states gracefully. On success, it should map over the returned data and render a `ThingsTaskCard` for each task.",
            "testStrategy": "While the tRPC hook is loading, ensure a loading skeleton or message is displayed. Once loaded, verify the list of tasks appears."
          },
          {
            "id": 2,
            "title": "Build `ThingsTaskCard` Component",
            "description": "Create a reusable component to display a single task's information.",
            "details": "Create `ThingsTaskCard.tsx`. It will receive a `task` object as a prop. For this task, it only needs to display the `task.title` and a checkbox. The checkbox should not have any functionality yet.",
            "testStrategy": "Use Storybook to render the `ThingsTaskCard` with various lengths of task titles to ensure the UI handles text overflow and wrapping correctly."
          }
        ]
      },
      {
        "id": 304,
        "title": "Epic 2: Implement Manual Task Creation",
        "description": "Implement the full user flow for manually creating a new task and having it appear in the UI.",
        "details": "This involves creating the frontend form and connecting it to a backend tRPC mutation. The goal is a seamless create-and-display loop.",
        "testStrategy": "Go to the `/tasks` page. Type 'My first fully functional task' into the add task form and submit it. The task should instantly appear in your task list (via optimistic update) and should remain there after a full page refresh.",
        "priority": "high",
        "dependencies": [303],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `task.create` tRPC Mutation",
            "description": "Flesh out the `task.create` procedure in `taskRouter` to save a new task to the database.",
            "details": "The mutation will take an input `{ title: string, projectId?: string }`. It should insert a new record into the `tasks` table with the provided data and the current user's ID.",
            "testStrategy": "Using an API client, call the `task.create` mutation directly with a valid title. Then, query your `tasks` table in Supabase Studio to confirm the new record was created successfully."
          },
          {
            "id": 2,
            "title": "Build 'Add Task' Form Component",
            "description": "Create the UI form for adding new tasks.",
            "details": "Create a new component `AddTaskForm.tsx`. It will contain a single text input. On submit, it will call the `api.task.create.useMutation()` hook. Implement logic to clear the input and refetch the task list upon successful creation.",
            "testStrategy": "In the UI, type a task title and submit. Check your browser's network tab to confirm a tRPC request was sent to the `task.create` endpoint with the correct payload."
          }
        ]
      },
      {
        "id": 305,
        "title": "Epic 2: Implement Task Completion",
        "description": "Enable users to mark tasks as complete, updating the UI and database state.",
        "details": "This task connects the checkbox on the `ThingsTaskCard` to a backend mutation, providing the core interactive functionality of a to-do list.",
        "testStrategy": "In the UI, find a pending task and click its checkbox. Verify its appearance changes immediately (e.g., text gets a strikethrough). Refresh the page; the task should remain marked as complete. Check the `status` column in the `tasks` table for that record in Supabase to confirm it's set to 'completed'.",
        "priority": "high",
        "dependencies": [303],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `task.updateStatus` tRPC Mutation",
            "description": "Create a tRPC mutation to change the status of a task.",
            "details": "In `taskRouter`, create an `updateStatus` mutation that accepts `{ taskId: string, status: 'pending' | 'completed' }` and updates the corresponding record in the database.",
            "testStrategy": "Using an API client, call `task.updateStatus` with a valid task ID and the status 'completed'. Query the database to confirm the row was updated."
          },
          {
            "id": 2,
            "title": "Connect Checkbox to `updateStatus` Mutation",
            "description": "Wire the `ThingsTaskCard` checkbox's `onClick` event to the tRPC mutation.",
            "details": "In `ThingsTaskCard.tsx`, import and use the `api.task.updateStatus.useMutation()` hook. When the checkbox is clicked, call the mutation with the task's ID and the new status. Implement an optimistic UI update for instant feedback.",
            "testStrategy": "Click a task's checkbox. Open the browser's developer tools and verify in the Network tab that a request to `task.updateStatus` was made. Check that the UI updated before the network request completed."
          }
        ]
      },
      {
        "id": 306,
        "title": "Epic 3: Implement Project Creation Flow",
        "description": "Build the complete user flow for creating a new Project.",
        "details": "This mirrors the task creation flow but for the 'Projects' entity. It involves the UI form and the backend tRPC mutation.",
        "testStrategy": "In the `TasksSidebar`, use the 'New Project' UI. Create a project named 'Q4 Marketing Campaign'. Verify it immediately appears in the project list in the sidebar and persists after a page refresh.",
        "priority": "medium",
        "dependencies": [302],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `project.create` tRPC Mutation",
            "description": "Flesh out the `project.create` procedure to save a new project to the database.",
            "details": "The mutation will take `{ name: string }` and create a new record in the `projects` table for the current user.",
            "testStrategy": "Call `project.create` from an API client with `{'name': 'My Test Project'}`. Check the `projects` table in Supabase to confirm the new record was created."
          },
          {
            "id": 2,
            "title": "Build 'New Project' Form",
            "description": "Create a UI form, likely in a modal or a dedicated view, for creating projects.",
            "details": "The form will have an input for the project name and a submit button. On submit, it will call the `api.project.create.useMutation()` hook and refetch the project list on success.",
            "testStrategy": "Open the 'New Project' modal, type a name, and submit. Verify the modal closes and the new project appears in the sidebar list without requiring a page refresh."
          }
        ]
      },
      {
        "id": 307,
        "title": "Epic 3: Implement Project-Based Task Filtering",
        "description": "Enable users to view tasks filtered by the selected project.",
        "details": "This task makes the project list in the sidebar functional, allowing it to control the main task view.",
        "testStrategy": "Create two projects, 'Project A' and 'Project B'. Create 'Task 1' assigned to 'Project A' and 'Task 2' assigned to 'Project B'. Click 'Project A' in the sidebar; only 'Task 1' should be visible. Click 'Project B'; only 'Task 2' should be visible. Click 'Inbox' or 'All Tasks'; both should be visible.",
        "priority": "high",
        "dependencies": [306],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update `task.list` for Project Filtering",
            "description": "Modify the `task.list` tRPC procedure to accept an optional `projectId`.",
            "details": "The `task.list` procedure should be updated to accept `input: { projectId?: string }`. If a `projectId` is provided, the database query must be modified with a `WHERE` clause to only return tasks matching that `projectId`.",
            "testStrategy": "Using an API client, call `task.list` with a valid `projectId`. Verify it only returns tasks associated with that project. Call it with no `projectId` and verify it returns all tasks."
          },
          {
            "id": 2,
            "title": "Connect Sidebar Links to Filter State",
            "description": "Make the project links in the sidebar control the filter applied to the task list.",
            "details": "Use a client-side state management solution (like Zustand or React Context) or URL query parameters (`/tasks?project=...`) to manage the currently selected project filter. When a project link in `TasksSidebar.tsx` is clicked, update this state. The main task list component should use this state to call the `api.task.list.useQuery()` hook with the correct `projectId`.",
            "testStrategy": "Click a project link in the sidebar. Check the browser's URL bar to confirm the query parameter has been updated correctly (if using URL state). Verify the Network tab shows a new call to `task.list` with the `projectId` in the payload."
          }
        ]
      },
      {
        "id": 308,
        "title": "Epic 3: Implement Task-to-Project Assignment",
        "description": "Allow existing tasks to be assigned to a project.",
        "details": "This task provides the functionality to organize existing tasks into projects, a key organizational feature.",
        "testStrategy": "Create a task without a project (it should appear in the 'Inbox'). Open the task's detail view, use the project dropdown to assign it to 'Project A', and save. Return to the main view; the task should no longer be in the 'Inbox' but should now appear when you filter by 'Project A'.",
        "priority": "medium",
        "dependencies": [306, 307],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `task.updateProject` tRPC Mutation",
            "description": "Create a mutation to update a task's `project_id`.",
            "details": "In `taskRouter`, create a new `updateProject` mutation that takes `{ taskId: string, projectId: string | null }` and updates the `project_id` field of the specified task.",
            "testStrategy": "Use an API client to call `task.updateProject`, changing a task's `projectId`. Query the database to confirm the field was updated."
          },
          {
            "id": 2,
            "title": "Add Project Dropdown to Task Detail UI",
            "description": "In the UI for viewing/editing a task, add a dropdown to change its project.",
            "details": "In the task detail view, add a dropdown populated with the user's projects (from `project.list`). Its value should be the task's current `projectId`. When changed, it should call the `task.updateProject` mutation.",
            "testStrategy": "Open a task's detail view. The project dropdown should correctly show its current project. Change the project in the dropdown and save. Verify the change is reflected in the main task list view."
          }
        ]
      },
      {
        "id": 309,
        "title": "Epic 4: Implement Task-to-Contact Assignment Backend",
        "description": "Create the backend tRPC procedures for assigning tasks to contacts.",
        "details": "This involves creating mutations to manage the records in the `task_assignees` join table.",
        "testStrategy": "Use an API client to call `task.addAssignee` with a task ID and a contact ID. Query the `task_assignees` table in Supabase to verify the new record was created. Then call `task.removeAssignee` and verify the record was deleted.",
        "priority": "medium",
        "dependencies": [301, 302],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `task.addAssignee` Mutation",
            "description": "Create a tRPC mutation to add a record to the `task_assignees` table.",
            "details": "In `taskRouter`, create an `addAssignee` mutation that takes `{ taskId: string, contactId: string }` and inserts a new record into the join table.",
            "testStrategy": "Verify the mutation handles potential duplicate entries gracefully (e.g., using an `ON CONFLICT DO NOTHING` clause in the SQL)."
          },
          {
            "id": 2,
            "title": "Implement `task.removeAssignee` Mutation",
            "description": "Create a tRPC mutation to remove a record from the `task_assignees` table.",
            "details": "In `taskRouter`, create a `removeAssignee` mutation that takes `{ taskId: string, contactId: string }` and deletes the corresponding record from the join table.",
            "testStrategy": "Verify the mutation correctly removes the specified assignee without affecting other assignees for the same task."
          }
        ]
      },
      {
        "id": 310,
        "title": "Epic 4: Implement Task-to-Contact Assignment Frontend",
        "description": "Build the UI for users to assign contacts to a task.",
        "details": "This involves creating a search-and-select component within the task detail view.",
        "testStrategy": "Open a task that has no assignees. Assign 'John Doe' and 'Jane Smith'. Save and reopen; both should be listed. Then, remove 'Jane Smith'. Save and reopen; only 'John Doe' should be listed.",
        "priority": "medium",
        "dependencies": [309],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Build Contact Search Component",
            "description": "Create a reusable component with a search input that displays matching contacts.",
            "details": "This component will use the `api.contact.search.useQuery` hook. As the user types, it should call the hook with the query and display the results in a list. Clicking a result should trigger a selection callback.",
            "testStrategy": "In Storybook, test the component by typing a name. Verify it makes a tRPC call and correctly displays the mock results. Ensure the selection callback is fired with the correct contact ID."
          },
          {
            "id": 2,
            "title": "Integrate Component into Task Detail View",
            "description": "Place the contact search component into the task detail UI and manage the state of assigned contacts.",
            "details": "The task detail UI will fetch current assignees. The search component will be used to add new assignees (`task.addAssignee`). A UI element (e.g., a list of names with 'x' buttons) will be used to display current assignees and allow their removal (`task.removeAssignee`).",
            "testStrategy": "Assign a contact to a task. Check the Network tab to confirm the `task.addAssignee` call. Then, click the 'x' next to their name and confirm the `task.removeAssignee` call is made."
          }
        ]
      },
      {
        "id": 311,
        "title": "Epic 5: Implement Google Calendar Onboarding",
        "description": "Build the complete user flow for connecting a Google Calendar, including OAuth and calendar selection.",
        "details": "This is a critical, user-facing security and integration feature that must be smooth and reliable.",
        "testStrategy": "Go to `/settings/integrations`. Click 'Connect Google Calendar'. Successfully log in with a real Google account and grant permissions. On redirect, ensure you are presented with a dropdown of your calendars. Select one. Verify the UI updates to a 'Connected' state and that this state persists on refresh.",
        "priority": "high",
        "dependencies": [301],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Build UI at `/settings/integrations`",
            "description": "Create the settings page with the button to start the Google OAuth flow.",
            "details": "The page should clearly explain what the integration does. The 'Connect' button should be disabled if a connection is already active. It should also display the currently connected calendar if one is set.",
            "testStrategy": "Verify the page renders correctly. The 'Connect' button should be visible. If you manually add a `google_business_calendar_id` to your user settings in the database, the UI should show the 'Connected' state instead."
          },
          {
            "id": 2,
            "title": "Implement Backend OAuth Logic & Token Storage",
            "description": "Create the tRPC procedures and API callback route to handle the Google OAuth 2.0 flow.",
            "details": "This includes a procedure to generate the auth URL, an API route (`/api/auth/google/callback`) to handle the redirect from Google, and logic to securely store the tokens in Supabase Vault and the chosen calendar ID in user settings.",
            "testStrategy": "Monitor the server logs during the OAuth flow. Verify the callback route is hit and that it successfully exchanges the authorization code for tokens without errors."
          }
        ]
      },
      {
        "id": 312,
        "title": "Epic 5: Implement Calendar Data Display",
        "description": "Create the unified calendar view that displays events from both the CRM and the user's connected Google Calendar.",
        "details": "This task focuses on reading data from multiple sources and presenting it in a single, coherent user interface.",
        "testStrategy": "Manually create one event in your `calendar_events` table for today. Create a separate, different event in your actual Google Calendar for tomorrow. Navigate to the `/calendar` page in the app. Verify you can see both events displayed correctly on their respective days.",
        "priority": "high",
        "dependencies": [311],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `calendarRouter` and `listEvents` Procedure",
            "description": "Implement a tRPC router for calendar-related data fetching.",
            "details": "The `listEvents` procedure will be the core of this router. It will first fetch events from the `calendar_events` table. Then, if the user has a connected Google Calendar, it will use their stored tokens to call the Google Calendar API and fetch events from their primary business calendar for the requested date range. It will then merge and return both sets of data.",
            "testStrategy": "Using an API client, call `listEvents`. First, test with a user who has *not* connected their Google Calendar; it should only return local CRM events. Then test with a connected user; it should return a merged list of CRM and Google Calendar events."
          },
          {
            "id": 2,
            "title": "Build the `/calendar` Page UI",
            "description": "Develop the main calendar page using a robust calendar component library.",
            "details": "Choose and install a library like `react-big-calendar`. The main page component will call the `api.calendar.listEvents.useQuery()` hook. The fetched events will be transformed into the format expected by the calendar library and passed as props to render the view.",
            "testStrategy": "Test the calendar UI's interactivity. Click to switch between 'Month', 'Week', and 'Day' views. Use the navigation arrows to move to the next/previous month. Verify the UI remains responsive and correctly refetches data for the new date ranges."
          }
        ]
      },
      {
        "id": 313,
        "title": "Epic 5: Implement Task and Calendar Sync",
        "description": "Allow users to push tasks with due dates from the CRM to their Google Calendar as events.",
        "details": "This feature provides a direct, actionable link between the planning done in the Tasks module and the user's scheduled reality in their calendar.",
        "testStrategy": "Create a new task with a title 'My Synced Task' and set its due date to next Tuesday at 2 PM. Open the task's detail view and click 'Add to Google Calendar'. Open your Google Calendar; a new event titled 'My Synced Task' should appear at the correct time on next Tuesday's date.",
        "priority": "medium",
        "dependencies": [311, 303],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `task.sendToGoogleCalendar` tRPC Mutation",
            "description": "Create a backend procedure to create a Google Calendar event from a task.",
            "details": "In `taskRouter`, create a new mutation `sendToGoogleCalendar(input: { taskId: string })`. This procedure will fetch the task details, retrieve the user's Google OAuth tokens from the vault, and then use the Google Calendar API to create a new event with the task's title and due date.",
            "testStrategy": "Call the mutation from an API client with a valid `taskId`. Check the server logs for any errors from the Google Calendar API. Verify a `200 OK` response is returned on success."
          },
          {
            "id": 2,
            "title": "Add 'Add to Calendar' Button in Task UI",
            "description": "Add a UI button to trigger the calendar sync for a specific task.",
            "details": "In the task detail view, conditionally render an 'Add to Google Calendar' button only if the task has a `due_date` set and the user has connected their calendar. The button's `onClick` handler should call the `api.task.sendToGoogleCalendar.useMutation()` hook.",
            "testStrategy": "Verify the 'Add to Google Calendar' button is only visible for tasks that have a due date. Create a task without a due date; the button should be hidden. Add a due date; the button should appear."
          }
        ]
      },
      {
        "id": 314,
        "title": "Epic 6: Implement AI Task Delegation Backend",
        "description": "Update the database schema and tRPC API to support AI task ownership.",
        "details": "This task lays the backend groundwork for handing off tasks to the AI worker agent.",
        "testStrategy": "Create a new 'AI Worker' user in the `auth.users` table. Find its UUID. Create a normal task; its `owner_id` should be your ID. Use an API client to call the new `task.delegateToAI` mutation with the task's ID. Query the database and confirm the task's `owner_id` has changed to the AI Worker's UUID.",
        "priority": "medium",
        "dependencies": [301],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update `tasks` Schema with `owner_id`",
            "description": "Add an `owner_id` column to the `tasks` table to track ownership.",
            "details": "Write and apply a migration to add a nullable `owner_id` column to `tasks`, with a foreign key constraint to `auth.users(id)`. Update the `task.create` procedure to set the `owner_id` to the creator's `user_id` by default.",
            "testStrategy": "After the migration, create a new task via the UI. Check the `tasks` table in Supabase Studio to verify the `owner_id` for the new record is correctly set to your `user_id`."
          },
          {
            "id": 2,
            "title": "Implement `task.delegateToAI` Mutation",
            "description": "Create a tRPC mutation to change the `owner_id` of a task to the designated AI user.",
            "details": "First, hardcode the UUID of a pre-created 'AI Worker' user. Create the `delegateToAI(input: { taskId: string })` mutation in `taskRouter`. This procedure updates the `owner_id` of the specified task to the hardcoded AI Worker UUID.",
            "testStrategy": "Ensure the mutation includes a check to prevent a user from delegating a task that does not belong to them."
          }
        ]
      },
      {
        "id": 315,
        "title": "Epic 6: Implement AI Task Delegation Frontend",
        "description": "Build the UI for a user to delegate a task to the AI.",
        "details": "This makes the AI handoff feature usable from the application interface.",
        "testStrategy": "Find a task in your personal inbox. Use the new 'Delegate to AI' menu option. The task should disappear from your view. Navigate to the new 'AI Inbox' page. The task should be listed there.",
        "priority": "medium",
        "dependencies": [314],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add 'Delegate to AI' Action to Task UI",
            "description": "Add a button or context menu option to the `ThingsTaskCard`.",
            "details": "In the task's context menu (the '...' button), add a new option labeled 'Delegate to AI'. This option should only be visible for tasks owned by the current user. Its `onClick` handler should call the `api.task.delegateToAI.useMutation()` hook.",
            "testStrategy": "Verify the 'Delegate to AI' option appears for tasks you own, but is hidden for any tasks owned by others (if applicable in the future)."
          },
          {
            "id": 2,
            "title": "Modify `task.list` to Respect Ownership",
            "description": "Update the primary task list query to only show tasks owned by the current user.",
            "details": "Modify the `task.list` procedure. It must now include a `WHERE owner_id = [current_user_id]` clause by default. This ensures a user's main task list is not cluttered with tasks they have delegated.",
            "testStrategy": "Delegate a task to the AI. Refresh the main task list page. The delegated task should no longer be visible."
          }
        ]
      },
      {
        "id": 316,
        "title": "Epic 6: Build the 'AI Inbox' UI",
        "description": "Create a dedicated view for the user to see which tasks are currently assigned to the AI.",
        "details": "This provides necessary visibility into the AI's workload, building user trust.",
        "testStrategy": "Delegate two tasks to the AI. Navigate to the 'AI Inbox'. Both tasks should be listed. Go back to your personal inbox and delegate a third task. Return to the 'AI Inbox' and verify the list updates to show all three tasks.",
        "priority": "medium",
        "dependencies": [315],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `task.listForAI` Procedure",
            "description": "Create a new tRPC procedure to fetch tasks assigned to the AI.",
            "details": "In `taskRouter`, create a new procedure `listForAI`. This query will be similar to `list` but will have a hardcoded `WHERE` clause to fetch tasks where `owner_id` matches the AI Worker's UUID. This is for the user to view the AI's queue.",
            "testStrategy": "Call `task.listForAI` from an API client. Verify it returns only tasks that have been successfully delegated to the AI."
          },
          {
            "id": 2,
            "title": "Create 'AI Inbox' Page",
            "description": "Build a new page or view that displays the AI's task list.",
            "details": "This could be a new page at `/tasks/ai-inbox` or a special filter in the sidebar. This view will call the `api.task.listForAI.useQuery()` hook and render the results, perhaps with a slightly different UI to indicate they are 'in progress' by the AI.",
            "testStrategy": "Verify that this page correctly shows tasks you have delegated and does *not* show tasks still owned by you."
          }
        ]
      },
      {
        "id": 317,
        "title": "Quality Assurance: Task & Project Flow Testing",
        "description": "Perform end-to-end manual testing on all core task and project management user stories.",
        "details": "This task involves manually going through all user flows related to creating and organizing tasks and projects, without AI or calendar features, to ensure the core functionality is bug-free.",
        "testStrategy": "Follow a written test plan: 1. Create Project A. 2. Create Task 1 and assign it to Project A. 3. Create Task 2 with no project. 4. Mark Task 2 complete. 5. Move Task 1 to a new Project B. Verify at each step that the UI and underlying database state are correct.",
        "priority": "high",
        "dependencies": [308],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 318,
        "title": "Quality Assurance: Contacts Integration Testing",
        "description": "Perform end-to-end manual testing of the task-to-contact assignment feature.",
        "details": "Manually verify the entire workflow of assigning and un-assigning contacts to tasks, ensuring data integrity and a smooth user experience.",
        "testStrategy": "Follow a written test plan: 1. Create a task. 2. Assign 3 contacts to it. 3. Verify all 3 are saved correctly. 4. Un-assign 1 contact. 5. Verify the remaining 2 are still assigned. 6. Delete the task and confirm the records in `task_assignees` are also deleted (cascade).",
        "priority": "high",
        "dependencies": [310],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 319,
        "title": "Quality Assurance: Calendar Integration Testing",
        "description": "Perform end-to-end manual testing of the entire Google Calendar integration workflow.",
        "details": "This is a critical test of an external integration. It involves checking the OAuth flow, data display, and the sync-to-calendar feature with a real Google account.",
        "testStrategy": "Follow a written test plan: 1. Connect a fresh Google account. 2. Verify calendar events appear in the app. 3. Create a task with a due date in the app. 4. Click 'Add to Google Calendar'. 5. Check your Google Calendar to ensure the event was created correctly. 6. Disconnect the Google account from settings and ensure the app handles it gracefully.",
        "priority": "high",
        "dependencies": [313],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 320,
        "title": "Quality Assurance: AI Delegation Flow Testing",
        "description": "Perform end-to-end manual testing of the AI delegation feature.",
        "details": "Manually verify that a user can successfully hand off a task to the AI, and that the task correctly moves from the user's view to the AI's view.",
        "testStrategy": "Follow a written test plan: 1. Create a task. 2. Verify it is in your inbox. 3. Delegate it to the AI. 4. Verify it is no longer in your inbox. 5. Verify it now appears in the 'AI Inbox' view. 6. Check the database `owner_id` to confirm the change.",
        "priority": "high",
        "dependencies": [316],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-15T19:15:09.849Z",
      "updated": "2025-06-15T21:50:55.129Z",
      "description": "Tasks for master context"
    }
  }
}
