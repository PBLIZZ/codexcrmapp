"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@trpc+server@11.4.2_typescript@5.8.3";
exports.ids = ["vendor-chunks/@trpc+server@11.4.2_typescript@5.8.3"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/adapters/fetch/index.mjs":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/adapters/fetch/index.mjs ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchRequestHandler: () => (/* binding */ fetchRequestHandler)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../getErrorShape-Uhlrl4Bk.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\");\n/* harmony import */ var _resolveResponse_CzlbRpCI_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../resolveResponse-CzlbRpCI.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs\");\n\n\n\n\n\n//#region src/adapters/fetch/fetchRequestHandler.ts\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\nconst trimSlashes = (path)=>{\n    path = path.startsWith(\"/\") ? path.slice(1) : path;\n    path = path.endsWith(\"/\") ? path.slice(0, -1) : path;\n    return path;\n};\nasync function fetchRequestHandler(opts) {\n    const resHeaders = new Headers();\n    const createContext = async (innerOpts)=>{\n        var _opts$createContext;\n        return (_opts$createContext = opts.createContext) === null || _opts$createContext === void 0 ? void 0 : _opts$createContext.call(opts, (0, import_objectSpread2.default)({\n            req: opts.req,\n            resHeaders\n        }, innerOpts));\n    };\n    const url = new URL(opts.req.url);\n    const pathname = trimSlashes(url.pathname);\n    const endpoint = trimSlashes(opts.endpoint);\n    const path = trimSlashes(pathname.slice(endpoint.length));\n    return await (0,_resolveResponse_CzlbRpCI_mjs__WEBPACK_IMPORTED_MODULE_1__.resolveResponse)((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n        req: opts.req,\n        createContext,\n        path,\n        error: null,\n        onError (o) {\n            var _opts$onError;\n            opts === null || opts === void 0 || (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, o), {}, {\n                req: opts.req\n            }));\n        },\n        responseMeta (data) {\n            var _opts$responseMeta;\n            const meta = (_opts$responseMeta = opts.responseMeta) === null || _opts$responseMeta === void 0 ? void 0 : _opts$responseMeta.call(opts, data);\n            if (meta === null || meta === void 0 ? void 0 : meta.headers) {\n                if (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries())resHeaders.append(key, value);\n                else /**\n\t\t\t\t* @deprecated, delete in v12\n\t\t\t\t*/ for (const [key, value] of Object.entries(meta.headers))if (Array.isArray(value)) for (const v of value)resHeaders.append(key, v);\n                else if (typeof value === \"string\") resHeaders.set(key, value);\n            }\n            return {\n                headers: resHeaders,\n                status: meta === null || meta === void 0 ? void 0 : meta.status\n            };\n        }\n    }));\n}\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvYWRhcHRlcnMvZmV0Y2gvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFnQkEsTUFBTSxjQUFjLENBQUNBO0lBQ25CLE9BQU8sS0FBSyxXQUFXLElBQUksR0FBRyxLQUFLLE1BQU0sRUFBRSxHQUFHO0lBQzlDLE9BQU8sS0FBSyxTQUFTLElBQUksR0FBRyxLQUFLLE1BQU0sR0FBRyxHQUFHLEdBQUc7SUFFaEQsT0FBTztBQUNSO0FBRUQsZUFBc0Isb0JBQ3BCQyxJQUFBQSxFQUNtQjtJQUNuQixNQUFNLGFBQWEsSUFBSTtJQUV2QixNQUFNQyxnQkFBNkQsT0FDakU7O1FBRUEsOEJBQU8sS0FBSyxxRUFBTDtZQUF1QixLQUFLLEtBQUs7WUFBSztXQUFlLFdBQVk7SUFDekU7SUFFRCxNQUFNLE1BQU0sSUFBSSxJQUFJLEtBQUssSUFBSTtJQUU3QixNQUFNLFdBQVcsWUFBWSxJQUFJLFNBQVM7SUFDMUMsTUFBTSxXQUFXLFlBQVksS0FBSyxTQUFTO0lBQzNDLE1BQU0sT0FBTyxZQUFZLFNBQVMsTUFBTSxTQUFTLE9BQU8sQ0FBQztJQUV6RCxPQUFPLE1BQU0sOEVBQWUsQ0FBZix3RUFDUjtRQUNILEtBQUssS0FBSztRQUNWO1FBQ0E7UUFDQSxPQUFPO1FBQ1AsU0FBUSxHQUFHOztZQUNULDBEQUFNLGlEQUFOLGlHQUFxQjtnQkFBRyxLQUFLLEtBQUs7WUFBQSxHQUFNO1FBQ3pDO1FBQ0QsY0FBYSxNQUFNOztZQUNqQixNQUFNLDZCQUFPLEtBQUssbUVBQUwsOEJBQW9CLEtBQUs7WUFFdEMsZ0RBQUksS0FBTSxTQUNSO29CQUFJLEtBQUssbUJBQW1CLFFBQzFCLE1BQUssTUFBTSxDQUFDLEtBQUssTUFBTSxJQUFJLEtBQUssUUFBUSxTQUFTLENBQy9DLFdBQVcsT0FBTyxLQUFLLE1BQU07OztPQU0vQixLQUFLLE1BQU0sQ0FBQyxLQUFLLE1BQU0sSUFBSSxPQUFPLFFBQVEsS0FBSyxRQUFRLENBQ3JELElBQUksTUFBTSxRQUFRLE1BQU0sQ0FDdEIsTUFBSyxNQUFNLEtBQUssTUFDZCxXQUFXLE9BQU8sS0FBSyxFQUFFO2dDQUVYLFVBQVUsU0FDMUIsWUFBVyxJQUFJLEtBQUssTUFBTTtZQUcvQjtZQUdILE9BQU87Z0JBQ0wsU0FBUztnQkFDVCxvREFBUSxLQUFNO1lBQ2Y7UUFDRjtPQUNEO0FBQ0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvc3JjL2FkYXB0ZXJzL2ZldGNoL2ZldGNoUmVxdWVzdEhhbmRsZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJZiB5b3UncmUgbWFraW5nIGFuIGFkYXB0ZXIgZm9yIHRSUEMgYW5kIGxvb2tpbmcgYXQgdGhpcyBmaWxlIGZvciByZWZlcmVuY2UsIHlvdSBzaG91bGQgaW1wb3J0IHR5cGVzIGFuZCBmdW5jdGlvbnMgZnJvbSBgQHRycGMvc2VydmVyYCBhbmQgYEB0cnBjL3NlcnZlci9odHRwYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHR5cGUgeyBBbnlUUlBDUm91dGVyIH0gZnJvbSAnQHRycGMvc2VydmVyJ1xuICogaW1wb3J0IHR5cGUgeyBIVFRQQmFzZUhhbmRsZXJPcHRpb25zIH0gZnJvbSAnQHRycGMvc2VydmVyL2h0dHAnXG4gKiBgYGBcbiAqL1xuLy8gQHRycGMvc2VydmVyXG5cbmltcG9ydCB0eXBlIHsgQW55Um91dGVyIH0gZnJvbSAnLi4vLi4vQHRycGMvc2VydmVyJztcbmltcG9ydCB0eXBlIHsgUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uc0NvbnRleHRGbiB9IGZyb20gJy4uLy4uL0B0cnBjL3NlcnZlci9odHRwJztcbmltcG9ydCB7IHJlc29sdmVSZXNwb25zZSB9IGZyb20gJy4uLy4uL0B0cnBjL3NlcnZlci9odHRwJztcbmltcG9ydCB0eXBlIHsgRmV0Y2hIYW5kbGVyUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgdHJpbVNsYXNoZXMgPSAocGF0aDogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgcGF0aCA9IHBhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aC5zbGljZSgxKSA6IHBhdGg7XG4gIHBhdGggPSBwYXRoLmVuZHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG5cbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXF1ZXN0SGFuZGxlcjxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPihcbiAgb3B0czogRmV0Y2hIYW5kbGVyUmVxdWVzdE9wdGlvbnM8VFJvdXRlcj4sXG4pOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gIGNvbnN0IHJlc0hlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuXG4gIGNvbnN0IGNyZWF0ZUNvbnRleHQ6IFJlc29sdmVIVFRQUmVxdWVzdE9wdGlvbnNDb250ZXh0Rm48VFJvdXRlcj4gPSBhc3luYyAoXG4gICAgaW5uZXJPcHRzLFxuICApID0+IHtcbiAgICByZXR1cm4gb3B0cy5jcmVhdGVDb250ZXh0Py4oeyByZXE6IG9wdHMucmVxLCByZXNIZWFkZXJzLCAuLi5pbm5lck9wdHMgfSk7XG4gIH07XG5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChvcHRzLnJlcS51cmwpO1xuXG4gIGNvbnN0IHBhdGhuYW1lID0gdHJpbVNsYXNoZXModXJsLnBhdGhuYW1lKTtcbiAgY29uc3QgZW5kcG9pbnQgPSB0cmltU2xhc2hlcyhvcHRzLmVuZHBvaW50KTtcbiAgY29uc3QgcGF0aCA9IHRyaW1TbGFzaGVzKHBhdGhuYW1lLnNsaWNlKGVuZHBvaW50Lmxlbmd0aCkpO1xuXG4gIHJldHVybiBhd2FpdCByZXNvbHZlUmVzcG9uc2Uoe1xuICAgIC4uLm9wdHMsXG4gICAgcmVxOiBvcHRzLnJlcSxcbiAgICBjcmVhdGVDb250ZXh0LFxuICAgIHBhdGgsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgb25FcnJvcihvKSB7XG4gICAgICBvcHRzPy5vbkVycm9yPy4oeyAuLi5vLCByZXE6IG9wdHMucmVxIH0pO1xuICAgIH0sXG4gICAgcmVzcG9uc2VNZXRhKGRhdGEpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBvcHRzLnJlc3BvbnNlTWV0YT8uKGRhdGEpO1xuXG4gICAgICBpZiAobWV0YT8uaGVhZGVycykge1xuICAgICAgICBpZiAobWV0YS5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1ldGEuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHJlc0hlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAZGVwcmVjYXRlZCwgZGVsZXRlIGluIHYxMlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGEuaGVhZGVycykpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXNIZWFkZXJzLmFwcGVuZChrZXksIHYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgcmVzSGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlcnM6IHJlc0hlYWRlcnMsXG4gICAgICAgIHN0YXR1czogbWV0YT8uc3RhdHVzLFxuICAgICAgfTtcbiAgICB9LFxuICB9KTtcbn1cbiJdLCJuYW1lcyI6WyJwYXRoOiBzdHJpbmciLCJvcHRzOiBGZXRjaEhhbmRsZXJSZXF1ZXN0T3B0aW9uczxUUm91dGVyPiIsImNyZWF0ZUNvbnRleHQ6IFJlc29sdmVIVFRQUmVxdWVzdE9wdGlvbnNDb250ZXh0Rm48VFJvdXRlcj4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/adapters/fetch/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTP_CODE_TO_JSONRPC2: () => (/* binding */ HTTP_CODE_TO_JSONRPC2),\n/* harmony export */   JSONRPC2_TO_HTTP_CODE: () => (/* binding */ JSONRPC2_TO_HTTP_CODE),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM),\n/* harmony export */   createFlatProxy: () => (/* binding */ createFlatProxy),\n/* harmony export */   createRecursiveProxy: () => (/* binding */ createRecursiveProxy),\n/* harmony export */   getErrorShape: () => (/* binding */ getErrorShape),\n/* harmony export */   getHTTPStatusCode: () => (/* binding */ getHTTPStatusCode),\n/* harmony export */   getHTTPStatusCodeFromError: () => (/* binding */ getHTTPStatusCodeFromError),\n/* harmony export */   getStatusCodeFromKey: () => (/* binding */ getStatusCodeFromKey),\n/* harmony export */   getStatusKeyFromCode: () => (/* binding */ getStatusKeyFromCode),\n/* harmony export */   require_defineProperty: () => (/* binding */ require_defineProperty),\n/* harmony export */   require_objectSpread2: () => (/* binding */ require_objectSpread2)\n/* harmony export */ });\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") for(var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++){\n        key = keys[i];\n        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ((k)=>from[k]).bind(null, key),\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n//#endregion\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = ()=>{};\nconst freezeIfAvailable = (obj)=>{\n    if (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n    var _memo$cacheKey;\n    const cacheKey = path.join(\".\");\n    (_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== \"string\" || key === \"then\") return void 0;\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ], memo);\n        },\n        apply (_1, _2, args) {\n            const lastOfPath = path[path.length - 1];\n            let opts = {\n                args,\n                path\n            };\n            if (lastOfPath === \"call\") opts = {\n                args: args.length >= 2 ? [\n                    args[1]\n                ] : [],\n                path: path.slice(0, -1)\n            };\n            else if (lastOfPath === \"apply\") opts = {\n                args: args.length >= 2 ? args[1] : [],\n                path: path.slice(0, -1)\n            };\n            freezeIfAvailable(opts.args);\n            freezeIfAvailable(opts.path);\n            return callback(opts);\n        }\n    }));\n    return memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/ const createRecursiveProxy = (callback)=>createInnerProxy(callback, [], Object.create(null));\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (name === \"then\") return void 0;\n            return callback(name);\n        }\n    });\n};\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n    400: \"BAD_REQUEST\",\n    401: \"UNAUTHORIZED\",\n    402: \"PAYMENT_REQUIRED\",\n    403: \"FORBIDDEN\",\n    404: \"NOT_FOUND\",\n    405: \"METHOD_NOT_SUPPORTED\",\n    408: \"TIMEOUT\",\n    409: \"CONFLICT\",\n    412: \"PRECONDITION_FAILED\",\n    413: \"PAYLOAD_TOO_LARGE\",\n    415: \"UNSUPPORTED_MEDIA_TYPE\",\n    422: \"UNPROCESSABLE_CONTENT\",\n    429: \"TOO_MANY_REQUESTS\",\n    499: \"CLIENT_CLOSED_REQUEST\",\n    500: \"INTERNAL_SERVER_ERROR\",\n    501: \"NOT_IMPLEMENTED\",\n    502: \"BAD_GATEWAY\",\n    503: \"SERVICE_UNAVAILABLE\",\n    504: \"GATEWAY_TIMEOUT\"\n};\nfunction getStatusCodeFromKey(code) {\n    var _JSONRPC2_TO_HTTP_COD;\n    return (_JSONRPC2_TO_HTTP_COD = JSONRPC2_TO_HTTP_CODE[code]) !== null && _JSONRPC2_TO_HTTP_COD !== void 0 ? _JSONRPC2_TO_HTTP_COD : 500;\n}\nfunction getStatusKeyFromCode(code) {\n    var _HTTP_CODE_TO_JSONRPC;\n    return (_HTTP_CODE_TO_JSONRPC = HTTP_CODE_TO_JSONRPC2[code]) !== null && _HTTP_CODE_TO_JSONRPC !== void 0 ? _HTTP_CODE_TO_JSONRPC : \"INTERNAL_SERVER_ERROR\";\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if (\"error\" in res && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(res.error.data)) {\n            var _res$error$data;\n            if (typeof ((_res$error$data = res.error.data) === null || _res$error$data === void 0 ? void 0 : _res$error$data[\"httpStatus\"]) === \"number\") return res.error.data[\"httpStatus\"];\n            const code = _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) return 207;\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\nvar require_typeof = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\" (exports, module) {\n        function _typeof$2(o) {\n            \"@babel/helpers - typeof\";\n            return module.exports = _typeof$2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n                return typeof o$1;\n            } : function(o$1) {\n                return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof$2(o);\n        }\n        module.exports = _typeof$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\nvar require_toPrimitive = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\" (exports, module) {\n        var _typeof$1 = require_typeof()[\"default\"];\n        function toPrimitive$1(t, r) {\n            if (\"object\" != _typeof$1(t) || !t) return t;\n            var e = t[Symbol.toPrimitive];\n            if (void 0 !== e) {\n                var i = e.call(t, r || \"default\");\n                if (\"object\" != _typeof$1(i)) return i;\n                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            return (\"string\" === r ? String : Number)(t);\n        }\n        module.exports = toPrimitive$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\nvar require_toPropertyKey = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\" (exports, module) {\n        var _typeof = require_typeof()[\"default\"];\n        var toPrimitive = require_toPrimitive();\n        function toPropertyKey$1(t) {\n            var i = toPrimitive(t, \"string\");\n            return \"symbol\" == _typeof(i) ? i : i + \"\";\n        }\n        module.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\nvar require_defineProperty = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\" (exports, module) {\n        var toPropertyKey = require_toPropertyKey();\n        function _defineProperty(e, r, t) {\n            return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n                value: t,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n            }) : e[r] = t, e;\n        }\n        module.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\nvar require_objectSpread2 = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\" (exports, module) {\n        var defineProperty = require_defineProperty();\n        function ownKeys(e, r) {\n            var t = Object.keys(e);\n            if (Object.getOwnPropertySymbols) {\n                var o = Object.getOwnPropertySymbols(e);\n                r && (o = o.filter(function(r$1) {\n                    return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n                })), t.push.apply(t, o);\n            }\n            return t;\n        }\n        function _objectSpread2(e) {\n            for(var r = 1; r < arguments.length; r++){\n                var t = null != arguments[r] ? arguments[r] : {};\n                r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n                    defineProperty(e, r$1, t[r$1]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n                    Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n                });\n            }\n            return e;\n        }\n        module.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* @internal\n*/ function getErrorShape(opts) {\n    const { path, error, config } = opts;\n    const { code } = opts.error;\n    const shape = {\n        message: error.message,\n        code: _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === \"string\") shape.data.stack = opts.error.stack;\n    if (typeof path === \"string\") shape.data.path = path;\n    return config.errorFormatter((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n        shape\n    }));\n}\n//#endregion\n //# sourceMappingURL=getErrorShape-Uhlrl4Bk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvZ2V0RXJyb3JTaGFwZS1VaGxybDRCay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLE1BQU0sT0FBTyxLQUVaLENBRmtCO0FBSW5CLE1BQU0sb0JBQW9CLENBQUNBO0lBQ3pCLElBQUksT0FBTyxPQUNULFFBQU8sT0FBTyxJQUFJO0FBRXJCO0FBRUQsU0FBUyxpQkFDUEMsUUFBQUEsRUFDQUMsSUFBQUEsRUFDQUMsSUFBQUEsRUFDQTs7SUFDQSxNQUFNLFdBQVcsS0FBSyxLQUFLLElBQUk7SUFFL0IsdUJBQUsscURBQUwsS0FBSyxZQUFjLElBQUksTUFBTSxNQUFNO1FBQ2pDLEtBQUksTUFBTSxLQUFLO1lBQ2IsV0FBVyxRQUFRLFlBQVksUUFBUSxPQUdyQztZQUVGLE9BQU8saUJBQWlCLFVBQVUsQ0FBQzttQkFBRztnQkFBTSxHQUFJO2FBQUEsRUFBRSxLQUFLO1FBQ3hEO1FBQ0QsT0FBTSxJQUFJLElBQUksTUFBTTtZQUNsQixNQUFNLGFBQWEsS0FBSyxLQUFLLFNBQVM7WUFFdEMsSUFBSSxPQUFPO2dCQUFFO2dCQUFNO1lBQU07WUFFekIsSUFBSSxlQUFlLE9BQ2pCLFFBQU87Z0JBQ0wsTUFBTSxLQUFLLFVBQVUsSUFBSTtvQkFBQyxLQUFLLEVBQUc7aUJBQUEsR0FBRyxDQUFFO2dCQUN2QyxNQUFNLEtBQUssTUFBTSxHQUFHLEdBQUc7WUFDeEI7cUJBQ1EsZUFBZSxRQUN4QixRQUFPO2dCQUNMLE1BQU0sS0FBSyxVQUFVLElBQUksS0FBSyxLQUFLLENBQUU7Z0JBQ3JDLE1BQU0sS0FBSyxNQUFNLEdBQUcsR0FBRztZQUN4QjtZQUVILGtCQUFrQixLQUFLLEtBQUs7WUFDNUIsa0JBQWtCLEtBQUssS0FBSztZ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QUNqRCIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2NyZWF0ZVByb3h5LnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvZ2V0SFRUUFN0YXR1c0NvZGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3R5cGVvZi5qcyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9QcmltaXRpdmUuanMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL2dldEVycm9yU2hhcGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIFByb3h5Q2FsbGJhY2tPcHRpb25zIHtcbiAgcGF0aDogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFyZ3M6IHJlYWRvbmx5IHVua25vd25bXTtcbn1cbnR5cGUgUHJveHlDYWxsYmFjayA9IChvcHRzOiBQcm94eUNhbGxiYWNrT3B0aW9ucykgPT4gdW5rbm93bjtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHtcbiAgLy8gbm9vcFxufTtcblxuY29uc3QgZnJlZXplSWZBdmFpbGFibGUgPSAob2JqOiBvYmplY3QpID0+IHtcbiAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyUHJveHkoXG4gIGNhbGxiYWNrOiBQcm94eUNhbGxiYWNrLFxuICBwYXRoOiByZWFkb25seSBzdHJpbmdbXSxcbiAgbWVtbzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pIHtcbiAgY29uc3QgY2FjaGVLZXkgPSBwYXRoLmpvaW4oJy4nKTtcblxuICBtZW1vW2NhY2hlS2V5XSA/Pz0gbmV3IFByb3h5KG5vb3AsIHtcbiAgICBnZXQoX29iaiwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwga2V5ID09PSAndGhlbicpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpZiB0aGUgcHJveHkgaXMgYWNjaWRlbnRhbGx5IHRyZWF0ZWRcbiAgICAgICAgLy8gbGlrZSBhIFByb21pc2VMaWtlIChsaWtlIGluIGBQcm9taXNlLnJlc29sdmUocHJveHkpYClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBbLi4ucGF0aCwga2V5XSwgbWVtbyk7XG4gICAgfSxcbiAgICBhcHBseShfMSwgXzIsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IGxhc3RPZlBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgIGxldCBvcHRzID0geyBhcmdzLCBwYXRoIH07XG4gICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBlLmcuIGB0cnBjLmhlbGxvLmNhbGwodGhpcywgJ3RoZXJlJylgIGFuZCBgdHJwYy5oZWxsby5hcHBseSh0aGlzLCBbJ3RoZXJlJ10pXG4gICAgICBpZiAobGFzdE9mUGF0aCA9PT0gJ2NhbGwnKSB7XG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgYXJnczogYXJncy5sZW5ndGggPj0gMiA/IFthcmdzWzFdXSA6IFtdLFxuICAgICAgICAgIHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChsYXN0T2ZQYXRoID09PSAnYXBwbHknKSB7XG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgYXJnczogYXJncy5sZW5ndGggPj0gMiA/IGFyZ3NbMV0gOiBbXSxcbiAgICAgICAgICBwYXRoOiBwYXRoLnNsaWNlKDAsIC0xKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyZWV6ZUlmQXZhaWxhYmxlKG9wdHMuYXJncyk7XG4gICAgICBmcmVlemVJZkF2YWlsYWJsZShvcHRzLnBhdGgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG9wdHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBtZW1vW2NhY2hlS2V5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgdGhhdCBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcGF0aCBhbmQgYXJndW1lbnRzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWN1cnNpdmVQcm94eSA9IDxURmF1eCA9IHVua25vd24+KFxuICBjYWxsYmFjazogUHJveHlDYWxsYmFjayxcbik6IFRGYXV4ID0+IGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFtdLCBPYmplY3QuY3JlYXRlKG51bGwpKSBhcyBURmF1eDtcblxuLyoqXG4gKiBVc2VkIGluIHBsYWNlIG9mIGBuZXcgUHJveHlgIHdoZXJlIGVhY2ggaGFuZGxlciB3aWxsIG1hcCAxIGxldmVsIGRlZXAgdG8gYW5vdGhlciB2YWx1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZsYXRQcm94eSA9IDxURmF1eD4oXG4gIGNhbGxiYWNrOiAocGF0aDoga2V5b2YgVEZhdXgpID0+IGFueSxcbik6IFRGYXV4ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShub29wLCB7XG4gICAgZ2V0KF9vYmosIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lID09PSAndGhlbicpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpZiB0aGUgcHJveHkgaXMgYWNjaWRlbnRhbGx5IHRyZWF0ZWRcbiAgICAgICAgLy8gbGlrZSBhIFByb21pc2VMaWtlIChsaWtlIGluIGBQcm9taXNlLnJlc29sdmUocHJveHkpYClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjayhuYW1lIGFzIGFueSk7XG4gICAgfSxcbiAgfSkgYXMgVEZhdXg7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUUlBDRXJyb3IgfSBmcm9tICcuLi9lcnJvci9UUlBDRXJyb3InO1xuaW1wb3J0IHR5cGUgeyBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSwgVFJQQ1Jlc3BvbnNlIH0gZnJvbSAnLi4vcnBjJztcbmltcG9ydCB7IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSIH0gZnJvbSAnLi4vcnBjJztcbmltcG9ydCB0eXBlIHsgSW52ZXJ0S2V5VmFsdWUsIFZhbHVlT2YgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IEpTT05SUEMyX1RPX0hUVFBfQ09ERTogUmVjb3JkPFxuICBrZXlvZiB0eXBlb2YgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVksXG4gIG51bWJlclxuPiA9IHtcbiAgUEFSU0VfRVJST1I6IDQwMCxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBNRVRIT0RfTk9UX1NVUFBPUlRFRDogNDA1LFxuICBUSU1FT1VUOiA0MDgsXG4gIENPTkZMSUNUOiA0MDksXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgVU5TVVBQT1JURURfTUVESUFfVFlQRTogNDE1LFxuICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IDQyMixcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgQ0xJRU5UX0NMT1NFRF9SRVFVRVNUOiA0OTksXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDUwMSxcbiAgQkFEX0dBVEVXQVk6IDUwMixcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcbn07XG5cbmV4cG9ydCBjb25zdCBIVFRQX0NPREVfVE9fSlNPTlJQQzI6IEludmVydEtleVZhbHVlPFxuICB0eXBlb2YgSlNPTlJQQzJfVE9fSFRUUF9DT0RFXG4+ID0ge1xuICA0MDA6ICdCQURfUkVRVUVTVCcsXG4gIDQwMTogJ1VOQVVUSE9SSVpFRCcsXG4gIDQwMjogJ1BBWU1FTlRfUkVRVUlSRUQnLFxuICA0MDM6ICdGT1JCSURERU4nLFxuICA0MDQ6ICdOT1RfRk9VTkQnLFxuICA0MDU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gIDQwODogJ1RJTUVPVVQnLFxuICA0MDk6ICdDT05GTElDVCcsXG4gIDQxMjogJ1BSRUNPTkRJVElPTl9GQUlMRUQnLFxuICA0MTM6ICdQQVlMT0FEX1RPT19MQVJHRScsXG4gIDQxNTogJ1VOU1VQUE9SVEVEX01FRElBX1RZUEUnLFxuICA0MjI6ICdVTlBST0NFU1NBQkxFX0NPTlRFTlQnLFxuICA0Mjk6ICdUT09fTUFOWV9SRVFVRVNUUycsXG4gIDQ5OTogJ0NMSUVOVF9DTE9TRURfUkVRVUVTVCcsXG4gIDUwMDogJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUicsXG4gIDUwMTogJ05PVF9JTVBMRU1FTlRFRCcsXG4gIDUwMjogJ0JBRF9HQVRFV0FZJyxcbiAgNTAzOiAnU0VSVklDRV9VTkFWQUlMQUJMRScsXG4gIDUwNDogJ0dBVEVXQVlfVElNRU9VVCcsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUZyb21LZXkoXG4gIGNvZGU6IGtleW9mIHR5cGVvZiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSxcbikge1xuICByZXR1cm4gSlNPTlJQQzJfVE9fSFRUUF9DT0RFW2NvZGVdID8/IDUwMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0tleUZyb21Db2RlKFxuICBjb2RlOiBrZXlvZiB0eXBlb2YgSFRUUF9DT0RFX1RPX0pTT05SUEMyLFxuKTogVmFsdWVPZjx0eXBlb2YgSFRUUF9DT0RFX1RPX0pTT05SUEMyPiB7XG4gIHJldHVybiBIVFRQX0NPREVfVE9fSlNPTlJQQzJbY29kZV0gPz8gJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZShqc29uOiBUUlBDUmVzcG9uc2UgfCBUUlBDUmVzcG9uc2VbXSkge1xuICBjb25zdCBhcnIgPSBBcnJheS5pc0FycmF5KGpzb24pID8ganNvbiA6IFtqc29uXTtcbiAgY29uc3QgaHR0cFN0YXR1c2VzID0gbmV3IFNldDxudW1iZXI+KFxuICAgIGFyci5tYXAoKHJlcykgPT4ge1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzICYmIGlzT2JqZWN0KHJlcy5lcnJvci5kYXRhKSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcy5lcnJvci5kYXRhPy5bJ2h0dHBTdGF0dXMnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gcmVzLmVycm9yLmRhdGFbJ2h0dHBTdGF0dXMnXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVJbcmVzLmVycm9yLmNvZGVdO1xuICAgICAgICByZXR1cm4gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMjAwO1xuICAgIH0pLFxuICApO1xuXG4gIGlmIChodHRwU3RhdHVzZXMuc2l6ZSAhPT0gMSkge1xuICAgIHJldHVybiAyMDc7XG4gIH1cblxuICBjb25zdCBodHRwU3RhdHVzID0gaHR0cFN0YXR1c2VzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICByZXR1cm4gaHR0cFN0YXR1cyE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcjogVFJQQ0Vycm9yKSB7XG4gIHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShlcnJvci5jb2RlKTtcbn1cbiIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9QcmltaXRpdmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKFwiLi90b1ByaW1pdGl2ZS5qc1wiKTtcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKFwiLi90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHsgZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IgfSBmcm9tICcuLi9odHRwL2dldEhUVFBTdGF0dXNDb2RlJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlVHlwZSB9IGZyb20gJy4uL3Byb2NlZHVyZSc7XG5pbXBvcnQgdHlwZSB7IEFueVJvb3RUeXBlcywgUm9vdENvbmZpZyB9IGZyb20gJy4uL3Jvb3RDb25maWcnO1xuaW1wb3J0IHsgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkgfSBmcm9tICcuLi9ycGMnO1xuaW1wb3J0IHR5cGUgeyBEZWZhdWx0RXJyb3JTaGFwZSB9IGZyb20gJy4vZm9ybWF0dGVyJztcbmltcG9ydCB0eXBlIHsgVFJQQ0Vycm9yIH0gZnJvbSAnLi9UUlBDRXJyb3InO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JTaGFwZTxUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcz4ob3B0czoge1xuICBjb25maWc6IFJvb3RDb25maWc8VFJvb3Q+O1xuICBlcnJvcjogVFJQQ0Vycm9yO1xuICB0eXBlOiBQcm9jZWR1cmVUeXBlIHwgJ3Vua25vd24nO1xuICBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGlucHV0OiB1bmtub3duO1xuICBjdHg6IFRSb290WydjdHgnXSB8IHVuZGVmaW5lZDtcbn0pOiBUUm9vdFsnZXJyb3JTaGFwZSddIHtcbiAgY29uc3QgeyBwYXRoLCBlcnJvciwgY29uZmlnIH0gPSBvcHRzO1xuICBjb25zdCB7IGNvZGUgfSA9IG9wdHMuZXJyb3I7XG4gIGNvbnN0IHNoYXBlOiBEZWZhdWx0RXJyb3JTaGFwZSA9IHtcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIGNvZGU6IFRSUENfRVJST1JfQ09ERVNfQllfS0VZW2NvZGVdLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvZGUsXG4gICAgICBodHRwU3RhdHVzOiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvciksXG4gICAgfSxcbiAgfTtcbiAgaWYgKGNvbmZpZy5pc0RldiAmJiB0eXBlb2Ygb3B0cy5lcnJvci5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICBzaGFwZS5kYXRhLnN0YWNrID0gb3B0cy5lcnJvci5zdGFjaztcbiAgfVxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgc2hhcGUuZGF0YS5wYXRoID0gcGF0aDtcbiAgfVxuICByZXR1cm4gY29uZmlnLmVycm9yRm9ybWF0dGVyKHsgLi4ub3B0cywgc2hhcGUgfSk7XG59XG4iXSwibmFtZXMiOlsib2JqOiBvYmplY3QiLCJjYWxsYmFjazogUHJveHlDYWxsYmFjayIsInBhdGg6IHJlYWRvbmx5IHN0cmluZ1tdIiwibWVtbzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4iLCJjYWxsYmFjazogKHBhdGg6IGtleW9mIFRGYXV4KSA9PiBhbnkiLCJKU09OUlBDMl9UT19IVFRQX0NPREU6IFJlY29yZDxcbiAga2V5b2YgdHlwZW9mIFRSUENfRVJST1JfQ09ERVNfQllfS0VZLFxuICBudW1iZXJcbj4iLCJIVFRQX0NPREVfVE9fSlNPTlJQQzI6IEludmVydEtleVZhbHVlPFxuICB0eXBlb2YgSlNPTlJQQzJfVE9fSFRUUF9DT0RFXG4+IiwiY29kZToga2V5b2YgdHlwZW9mIFRSUENfRVJST1JfQ09ERVNfQllfS0VZIiwiY29kZToga2V5b2YgdHlwZW9mIEhUVFBfQ09ERV9UT19KU09OUlBDMiIsImpzb246IFRSUENSZXNwb25zZSB8IFRSUENSZXNwb25zZVtdIiwiZXJyb3I6IFRSUENFcnJvciIsIl90eXBlb2YiLCJvIiwidG9QcmltaXRpdmUiLCJ0b1Byb3BlcnR5S2V5IiwiciIsIm9wdHM6IHtcbiAgY29uZmlnOiBSb290Q29uZmlnPFRSb290PjtcbiAgZXJyb3I6IFRSUENFcnJvcjtcbiAgdHlwZTogUHJvY2VkdXJlVHlwZSB8ICd1bmtub3duJztcbiAgcGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpbnB1dDogdW5rbm93bjtcbiAgY3R4OiBUUm9vdFsnY3R4J10gfCB1bmRlZmluZWQ7XG59Iiwic2hhcGU6IERlZmF1bHRFcnJvclNoYXBlIl0sImlnbm9yZUxpc3QiOlsyLDMsNCw1LDZdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/initTRPC-IT_6ZYJd.mjs":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/initTRPC-IT_6ZYJd.mjs ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandardSchemaV1Error: () => (/* binding */ StandardSchemaV1Error),\n/* harmony export */   createBuilder: () => (/* binding */ createBuilder),\n/* harmony export */   createInputMiddleware: () => (/* binding */ createInputMiddleware),\n/* harmony export */   createMiddlewareFactory: () => (/* binding */ createMiddlewareFactory),\n/* harmony export */   createOutputMiddleware: () => (/* binding */ createOutputMiddleware),\n/* harmony export */   experimental_standaloneMiddleware: () => (/* binding */ experimental_standaloneMiddleware),\n/* harmony export */   getParseFn: () => (/* binding */ getParseFn),\n/* harmony export */   initTRPC: () => (/* binding */ initTRPC),\n/* harmony export */   isServerDefault: () => (/* binding */ isServerDefault),\n/* harmony export */   middlewareMarker: () => (/* binding */ middlewareMarker)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\");\n/* harmony import */ var _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-gU3ttYjg.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs\");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n\n\n\n//#region src/unstable-core-do-not-import/middleware.ts\nvar import_objectSpread2$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/** @internal */ const middlewareMarker = \"middlewareMarker\";\n/**\n* @internal\n*/ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = \"_middlewares\" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\n/**\n* Create a standalone middleware\n* @see https://trpc.io/docs/v11/server/middlewares#experimental-standalone-middlewares\n* @deprecated use `.concat()` instead\n*/ const experimental_standaloneMiddleware = ()=>({\n        create: createMiddlewareFactory()\n    });\n/**\n* @internal\n* Please note, `trpc-openapi` uses this function.\n*/ function createInputMiddleware(parse) {\n    const inputMiddleware = async function inputValidatorMiddleware(opts) {\n        let parsedInput;\n        const rawInput = await opts.getRawInput();\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                code: \"BAD_REQUEST\",\n                cause\n            });\n        }\n        const combinedInput = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(opts.input) && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_2__.isObject)(parsedInput) ? (0, import_objectSpread2$2.default)((0, import_objectSpread2$2.default)({}, opts.input), parsedInput) : parsedInput;\n        return opts.next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = \"input\";\n    return inputMiddleware;\n}\n/**\n* @internal\n*/ function createOutputMiddleware(parse) {\n    const outputMiddleware = async function outputValidatorMiddleware({ next }) {\n        const result = await next();\n        if (!result.ok) return result;\n        try {\n            const data = await parse(result.data);\n            return (0, import_objectSpread2$2.default)((0, import_objectSpread2$2.default)({}, result), {}, {\n                data\n            });\n        } catch (cause) {\n            throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                message: \"Output validation failed\",\n                code: \"INTERNAL_SERVER_ERROR\",\n                cause\n            });\n        }\n    };\n    outputMiddleware._type = \"output\";\n    return outputMiddleware;\n}\n//#endregion\n//#region src/vendor/standard-schema-v1/error.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_defineProperty)(), 1);\n/** A schema error with useful information. */ var StandardSchemaV1Error = class extends Error {\n    /**\n\t* Creates a schema error with useful information.\n\t*\n\t* @param issues The schema issues.\n\t*/ constructor(issues){\n        var _issues$;\n        super((_issues$ = issues[0]) === null || _issues$ === void 0 ? void 0 : _issues$.message);\n        (0, import_defineProperty.default)(this, \"issues\", void 0);\n        this.name = \"SchemaError\";\n        this.issues = issues;\n    }\n};\n//#endregion\n//#region src/unstable-core-do-not-import/parser.ts\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    const isStandardSchema = \"~standard\" in parser;\n    if (typeof parser === \"function\" && typeof parser.assert === \"function\") return parser.assert.bind(parser);\n    if (typeof parser === \"function\" && !isStandardSchema) return parser;\n    if (typeof parser.parseAsync === \"function\") return parser.parseAsync.bind(parser);\n    if (typeof parser.parse === \"function\") return parser.parse.bind(parser);\n    if (typeof parser.validateSync === \"function\") return parser.validateSync.bind(parser);\n    if (typeof parser.create === \"function\") return parser.create.bind(parser);\n    if (typeof parser.assert === \"function\") return (value)=>{\n        parser.assert(value);\n        return value;\n    };\n    if (isStandardSchema) return async (value)=>{\n        const result = await parser[\"~standard\"].validate(value);\n        if (result.issues) throw new StandardSchemaV1Error(result.issues);\n        return result.value;\n    };\n    throw new Error(\"Could not find a validator fn\");\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutPropertiesLoose.js\nvar require_objectWithoutPropertiesLoose = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutPropertiesLoose.js\" (exports, module) {\n        function _objectWithoutPropertiesLoose(r, e) {\n            if (null == r) return {};\n            var t = {};\n            for(var n in r)if (({}).hasOwnProperty.call(r, n)) {\n                if (e.includes(n)) continue;\n                t[n] = r[n];\n            }\n            return t;\n        }\n        module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutProperties.js\nvar require_objectWithoutProperties = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutProperties.js\" (exports, module) {\n        var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();\n        function _objectWithoutProperties$1(e, t) {\n            if (null == e) return {};\n            var o, r, i = objectWithoutPropertiesLoose(e, t);\n            if (Object.getOwnPropertySymbols) {\n                var s = Object.getOwnPropertySymbols(e);\n                for(r = 0; r < s.length; r++)o = s[r], t.includes(o) || ({}).propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n            }\n            return i;\n        }\n        module.exports = _objectWithoutProperties$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/procedureBuilder.ts\nvar import_objectWithoutProperties = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)(require_objectWithoutProperties(), 1);\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\nconst _excluded = [\n    \"middlewares\",\n    \"inputs\",\n    \"meta\"\n];\nfunction createNewBuilder(def1, def2) {\n    const { middlewares = [], inputs, meta } = def2, rest = (0, import_objectWithoutProperties.default)(def2, _excluded);\n    return createBuilder((0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_2__.mergeWithoutOverrides)(def1, rest)), {}, {\n        inputs: [\n            ...def1.inputs,\n            ...inputs !== null && inputs !== void 0 ? inputs : []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, def1.meta), meta) : meta !== null && meta !== void 0 ? meta : def1.meta\n    }));\n}\nfunction createBuilder(initDef = {}) {\n    const _def = (0, import_objectSpread2$1.default)({\n        procedure: true,\n        inputs: [],\n        middlewares: []\n    }, initDef);\n    const builder = {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parser = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parser)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta\n            });\n        },\n        use (middlewareBuilderOrFn) {\n            const middlewares = \"_middlewares\" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares\n            });\n        },\n        unstable_concat (builder$1) {\n            return createNewBuilder(_def, builder$1._def);\n        },\n        concat (builder$1) {\n            return createNewBuilder(_def, builder$1._def);\n        },\n        query (resolver) {\n            return createResolver((0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, _def), {}, {\n                type: \"query\"\n            }), resolver);\n        },\n        mutation (resolver) {\n            return createResolver((0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, _def), {}, {\n                type: \"mutation\"\n            }), resolver);\n        },\n        subscription (resolver) {\n            return createResolver((0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, _def), {}, {\n                type: \"subscription\"\n            }), resolver);\n        },\n        experimental_caller (caller) {\n            return createNewBuilder(_def, {\n                caller\n            });\n        }\n    };\n    return builder;\n}\nfunction createResolver(_defIn, resolver) {\n    const finalBuilder = createNewBuilder(_defIn, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    const _def = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, finalBuilder._def), {}, {\n        type: _defIn.type,\n        experimental_caller: Boolean(finalBuilder._def.caller),\n        meta: finalBuilder._def.meta,\n        $types: null\n    });\n    const invoke = createProcedureCaller(finalBuilder._def);\n    const callerOverride = finalBuilder._def.caller;\n    if (!callerOverride) return invoke;\n    const callerWrapper = async (...args)=>{\n        return await callerOverride({\n            args,\n            invoke,\n            _def\n        });\n    };\n    callerWrapper._def = _def;\n    return callerWrapper;\n}\nconst codeblock = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls\n`.trim();\nasync function callRecursive(index, _def, opts) {\n    try {\n        const middleware = _def.middlewares[index];\n        const result = await middleware((0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, opts), {}, {\n            meta: _def.meta,\n            input: opts.input,\n            next (_nextOpts) {\n                var _nextOpts$getRawInput;\n                const nextOpts = _nextOpts;\n                return callRecursive(index + 1, _def, (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, opts), {}, {\n                    ctx: (nextOpts === null || nextOpts === void 0 ? void 0 : nextOpts.ctx) ? (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, opts.ctx), nextOpts.ctx) : opts.ctx,\n                    input: nextOpts && \"input\" in nextOpts ? nextOpts.input : opts.input,\n                    getRawInput: (_nextOpts$getRawInput = nextOpts === null || nextOpts === void 0 ? void 0 : nextOpts.getRawInput) !== null && _nextOpts$getRawInput !== void 0 ? _nextOpts$getRawInput : opts.getRawInput\n                }));\n            }\n        }));\n        return result;\n    } catch (cause) {\n        return {\n            ok: false,\n            error: (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n            marker: middlewareMarker\n        };\n    }\n}\nfunction createProcedureCaller(_def) {\n    async function procedure(opts) {\n        if (!opts || !(\"getRawInput\" in opts)) throw new Error(codeblock);\n        const result = await callRecursive(0, _def, opts);\n        if (!result) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"INTERNAL_SERVER_ERROR\",\n            message: \"No result from middlewares - did you forget to `return next()`?\"\n        });\n        if (!result.ok) throw result.error;\n        return result.data;\n    }\n    procedure._def = _def;\n    procedure.procedure = true;\n    procedure.meta = _def.meta;\n    return procedure;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/rootConfig.ts\nvar _globalThis$process, _globalThis$process2, _globalThis$process3;\n/**\n* The default check to see if we're in a server\n*/ const isServerDefault =  true || 0;\n//#endregion\n//#region src/unstable-core-do-not-import/initTRPC.ts\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\nvar TRPCBuilder = class TRPCBuilder {\n    /**\n\t* Add a context shape as a generic to the root object\n\t* @see https://trpc.io/docs/v11/server/context\n\t*/ context() {\n        return new TRPCBuilder();\n    }\n    /**\n\t* Add a meta shape as a generic to the root object\n\t* @see https://trpc.io/docs/v11/quickstart\n\t*/ meta() {\n        return new TRPCBuilder();\n    }\n    /**\n\t* Create the root object\n\t* @see https://trpc.io/docs/v11/server/routers#initialize-trpc\n\t*/ create(opts) {\n        var _opts$transformer, _opts$isDev, _globalThis$process$1, _opts$allowOutsideOfS, _opts$errorFormatter, _opts$isServer;\n        const config = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n            transformer: (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getDataTransformer)((_opts$transformer = opts === null || opts === void 0 ? void 0 : opts.transformer) !== null && _opts$transformer !== void 0 ? _opts$transformer : _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultTransformer),\n            isDev: (_opts$isDev = opts === null || opts === void 0 ? void 0 : opts.isDev) !== null && _opts$isDev !== void 0 ? _opts$isDev : ((_globalThis$process$1 = globalThis.process) === null || _globalThis$process$1 === void 0 ? void 0 : _globalThis$process$1.env[\"NODE_ENV\"]) !== \"production\",\n            allowOutsideOfServer: (_opts$allowOutsideOfS = opts === null || opts === void 0 ? void 0 : opts.allowOutsideOfServer) !== null && _opts$allowOutsideOfS !== void 0 ? _opts$allowOutsideOfS : false,\n            errorFormatter: (_opts$errorFormatter = opts === null || opts === void 0 ? void 0 : opts.errorFormatter) !== null && _opts$errorFormatter !== void 0 ? _opts$errorFormatter : _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultFormatter,\n            isServer: (_opts$isServer = opts === null || opts === void 0 ? void 0 : opts.isServer) !== null && _opts$isServer !== void 0 ? _opts$isServer : isServerDefault,\n            $types: null\n        });\n        {\n            var _opts$isServer2;\n            const isServer = (_opts$isServer2 = opts === null || opts === void 0 ? void 0 : opts.isServer) !== null && _opts$isServer2 !== void 0 ? _opts$isServer2 : isServerDefault;\n            if (!isServer && (opts === null || opts === void 0 ? void 0 : opts.allowOutsideOfServer) !== true) throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n        }\n        return {\n            _config: config,\n            procedure: createBuilder({\n                meta: opts === null || opts === void 0 ? void 0 : opts.defaultMeta\n            }),\n            middleware: createMiddlewareFactory(),\n            router: (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.createRouterFactory)(config),\n            mergeRouters: _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.mergeRouters,\n            createCallerFactory: (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.createCallerFactory)()\n        };\n    }\n};\n/**\n* Builder to initialize the tRPC root object - use this exactly once per backend\n* @see https://trpc.io/docs/v11/quickstart\n*/ const initTRPC = new TRPCBuilder();\n//#endregion\n //# sourceMappingURL=initTRPC-IT_6ZYJd.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvaW5pdFRSUEMtSVRfNlpZSmQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFPQSxNQUFhLG1CQUFtQjs7O0dBbUhoQyxTQUFnQiwwQkFJWjtJQUNGLFNBQVMsc0JBQ1BBLFdBQUFBLEVBQ3NCO1FBQ3RCLE9BQU87WUFDTCxjQUFjO1lBQ2QsZUFBYyx1QkFBdUI7Z0JBQ25DLE1BQU0sa0JBQ0osa0JBQWtCLHdCQUNkLHNCQUFzQixlQUN0QjtvQkFBQyxxQkFBc0I7aUJBQUE7Z0JBRTdCLE9BQU8sc0JBQXNCLENBQUM7dUJBQUc7dUJBQWdCLGVBQWdCO2lCQUFBLENBQUM7WUFDbkU7UUFDRjtJQUNGO0lBRUQsU0FBUyxpQkFDUEMsRUFBQUEsRUFPa0U7UUFDbEUsT0FBTyxzQkFBc0I7WUFBQyxFQUFHO1NBQUEsQ0FBQztJQUNuQztJQUVELE9BQU87QUFDUjs7Ozs7R0FPRCxNQUFhLG9DQUFvQyxLQU16QztRQUNOLFFBQVEseUJBSUw7S0FDSjs7OztHQU1ELFNBQWdCLHNCQUE4QkMsS0FBQUEsRUFBd0I7SUFDcEUsTUFBTUMsa0JBQ0osZUFBZSx5QkFBeUIsTUFBTTtRQUM1QyxJQUFJQztRQUVKLE1BQU0sV0FBVyxNQUFNLEtBQUssYUFBYTtRQUN6QyxJQUFJO1lBQ0YsY0FBYyxNQUFNLE1BQU0sU0FBUztRQUNwQyxTQUFRLE9BQU87WUFDZCxNQUFNLElBQUksNERBQVMsQ0FBQztnQkFDbEIsTUFBTTtnQkFDTjtZQUNEO1FBQ0Y7UUFHRCxNQUFNLGdCQUNKLDZEQUFRLENBQUMsS0FBSyxNQUFNLElBQUksNkRBQVEsQ0FBQyxZQUFZLCtFQUVwQyxLQUFLLFFBQ0wsZUFFTDtRQUVOLE9BQU8sS0FBSyxLQUFLO1lBQUUsT0FBTztRQUFlLEVBQUM7SUFDM0M7SUFDSCxn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Ozs7Ozs7R0MvcEJELE1BQWFDLGtCQUFBQSxLQUtpQixLQUNBOzs7O0FDMkY5QixJQUFNLGNBQU4sTUFBTSxZQUEyRDs7OztJQUsvRCxVQUF3RDtRQUN0RCxPQUFPLElBQUk7SUFJWjs7OztJQU1ELE9BQWdDO1FBQzlCLE9BQU8sSUFBSTtJQUNaOzs7O0lBTUQsT0FDRUMsSUFBQUEsRUFDMkM7O1FBVTNDLE1BQU1DLFNBQUFBLENBQUFBLEdBQUFBLHFCQUFBQSxPQUFBQSxFQUFBQSxDQUFBQSxHQUFBQSxxQkFBQUEsT0FBQUEsRUFBQUEsQ0FBQUEsR0FDRDtZQUNILGFBQWEseUVBQWtCLENBQWxCLGlFQUFtQixLQUFNLDRFQUFlLHFFQUFrQixDQUFDO1lBQ3hFLGtFQUNFLEtBQU0sb0ZBRU4sV0FBVyx1RkFBUyxJQUFJLGlCQUFnQjtZQUMxQywyRkFBc0IsS0FBTSw2RkFBd0I7WUFDcEQsb0ZBQWdCLEtBQU0scUZBQWtCLG1FQUFnQjtZQUN4RCx3RUFBVSxLQUFNLG1FQUFZO1lBSzVCLFFBQVE7O1FBR1Y7O1lBRUUsTUFBTUMsV0FBQUEsQ0FBQUEsa0JBQUFBLFNBQUFBLFFBQUFBLFNBQUFBLEtBQUFBLElBQUFBLEtBQUFBLElBQW9CLEtBQU0scUVBQVk7WUFFNUMsS0FBSyx5REFBWSxLQUFNLDBCQUF5QixLQUM5QyxPQUFNLElBQUksT0FDUDtRQUdOO1FBQ0QsT0FBTztZQUtMLFNBQVM7WUFLVCxXQUFXLGNBQTJDO2dCQUNwRCxrREFBTSxLQUFNO1lBQ2IsRUFBQztZQUtGLFlBQVkseUJBQXNEO1lBS2xFLFFBQVEsMEVBQW1CLENBQVEsT0FBTztZQUsxQyxZQUFZO1lBS1oscUJBQXFCLDBFQUFtQixFQUFTO1FBQ2xEO0lBQ0Y7QUFDRjs7OztHQU1ELE1BQWEsV0FBVyxJQUFJIiwic291cmNlcyI6WyIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvbWlkZGxld2FyZS50cyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3ZlbmRvci9zdGFuZGFyZC1zY2hlbWEtdjEvZXJyb3IudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcGFyc2VyLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RXaXRob3V0UHJvcGVydGllcy5qcyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9wcm9jZWR1cmVCdWlsZGVyLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3Jvb3RDb25maWcudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaW5pdFRSUEMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVFJQQ0Vycm9yIH0gZnJvbSAnLi9lcnJvci9UUlBDRXJyb3InO1xuaW1wb3J0IHR5cGUgeyBQYXJzZUZuIH0gZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHR5cGUgeyBQcm9jZWR1cmVUeXBlIH0gZnJvbSAnLi9wcm9jZWR1cmUnO1xuaW1wb3J0IHR5cGUgeyBHZXRSYXdJbnB1dEZuLCBPdmVyd3JpdGUsIFNpbXBsaWZ5IH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgbWlkZGxld2FyZU1hcmtlciA9ICdtaWRkbGV3YXJlTWFya2VyJyBhcyAnbWlkZGxld2FyZU1hcmtlcicgJiB7XG4gIF9fYnJhbmQ6ICdtaWRkbGV3YXJlTWFya2VyJztcbn07XG50eXBlIE1pZGRsZXdhcmVNYXJrZXIgPSB0eXBlb2YgbWlkZGxld2FyZU1hcmtlcjtcblxuaW50ZXJmYWNlIE1pZGRsZXdhcmVSZXN1bHRCYXNlIHtcbiAgLyoqXG4gICAqIEFsbCBtaWRkbGV3YXJlcyBzaG91bGQgcGFzcyB0aHJvdWdoIHRoZWlyIGBuZXh0KClgJ3Mgb3V0cHV0LlxuICAgKiBSZXF1aXJpbmcgdGhpcyBtYXJrZXIgbWFrZXMgc3VyZSB0aGF0IGNhbid0IGJlIGZvcmdvdHRlbiBhdCBjb21waWxlLXRpbWUuXG4gICAqL1xuICByZWFkb25seSBtYXJrZXI6IE1pZGRsZXdhcmVNYXJrZXI7XG59XG5cbmludGVyZmFjZSBNaWRkbGV3YXJlT0tSZXN1bHQ8X1RDb250ZXh0T3ZlcnJpZGU+IGV4dGVuZHMgTWlkZGxld2FyZVJlc3VsdEJhc2Uge1xuICBvazogdHJ1ZTtcbiAgZGF0YTogdW5rbm93bjtcbiAgLy8gdGhpcyBjb3VsZCBiZSBleHRlbmRlZCB3aXRoIGBpbnB1dGAvYHJhd0lucHV0YCBsYXRlclxufVxuXG5pbnRlcmZhY2UgTWlkZGxld2FyZUVycm9yUmVzdWx0PF9UQ29udGV4dE92ZXJyaWRlPlxuICBleHRlbmRzIE1pZGRsZXdhcmVSZXN1bHRCYXNlIHtcbiAgb2s6IGZhbHNlO1xuICBlcnJvcjogVFJQQ0Vycm9yO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBNaWRkbGV3YXJlUmVzdWx0PF9UQ29udGV4dE92ZXJyaWRlPiA9XG4gIHwgTWlkZGxld2FyZUVycm9yUmVzdWx0PF9UQ29udGV4dE92ZXJyaWRlPlxuICB8IE1pZGRsZXdhcmVPS1Jlc3VsdDxfVENvbnRleHRPdmVycmlkZT47XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWlkZGxld2FyZUJ1aWxkZXI8XG4gIFRDb250ZXh0LFxuICBUTWV0YSxcbiAgVENvbnRleHRPdmVycmlkZXMsXG4gIFRJbnB1dE91dCxcbj4ge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGJ1aWxkZXIgYmFzZWQgb24gdGhlIGN1cnJlbnQgbWlkZGxld2FyZSBidWlsZGVyXG4gICAqL1xuICB1bnN0YWJsZV9waXBlPCRDb250ZXh0T3ZlcnJpZGVzT3V0PihcbiAgICBmbjpcbiAgICAgIHwgTWlkZGxld2FyZUZ1bmN0aW9uPFxuICAgICAgICAgIFRDb250ZXh0LFxuICAgICAgICAgIFRNZXRhLFxuICAgICAgICAgIFRDb250ZXh0T3ZlcnJpZGVzLFxuICAgICAgICAgICRDb250ZXh0T3ZlcnJpZGVzT3V0LFxuICAgICAgICAgIFRJbnB1dE91dFxuICAgICAgICA+XG4gICAgICB8IE1pZGRsZXdhcmVCdWlsZGVyPFxuICAgICAgICAgIE92ZXJ3cml0ZTxUQ29udGV4dCwgVENvbnRleHRPdmVycmlkZXM+LFxuICAgICAgICAgIFRNZXRhLFxuICAgICAgICAgICRDb250ZXh0T3ZlcnJpZGVzT3V0LFxuICAgICAgICAgIFRJbnB1dE91dFxuICAgICAgICA+LFxuICApOiBNaWRkbGV3YXJlQnVpbGRlcjxcbiAgICBUQ29udGV4dCxcbiAgICBUTWV0YSxcbiAgICBPdmVyd3JpdGU8VENvbnRleHRPdmVycmlkZXMsICRDb250ZXh0T3ZlcnJpZGVzT3V0PixcbiAgICBUSW5wdXRPdXRcbiAgPjtcblxuICAvKipcbiAgICogTGlzdCBvZiBtaWRkbGV3YXJlcyB3aXRoaW4gdGhpcyBtaWRkbGV3YXJlIGJ1aWxkZXJcbiAgICovXG4gIF9taWRkbGV3YXJlczogTWlkZGxld2FyZUZ1bmN0aW9uPFxuICAgIFRDb250ZXh0LFxuICAgIFRNZXRhLFxuICAgIFRDb250ZXh0T3ZlcnJpZGVzLFxuICAgIG9iamVjdCxcbiAgICBUSW5wdXRPdXRcbiAgPltdO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdHlwZSBNaWRkbGV3YXJlRnVuY3Rpb248XG4gIFRDb250ZXh0LFxuICBUTWV0YSxcbiAgVENvbnRleHRPdmVycmlkZXNJbixcbiAgJENvbnRleHRPdmVycmlkZXNPdXQsXG4gIFRJbnB1dE91dCxcbj4gPSB7XG4gIChvcHRzOiB7XG4gICAgY3R4OiBTaW1wbGlmeTxPdmVyd3JpdGU8VENvbnRleHQsIFRDb250ZXh0T3ZlcnJpZGVzSW4+PjtcbiAgICB0eXBlOiBQcm9jZWR1cmVUeXBlO1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBpbnB1dDogVElucHV0T3V0O1xuICAgIGdldFJhd0lucHV0OiBHZXRSYXdJbnB1dEZuO1xuICAgIG1ldGE6IFRNZXRhIHwgdW5kZWZpbmVkO1xuICAgIHNpZ25hbDogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQ7XG4gICAgbmV4dDoge1xuICAgICAgKCk6IFByb21pc2U8TWlkZGxld2FyZVJlc3VsdDxUQ29udGV4dE92ZXJyaWRlc0luPj47XG4gICAgICA8JENvbnRleHRPdmVycmlkZT4ob3B0czoge1xuICAgICAgICBjdHg/OiAkQ29udGV4dE92ZXJyaWRlO1xuICAgICAgICBpbnB1dD86IHVua25vd247XG4gICAgICB9KTogUHJvbWlzZTxNaWRkbGV3YXJlUmVzdWx0PCRDb250ZXh0T3ZlcnJpZGU+PjtcbiAgICAgIChvcHRzOiB7XG4gICAgICAgIGdldFJhd0lucHV0OiBHZXRSYXdJbnB1dEZuO1xuICAgICAgfSk6IFByb21pc2U8TWlkZGxld2FyZVJlc3VsdDxUQ29udGV4dE92ZXJyaWRlc0luPj47XG4gICAgfTtcbiAgfSk6IFByb21pc2U8TWlkZGxld2FyZVJlc3VsdDwkQ29udGV4dE92ZXJyaWRlc091dD4+O1xuICBfdHlwZT86IHN0cmluZyB8IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCB0eXBlIEFueU1pZGRsZXdhcmVGdW5jdGlvbiA9IE1pZGRsZXdhcmVGdW5jdGlvbjxhbnksIGFueSwgYW55LCBhbnksIGFueT47XG5leHBvcnQgdHlwZSBBbnlNaWRkbGV3YXJlQnVpbGRlciA9IE1pZGRsZXdhcmVCdWlsZGVyPGFueSwgYW55LCBhbnksIGFueT47XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZUZhY3Rvcnk8XG4gIFRDb250ZXh0LFxuICBUTWV0YSxcbiAgVElucHV0T3V0ID0gdW5rbm93bixcbj4oKSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihcbiAgICBtaWRkbGV3YXJlczogQW55TWlkZGxld2FyZUZ1bmN0aW9uW10sXG4gICk6IEFueU1pZGRsZXdhcmVCdWlsZGVyIHtcbiAgICByZXR1cm4ge1xuICAgICAgX21pZGRsZXdhcmVzOiBtaWRkbGV3YXJlcyxcbiAgICAgIHVuc3RhYmxlX3BpcGUobWlkZGxld2FyZUJ1aWxkZXJPckZuKSB7XG4gICAgICAgIGNvbnN0IHBpcGVkTWlkZGxld2FyZSA9XG4gICAgICAgICAgJ19taWRkbGV3YXJlcycgaW4gbWlkZGxld2FyZUJ1aWxkZXJPckZuXG4gICAgICAgICAgICA/IG1pZGRsZXdhcmVCdWlsZGVyT3JGbi5fbWlkZGxld2FyZXNcbiAgICAgICAgICAgIDogW21pZGRsZXdhcmVCdWlsZGVyT3JGbl07XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1pZGRsZXdhcmVJbm5lcihbLi4ubWlkZGxld2FyZXMsIC4uLnBpcGVkTWlkZGxld2FyZV0pO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZTwkQ29udGV4dE92ZXJyaWRlcz4oXG4gICAgZm46IE1pZGRsZXdhcmVGdW5jdGlvbjxcbiAgICAgIFRDb250ZXh0LFxuICAgICAgVE1ldGEsXG4gICAgICBvYmplY3QsXG4gICAgICAkQ29udGV4dE92ZXJyaWRlcyxcbiAgICAgIFRJbnB1dE91dFxuICAgID4sXG4gICk6IE1pZGRsZXdhcmVCdWlsZGVyPFRDb250ZXh0LCBUTWV0YSwgJENvbnRleHRPdmVycmlkZXMsIFRJbnB1dE91dD4ge1xuICAgIHJldHVybiBjcmVhdGVNaWRkbGV3YXJlSW5uZXIoW2ZuXSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRlTWlkZGxld2FyZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzdGFuZGFsb25lIG1pZGRsZXdhcmVcbiAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9taWRkbGV3YXJlcyNleHBlcmltZW50YWwtc3RhbmRhbG9uZS1taWRkbGV3YXJlc1xuICogQGRlcHJlY2F0ZWQgdXNlIGAuY29uY2F0KClgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbF9zdGFuZGFsb25lTWlkZGxld2FyZSA9IDxcbiAgVEN0eCBleHRlbmRzIHtcbiAgICBjdHg/OiBvYmplY3Q7XG4gICAgbWV0YT86IG9iamVjdDtcbiAgICBpbnB1dD86IHVua25vd247XG4gIH0sXG4+KCkgPT4gKHtcbiAgY3JlYXRlOiBjcmVhdGVNaWRkbGV3YXJlRmFjdG9yeTxcbiAgICBUQ3R4IGV4dGVuZHMgeyBjdHg6IGluZmVyIFQgZXh0ZW5kcyBvYmplY3QgfSA/IFQgOiBhbnksXG4gICAgVEN0eCBleHRlbmRzIHsgbWV0YTogaW5mZXIgVCBleHRlbmRzIG9iamVjdCB9ID8gVCA6IG9iamVjdCxcbiAgICBUQ3R4IGV4dGVuZHMgeyBpbnB1dDogaW5mZXIgVCB9ID8gVCA6IHVua25vd25cbiAgPigpLFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBQbGVhc2Ugbm90ZSwgYHRycGMtb3BlbmFwaWAgdXNlcyB0aGlzIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5wdXRNaWRkbGV3YXJlPFRJbnB1dD4ocGFyc2U6IFBhcnNlRm48VElucHV0Pikge1xuICBjb25zdCBpbnB1dE1pZGRsZXdhcmU6IEFueU1pZGRsZXdhcmVGdW5jdGlvbiA9XG4gICAgYXN5bmMgZnVuY3Rpb24gaW5wdXRWYWxpZGF0b3JNaWRkbGV3YXJlKG9wdHMpIHtcbiAgICAgIGxldCBwYXJzZWRJbnB1dDogUmV0dXJuVHlwZTx0eXBlb2YgcGFyc2U+O1xuXG4gICAgICBjb25zdCByYXdJbnB1dCA9IGF3YWl0IG9wdHMuZ2V0UmF3SW5wdXQoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZElucHV0ID0gYXdhaXQgcGFyc2UocmF3SW5wdXQpO1xuICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGxlIGlucHV0IHBhcnNlcnNcbiAgICAgIGNvbnN0IGNvbWJpbmVkSW5wdXQgPVxuICAgICAgICBpc09iamVjdChvcHRzLmlucHV0KSAmJiBpc09iamVjdChwYXJzZWRJbnB1dClcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgLi4ub3B0cy5pbnB1dCxcbiAgICAgICAgICAgICAgLi4ucGFyc2VkSW5wdXQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOiBwYXJzZWRJbnB1dDtcblxuICAgICAgcmV0dXJuIG9wdHMubmV4dCh7IGlucHV0OiBjb21iaW5lZElucHV0IH0pO1xuICAgIH07XG4gIGlucHV0TWlkZGxld2FyZS5fdHlwZSA9ICdpbnB1dCc7XG4gIHJldHVybiBpbnB1dE1pZGRsZXdhcmU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPdXRwdXRNaWRkbGV3YXJlPFRPdXRwdXQ+KHBhcnNlOiBQYXJzZUZuPFRPdXRwdXQ+KSB7XG4gIGNvbnN0IG91dHB1dE1pZGRsZXdhcmU6IEFueU1pZGRsZXdhcmVGdW5jdGlvbiA9XG4gICAgYXN5bmMgZnVuY3Rpb24gb3V0cHV0VmFsaWRhdG9yTWlkZGxld2FyZSh7IG5leHQgfSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbmV4dCgpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgLy8gcGFzcyB0aHJvdWdoIGZhaWx1cmVzIHdpdGhvdXQgdmFsaWRhdGluZ1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHBhcnNlKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6ICdPdXRwdXQgdmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICBvdXRwdXRNaWRkbGV3YXJlLl90eXBlID0gJ291dHB1dCc7XG4gIHJldHVybiBvdXRwdXRNaWRkbGV3YXJlO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBTdGFuZGFyZFNjaGVtYVYxIH0gZnJvbSBcIi4vc3BlY1wiO1xuXG4vKiogQSBzY2hlbWEgZXJyb3Igd2l0aCB1c2VmdWwgaW5mb3JtYXRpb24uICovXG5cbmV4cG9ydCBjbGFzcyBTdGFuZGFyZFNjaGVtYVYxRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBUaGUgc2NoZW1hIGlzc3Vlcy4gKi9cbiAgcHVibGljIHJlYWRvbmx5IGlzc3VlczogUmVhZG9ubHlBcnJheTxTdGFuZGFyZFNjaGVtYVYxLklzc3VlPjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNjaGVtYSBlcnJvciB3aXRoIHVzZWZ1bCBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGlzc3VlcyBUaGUgc2NoZW1hIGlzc3Vlcy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlzc3VlczogUmVhZG9ubHlBcnJheTxTdGFuZGFyZFNjaGVtYVYxLklzc3VlPikge1xuICAgIHN1cGVyKGlzc3Vlc1swXT8ubWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1NjaGVtYUVycm9yJztcbiAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgfVxufVxuIiwiaW1wb3J0IHsgU3RhbmRhcmRTY2hlbWFWMUVycm9yIH0gZnJvbSAnLi4vdmVuZG9yL3N0YW5kYXJkLXNjaGVtYS12MS9lcnJvcic7XG5pbXBvcnQgeyB0eXBlIFN0YW5kYXJkU2NoZW1hVjEgfSBmcm9tICcuLi92ZW5kb3Ivc3RhbmRhcmQtc2NoZW1hLXYxL3NwZWMnO1xuXG4vLyB6b2QgLyB0eXBlc2NoZW1hXG5leHBvcnQgdHlwZSBQYXJzZXJab2RFc3F1ZTxUSW5wdXQsIFRQYXJzZWRJbnB1dD4gPSB7XG4gIF9pbnB1dDogVElucHV0O1xuICBfb3V0cHV0OiBUUGFyc2VkSW5wdXQ7XG59O1xuXG5leHBvcnQgdHlwZSBQYXJzZXJWYWxpYm90RXNxdWU8VElucHV0LCBUUGFyc2VkSW5wdXQ+ID0ge1xuICBzY2hlbWE6IHtcbiAgICBfdHlwZXM/OiB7XG4gICAgICBpbnB1dDogVElucHV0O1xuICAgICAgb3V0cHV0OiBUUGFyc2VkSW5wdXQ7XG4gICAgfTtcbiAgfTtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnNlckFya1R5cGVFc3F1ZTxUSW5wdXQsIFRQYXJzZWRJbnB1dD4gPSB7XG4gIGluZmVySW46IFRJbnB1dDtcbiAgaW5mZXI6IFRQYXJzZWRJbnB1dDtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnNlclN0YW5kYXJkU2NoZW1hRXNxdWU8VElucHV0LCBUUGFyc2VkSW5wdXQ+ID0gU3RhbmRhcmRTY2hlbWFWMTxcbiAgVElucHV0LFxuICBUUGFyc2VkSW5wdXRcbj47XG5cbmV4cG9ydCB0eXBlIFBhcnNlck15Wm9kRXNxdWU8VElucHV0PiA9IHtcbiAgcGFyc2U6IChpbnB1dDogYW55KSA9PiBUSW5wdXQ7XG59O1xuXG5leHBvcnQgdHlwZSBQYXJzZXJTdXBlcnN0cnVjdEVzcXVlPFRJbnB1dD4gPSB7XG4gIGNyZWF0ZTogKGlucHV0OiB1bmtub3duKSA9PiBUSW5wdXQ7XG59O1xuXG5leHBvcnQgdHlwZSBQYXJzZXJDdXN0b21WYWxpZGF0b3JFc3F1ZTxUSW5wdXQ+ID0gKFxuICBpbnB1dDogdW5rbm93bixcbikgPT4gUHJvbWlzZTxUSW5wdXQ+IHwgVElucHV0O1xuXG5leHBvcnQgdHlwZSBQYXJzZXJZdXBFc3F1ZTxUSW5wdXQ+ID0ge1xuICB2YWxpZGF0ZVN5bmM6IChpbnB1dDogdW5rbm93bikgPT4gVElucHV0O1xufTtcblxuZXhwb3J0IHR5cGUgUGFyc2VyU2NhbGVFc3F1ZTxUSW5wdXQ+ID0ge1xuICBhc3NlcnQodmFsdWU6IHVua25vd24pOiBhc3NlcnRzIHZhbHVlIGlzIFRJbnB1dDtcbn07XG5cbmV4cG9ydCB0eXBlIFBhcnNlcldpdGhvdXRJbnB1dDxUSW5wdXQ+ID1cbiAgfCBQYXJzZXJDdXN0b21WYWxpZGF0b3JFc3F1ZTxUSW5wdXQ+XG4gIHwgUGFyc2VyTXlab2RFc3F1ZTxUSW5wdXQ+XG4gIHwgUGFyc2VyU2NhbGVFc3F1ZTxUSW5wdXQ+XG4gIHwgUGFyc2VyU3VwZXJzdHJ1Y3RFc3F1ZTxUSW5wdXQ+XG4gIHwgUGFyc2VyWXVwRXNxdWU8VElucHV0PjtcblxuZXhwb3J0IHR5cGUgUGFyc2VyV2l0aElucHV0T3V0cHV0PFRJbnB1dCwgVFBhcnNlZElucHV0PiA9XG4gIHwgUGFyc2VyWm9kRXNxdWU8VElucHV0LCBUUGFyc2VkSW5wdXQ+XG4gIHwgUGFyc2VyVmFsaWJvdEVzcXVlPFRJbnB1dCwgVFBhcnNlZElucHV0PlxuICB8IFBhcnNlckFya1R5cGVFc3F1ZTxUSW5wdXQsIFRQYXJzZWRJbnB1dD5cbiAgfCBQYXJzZXJTdGFuZGFyZFNjaGVtYUVzcXVlPFRJbnB1dCwgVFBhcnNlZElucHV0PjtcblxuZXhwb3J0IHR5cGUgUGFyc2VyID0gUGFyc2VyV2l0aElucHV0T3V0cHV0PGFueSwgYW55PiB8IFBhcnNlcldpdGhvdXRJbnB1dDxhbnk+O1xuXG5leHBvcnQgdHlwZSBpbmZlclBhcnNlcjxUUGFyc2VyIGV4dGVuZHMgUGFyc2VyPiA9XG4gIFRQYXJzZXIgZXh0ZW5kcyBQYXJzZXJXaXRoSW5wdXRPdXRwdXQ8aW5mZXIgJFRJbiwgaW5mZXIgJFRPdXQ+XG4gICAgPyB7XG4gICAgICAgIGluOiAkVEluO1xuICAgICAgICBvdXQ6ICRUT3V0O1xuICAgICAgfVxuICAgIDogVFBhcnNlciBleHRlbmRzIFBhcnNlcldpdGhvdXRJbnB1dDxpbmZlciAkSW5PdXQ+XG4gICAgICA/IHtcbiAgICAgICAgICBpbjogJEluT3V0O1xuICAgICAgICAgIG91dDogJEluT3V0O1xuICAgICAgICB9XG4gICAgICA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBQYXJzZUZuPFRUeXBlPiA9ICh2YWx1ZTogdW5rbm93bikgPT4gUHJvbWlzZTxUVHlwZT4gfCBUVHlwZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcnNlRm48VFR5cGU+KHByb2NlZHVyZVBhcnNlcjogUGFyc2VyKTogUGFyc2VGbjxUVHlwZT4ge1xuICBjb25zdCBwYXJzZXIgPSBwcm9jZWR1cmVQYXJzZXIgYXMgYW55O1xuICBjb25zdCBpc1N0YW5kYXJkU2NoZW1hID0gJ35zdGFuZGFyZCcgaW4gcGFyc2VyO1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwYXJzZXIuYXNzZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gUGFyc2VyQXJrVHlwZUVzcXVlIC0gYXJrdHlwZSBzY2hlbWFzIHNob3VsZG4ndCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbiBiZWNhdXNlIHRoZXkgcmV0dXJuIGEgdW5pb24gdHlwZSBpbnN0ZWFkIG9mIHRocm93aW5nXG4gICAgcmV0dXJuIHBhcnNlci5hc3NlcnQuYmluZChwYXJzZXIpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJzZXIgPT09ICdmdW5jdGlvbicgJiYgIWlzU3RhbmRhcmRTY2hlbWEpIHtcbiAgICAvLyBQYXJzZXJWYWxpYm90RXNxdWUgKD49IHYwLjMxLjApXG4gICAgLy8gUGFyc2VyQ3VzdG9tVmFsaWRhdG9yRXNxdWUgLSBub3RlIHRoZSBjaGVjayBmb3Igc3RhbmRhcmQtc2NoZW1hIGNvbmZvcm1hbmNlIC0gc29tZSBsaWJyYXJpZXMgbGlrZSBgZWZmZWN0YCB1c2UgZnVuY3Rpb24gc2NoZW1hcyB3aGljaCBhcmUgKm5vdCogYSBcInBhcnNlXCIgZnVuY3Rpb24uXG4gICAgcmV0dXJuIHBhcnNlcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyc2VyLnBhcnNlQXN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBQYXJzZXJab2RFc3F1ZVxuICAgIHJldHVybiBwYXJzZXIucGFyc2VBc3luYy5iaW5kKHBhcnNlcik7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcnNlci5wYXJzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFBhcnNlclpvZEVzcXVlXG4gICAgLy8gUGFyc2VyVmFsaWJvdEVzcXVlICg8IHYwLjEzLjApXG4gICAgcmV0dXJuIHBhcnNlci5wYXJzZS5iaW5kKHBhcnNlcik7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcnNlci52YWxpZGF0ZVN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBQYXJzZXJZdXBFc3F1ZVxuICAgIHJldHVybiBwYXJzZXIudmFsaWRhdGVTeW5jLmJpbmQocGFyc2VyKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyc2VyLmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFBhcnNlclN1cGVyc3RydWN0RXNxdWVcbiAgICByZXR1cm4gcGFyc2VyLmNyZWF0ZS5iaW5kKHBhcnNlcik7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcnNlci5hc3NlcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBQYXJzZXJTY2FsZUVzcXVlXG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgcGFyc2VyLmFzc2VydCh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWUgYXMgVFR5cGU7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChpc1N0YW5kYXJkU2NoZW1hKSB7XG4gICAgLy8gU3RhbmRhcmRTY2hlbWFFc3F1ZVxuICAgIHJldHVybiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlclsnfnN0YW5kYXJkJ10udmFsaWRhdGUodmFsdWUpO1xuICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN0YW5kYXJkU2NoZW1hVjFFcnJvcihyZXN1bHQuaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSB2YWxpZGF0b3IgZm4nKTtcbn1cbiIsImZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHIsIGUpIHtcbiAgaWYgKG51bGwgPT0gcikgcmV0dXJuIHt9O1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBuIGluIHIpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsIG4pKSB7XG4gICAgaWYgKGUuaW5jbHVkZXMobikpIGNvbnRpbnVlO1xuICAgIHRbbl0gPSByW25dO1xuICB9XG4gIHJldHVybiB0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gcmVxdWlyZShcIi4vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qc1wiKTtcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChyID0gMDsgciA8IHMubGVuZ3RoOyByKyspIG8gPSBzW3JdLCB0LmluY2x1ZGVzKG8pIHx8IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHR5cGUgeyBpbmZlck9ic2VydmFibGVWYWx1ZSwgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUnO1xuaW1wb3J0IHsgZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24sIFRSUENFcnJvciB9IGZyb20gJy4vZXJyb3IvVFJQQ0Vycm9yJztcbmltcG9ydCB0eXBlIHtcbiAgQW55TWlkZGxld2FyZUZ1bmN0aW9uLFxuICBNaWRkbGV3YXJlQnVpbGRlcixcbiAgTWlkZGxld2FyZUZ1bmN0aW9uLFxuICBNaWRkbGV3YXJlUmVzdWx0LFxufSBmcm9tICcuL21pZGRsZXdhcmUnO1xuaW1wb3J0IHtcbiAgY3JlYXRlSW5wdXRNaWRkbGV3YXJlLFxuICBjcmVhdGVPdXRwdXRNaWRkbGV3YXJlLFxuICBtaWRkbGV3YXJlTWFya2VyLFxufSBmcm9tICcuL21pZGRsZXdhcmUnO1xuaW1wb3J0IHR5cGUgeyBpbmZlclBhcnNlciwgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXInO1xuaW1wb3J0IHsgZ2V0UGFyc2VGbiB9IGZyb20gJy4vcGFyc2VyJztcbmltcG9ydCB0eXBlIHtcbiAgQW55TXV0YXRpb25Qcm9jZWR1cmUsXG4gIEFueVByb2NlZHVyZSxcbiAgQW55UXVlcnlQcm9jZWR1cmUsXG4gIExlZ2FjeU9ic2VydmFibGVTdWJzY3JpcHRpb25Qcm9jZWR1cmUsXG4gIE11dGF0aW9uUHJvY2VkdXJlLFxuICBQcm9jZWR1cmVUeXBlLFxuICBRdWVyeVByb2NlZHVyZSxcbiAgU3Vic2NyaXB0aW9uUHJvY2VkdXJlLFxufSBmcm9tICcuL3Byb2NlZHVyZSc7XG5pbXBvcnQgdHlwZSB7IGluZmVyVHJhY2tlZE91dHB1dCB9IGZyb20gJy4vc3RyZWFtL3RyYWNrZWQnO1xuaW1wb3J0IHR5cGUge1xuICBHZXRSYXdJbnB1dEZuLFxuICBNYXliZVByb21pc2UsXG4gIE92ZXJ3cml0ZSxcbiAgU2ltcGxpZnksXG4gIFR5cGVFcnJvcixcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgdHlwZSB7IFVuc2V0TWFya2VyIH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBtZXJnZVdpdGhvdXRPdmVycmlkZXMgfSBmcm9tICcuL3V0aWxzJztcblxudHlwZSBJbnRlcnNlY3RJZkRlZmluZWQ8VFR5cGUsIFRXaXRoPiA9IFRUeXBlIGV4dGVuZHMgVW5zZXRNYXJrZXJcbiAgPyBUV2l0aFxuICA6IFRXaXRoIGV4dGVuZHMgVW5zZXRNYXJrZXJcbiAgICA/IFRUeXBlXG4gICAgOiBTaW1wbGlmeTxUVHlwZSAmIFRXaXRoPjtcblxudHlwZSBEZWZhdWx0VmFsdWU8VFZhbHVlLCBURmFsbGJhY2s+ID0gVFZhbHVlIGV4dGVuZHMgVW5zZXRNYXJrZXJcbiAgPyBURmFsbGJhY2tcbiAgOiBUVmFsdWU7XG5cbnR5cGUgaW5mZXJBc3luY0l0ZXJhYmxlPFRPdXRwdXQ+ID1cbiAgVE91dHB1dCBleHRlbmRzIEFzeW5jSXRlcmFibGU8aW5mZXIgJFlpZWxkLCBpbmZlciAkUmV0dXJuLCBpbmZlciAkTmV4dD5cbiAgICA/IHtcbiAgICAgICAgeWllbGQ6ICRZaWVsZDtcbiAgICAgICAgcmV0dXJuOiAkUmV0dXJuO1xuICAgICAgICBuZXh0OiAkTmV4dDtcbiAgICAgIH1cbiAgICA6IG5ldmVyO1xudHlwZSBpbmZlclN1YnNjcmlwdGlvbk91dHB1dDxUT3V0cHV0PiA9XG4gIFRPdXRwdXQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGFueT5cbiAgICA/IEFzeW5jSXRlcmFibGU8XG4gICAgICAgIGluZmVyVHJhY2tlZE91dHB1dDxpbmZlckFzeW5jSXRlcmFibGU8VE91dHB1dD5bJ3lpZWxkJ10+LFxuICAgICAgICBpbmZlckFzeW5jSXRlcmFibGU8VE91dHB1dD5bJ3JldHVybiddLFxuICAgICAgICBpbmZlckFzeW5jSXRlcmFibGU8VE91dHB1dD5bJ25leHQnXVxuICAgICAgPlxuICAgIDogVHlwZUVycm9yPCdTdWJzY3JpcHRpb24gb3V0cHV0IGNvdWxkIG5vdCBiZSBpbmZlcnJlZCc+O1xuXG5leHBvcnQgdHlwZSBDYWxsZXJPdmVycmlkZTxUQ29udGV4dD4gPSAob3B0czoge1xuICBhcmdzOiB1bmtub3duW107XG4gIGludm9rZTogKG9wdHM6IFByb2NlZHVyZUNhbGxPcHRpb25zPFRDb250ZXh0PikgPT4gUHJvbWlzZTx1bmtub3duPjtcbiAgX2RlZjogQW55UHJvY2VkdXJlWydfZGVmJ107XG59KSA9PiBQcm9taXNlPHVua25vd24+O1xudHlwZSBQcm9jZWR1cmVCdWlsZGVyRGVmPFRNZXRhPiA9IHtcbiAgcHJvY2VkdXJlOiB0cnVlO1xuICBpbnB1dHM6IFBhcnNlcltdO1xuICBvdXRwdXQ/OiBQYXJzZXI7XG4gIG1ldGE/OiBUTWV0YTtcbiAgcmVzb2x2ZXI/OiBQcm9jZWR1cmVCdWlsZGVyUmVzb2x2ZXI7XG4gIG1pZGRsZXdhcmVzOiBBbnlNaWRkbGV3YXJlRnVuY3Rpb25bXTtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgdHlwZWAgaW5zdGVhZFxuICAgKi9cbiAgbXV0YXRpb24/OiBib29sZWFuO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGB0eXBlYCBpbnN0ZWFkXG4gICAqL1xuICBxdWVyeT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHR5cGVgIGluc3RlYWRcbiAgICovXG4gIHN1YnNjcmlwdGlvbj86IGJvb2xlYW47XG4gIHR5cGU/OiBQcm9jZWR1cmVUeXBlO1xuICBjYWxsZXI/OiBDYWxsZXJPdmVycmlkZTx1bmtub3duPjtcbn07XG5cbnR5cGUgQW55UHJvY2VkdXJlQnVpbGRlckRlZiA9IFByb2NlZHVyZUJ1aWxkZXJEZWY8YW55PjtcblxuLyoqXG4gKiBQcm9jZWR1cmUgcmVzb2x2ZXIgb3B0aW9ucyAod2hhdCB0aGUgYC5xdWVyeSgpYCwgYC5tdXRhdGlvbigpYCwgYW5kIGAuc3Vic2NyaXB0aW9uKClgIGZ1bmN0aW9ucyByZWNlaXZlKVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2VkdXJlUmVzb2x2ZXJPcHRpb25zPFxuICBUQ29udGV4dCxcbiAgX1RNZXRhLFxuICBUQ29udGV4dE92ZXJyaWRlc0luLFxuICBUSW5wdXRPdXQsXG4+IHtcbiAgY3R4OiBTaW1wbGlmeTxPdmVyd3JpdGU8VENvbnRleHQsIFRDb250ZXh0T3ZlcnJpZGVzSW4+PjtcbiAgaW5wdXQ6IFRJbnB1dE91dCBleHRlbmRzIFVuc2V0TWFya2VyID8gdW5kZWZpbmVkIDogVElucHV0T3V0O1xuICAvKipcbiAgICogVGhlIEFib3J0U2lnbmFsIG9mIHRoZSByZXF1ZXN0XG4gICAqL1xuICBzaWduYWw6IEFib3J0U2lnbmFsIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgcHJvY2VkdXJlIHJlc29sdmVyXG4gKi9cbnR5cGUgUHJvY2VkdXJlUmVzb2x2ZXI8XG4gIFRDb250ZXh0LFxuICBUTWV0YSxcbiAgVENvbnRleHRPdmVycmlkZXMsXG4gIFRJbnB1dE91dCxcbiAgVE91dHB1dFBhcnNlckluLFxuICAkT3V0cHV0LFxuPiA9IChcbiAgb3B0czogUHJvY2VkdXJlUmVzb2x2ZXJPcHRpb25zPFRDb250ZXh0LCBUTWV0YSwgVENvbnRleHRPdmVycmlkZXMsIFRJbnB1dE91dD4sXG4pID0+IE1heWJlUHJvbWlzZTxcbiAgLy8gSWYgYW4gb3V0cHV0IHBhcnNlciBpcyBkZWZpbmVkLCB3ZSBuZWVkIHRvIHJldHVybiB3aGF0IHRoZSBwYXJzZXIgZXhwZWN0cywgb3RoZXJ3aXNlIHdlIHJldHVybiB0aGUgaW5mZXJyZWQgdHlwZVxuICBEZWZhdWx0VmFsdWU8VE91dHB1dFBhcnNlckluLCAkT3V0cHV0PlxuPjtcblxudHlwZSBBbnlSZXNvbHZlciA9IFByb2NlZHVyZVJlc29sdmVyPGFueSwgYW55LCBhbnksIGFueSwgYW55LCBhbnk+O1xuZXhwb3J0IHR5cGUgQW55UHJvY2VkdXJlQnVpbGRlciA9IFByb2NlZHVyZUJ1aWxkZXI8XG4gIGFueSxcbiAgYW55LFxuICBhbnksXG4gIGFueSxcbiAgYW55LFxuICBhbnksXG4gIGFueSxcbiAgYW55XG4+O1xuXG4vKipcbiAqIEluZmVyIHRoZSBjb250ZXh0IHR5cGUgZnJvbSBhIHByb2NlZHVyZSBidWlsZGVyXG4gKiBVc2VmdWwgdG8gY3JlYXRlIGNvbW1vbiBoZWxwZXIgZnVuY3Rpb25zIGZvciBkaWZmZXJlbnQgcHJvY2VkdXJlc1xuICovXG5leHBvcnQgdHlwZSBpbmZlclByb2NlZHVyZUJ1aWxkZXJSZXNvbHZlck9wdGlvbnM8XG4gIFRQcm9jZWR1cmVCdWlsZGVyIGV4dGVuZHMgQW55UHJvY2VkdXJlQnVpbGRlcixcbj4gPVxuICBUUHJvY2VkdXJlQnVpbGRlciBleHRlbmRzIFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgaW5mZXIgVENvbnRleHQsXG4gICAgaW5mZXIgVE1ldGEsXG4gICAgaW5mZXIgVENvbnRleHRPdmVycmlkZXMsXG4gICAgaW5mZXIgX1RJbnB1dEluLFxuICAgIGluZmVyIFRJbnB1dE91dCxcbiAgICBpbmZlciBfVE91dHB1dEluLFxuICAgIGluZmVyIF9UT3V0cHV0T3V0LFxuICAgIGluZmVyIF9UQ2FsbGVyXG4gID5cbiAgICA/IFByb2NlZHVyZVJlc29sdmVyT3B0aW9uczxcbiAgICAgICAgVENvbnRleHQsXG4gICAgICAgIFRNZXRhLFxuICAgICAgICBUQ29udGV4dE92ZXJyaWRlcyxcbiAgICAgICAgVElucHV0T3V0IGV4dGVuZHMgVW5zZXRNYXJrZXJcbiAgICAgICAgICA/IC8vIGlmIGlucHV0IGlzIG5vdCBzZXQsIHdlIGRvbid0IHdhbnQgdG8gaW5mZXIgaXQgYXMgYHVuZGVmaW5lZGAgc2luY2UgYSBwcm9jZWR1cmUgZnVydGhlciBkb3duIHRoZSBjaGFpbiBtaWdodCBoYXZlIHNldCBhbiBpbnB1dFxuICAgICAgICAgICAgdW5rbm93blxuICAgICAgICAgIDogVElucHV0T3V0IGV4dGVuZHMgb2JqZWN0XG4gICAgICAgICAgICA/IFNpbXBsaWZ5PFxuICAgICAgICAgICAgICAgIFRJbnB1dE91dCAmIHtcbiAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICogRXh0cmEgaW5wdXQgcGFyYW1zIG1pZ2h0IGhhdmUgYmVlbiBhZGRlZCBieSBhIGAuaW5wdXQoKWAgZnVydGhlciBkb3duIHRoZSBjaGFpblxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBba2V5QWRkZWRCeUlucHV0Q2FsbEZ1cnRoZXJEb3duOiBzdHJpbmddOiB1bmtub3duO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgOiBUSW5wdXRPdXRcbiAgICAgID5cbiAgICA6IG5ldmVyO1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb2NlZHVyZUJ1aWxkZXI8XG4gIFRDb250ZXh0LFxuICBUTWV0YSxcbiAgVENvbnRleHRPdmVycmlkZXMsXG4gIFRJbnB1dEluLFxuICBUSW5wdXRPdXQsXG4gIFRPdXRwdXRJbixcbiAgVE91dHB1dE91dCxcbiAgVENhbGxlciBleHRlbmRzIGJvb2xlYW4sXG4+IHtcbiAgLyoqXG4gICAqIEFkZCBhbiBpbnB1dCBwYXJzZXIgdG8gdGhlIHByb2NlZHVyZS5cbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3ZhbGlkYXRvcnNcbiAgICovXG4gIGlucHV0PCRQYXJzZXIgZXh0ZW5kcyBQYXJzZXI+KFxuICAgIHNjaGVtYTogVElucHV0T3V0IGV4dGVuZHMgVW5zZXRNYXJrZXJcbiAgICAgID8gJFBhcnNlclxuICAgICAgOiBpbmZlclBhcnNlcjwkUGFyc2VyPlsnb3V0J10gZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IHVuZGVmaW5lZFxuICAgICAgICA/IFRJbnB1dE91dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5kZWZpbmVkXG4gICAgICAgICAgPyB1bmRlZmluZWQgZXh0ZW5kcyBpbmZlclBhcnNlcjwkUGFyc2VyPlsnb3V0J10gLy8gaWYgY3VycmVudCBpcyBvcHRpb25hbCB0aGUgcHJldmlvdXMgbXVzdCBiZSB0b29cbiAgICAgICAgICAgID8gdW5kZWZpbmVkIGV4dGVuZHMgVElucHV0T3V0XG4gICAgICAgICAgICAgID8gJFBhcnNlclxuICAgICAgICAgICAgICA6IFR5cGVFcnJvcjwnQ2Fubm90IGNoYWluIGFuIG9wdGlvbmFsIHBhcnNlciB0byBhIHJlcXVpcmVkIHBhcnNlcic+XG4gICAgICAgICAgICA6ICRQYXJzZXJcbiAgICAgICAgICA6IFR5cGVFcnJvcjwnQWxsIGlucHV0IHBhcnNlcnMgZGlkIG5vdCByZXNvbHZlIHRvIGFuIG9iamVjdCc+XG4gICAgICAgIDogVHlwZUVycm9yPCdBbGwgaW5wdXQgcGFyc2VycyBkaWQgbm90IHJlc29sdmUgdG8gYW4gb2JqZWN0Jz4sXG4gICk6IFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgVENvbnRleHQsXG4gICAgVE1ldGEsXG4gICAgVENvbnRleHRPdmVycmlkZXMsXG4gICAgSW50ZXJzZWN0SWZEZWZpbmVkPFRJbnB1dEluLCBpbmZlclBhcnNlcjwkUGFyc2VyPlsnaW4nXT4sXG4gICAgSW50ZXJzZWN0SWZEZWZpbmVkPFRJbnB1dE91dCwgaW5mZXJQYXJzZXI8JFBhcnNlcj5bJ291dCddPixcbiAgICBUT3V0cHV0SW4sXG4gICAgVE91dHB1dE91dCxcbiAgICBUQ2FsbGVyXG4gID47XG4gIC8qKlxuICAgKiBBZGQgYW4gb3V0cHV0IHBhcnNlciB0byB0aGUgcHJvY2VkdXJlLlxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvdmFsaWRhdG9yc1xuICAgKi9cbiAgb3V0cHV0PCRQYXJzZXIgZXh0ZW5kcyBQYXJzZXI+KFxuICAgIHNjaGVtYTogJFBhcnNlcixcbiAgKTogUHJvY2VkdXJlQnVpbGRlcjxcbiAgICBUQ29udGV4dCxcbiAgICBUTWV0YSxcbiAgICBUQ29udGV4dE92ZXJyaWRlcyxcbiAgICBUSW5wdXRJbixcbiAgICBUSW5wdXRPdXQsXG4gICAgSW50ZXJzZWN0SWZEZWZpbmVkPFRPdXRwdXRJbiwgaW5mZXJQYXJzZXI8JFBhcnNlcj5bJ2luJ10+LFxuICAgIEludGVyc2VjdElmRGVmaW5lZDxUT3V0cHV0T3V0LCBpbmZlclBhcnNlcjwkUGFyc2VyPlsnb3V0J10+LFxuICAgIFRDYWxsZXJcbiAgPjtcbiAgLyoqXG4gICAqIEFkZCBhIG1ldGEgZGF0YSB0byB0aGUgcHJvY2VkdXJlLlxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvbWV0YWRhdGFcbiAgICovXG4gIG1ldGEoXG4gICAgbWV0YTogVE1ldGEsXG4gICk6IFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgVENvbnRleHQsXG4gICAgVE1ldGEsXG4gICAgVENvbnRleHRPdmVycmlkZXMsXG4gICAgVElucHV0SW4sXG4gICAgVElucHV0T3V0LFxuICAgIFRPdXRwdXRJbixcbiAgICBUT3V0cHV0T3V0LFxuICAgIFRDYWxsZXJcbiAgPjtcbiAgLyoqXG4gICAqIEFkZCBhIG1pZGRsZXdhcmUgdG8gdGhlIHByb2NlZHVyZS5cbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL21pZGRsZXdhcmVzXG4gICAqL1xuICB1c2U8JENvbnRleHRPdmVycmlkZXNPdXQ+KFxuICAgIGZuOlxuICAgICAgfCBNaWRkbGV3YXJlQnVpbGRlcjxcbiAgICAgICAgICBPdmVyd3JpdGU8VENvbnRleHQsIFRDb250ZXh0T3ZlcnJpZGVzPixcbiAgICAgICAgICBUTWV0YSxcbiAgICAgICAgICAkQ29udGV4dE92ZXJyaWRlc091dCxcbiAgICAgICAgICBUSW5wdXRPdXRcbiAgICAgICAgPlxuICAgICAgfCBNaWRkbGV3YXJlRnVuY3Rpb248XG4gICAgICAgICAgVENvbnRleHQsXG4gICAgICAgICAgVE1ldGEsXG4gICAgICAgICAgVENvbnRleHRPdmVycmlkZXMsXG4gICAgICAgICAgJENvbnRleHRPdmVycmlkZXNPdXQsXG4gICAgICAgICAgVElucHV0T3V0XG4gICAgICAgID4sXG4gICk6IFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgVENvbnRleHQsXG4gICAgVE1ldGEsXG4gICAgT3ZlcndyaXRlPFRDb250ZXh0T3ZlcnJpZGVzLCAkQ29udGV4dE92ZXJyaWRlc091dD4sXG4gICAgVElucHV0SW4sXG4gICAgVElucHV0T3V0LFxuICAgIFRPdXRwdXRJbixcbiAgICBUT3V0cHV0T3V0LFxuICAgIFRDYWxsZXJcbiAgPjtcblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBjb25jYXR9IGluc3RlYWRcbiAgICovXG4gIHVuc3RhYmxlX2NvbmNhdDxcbiAgICAkQ29udGV4dCxcbiAgICAkTWV0YSxcbiAgICAkQ29udGV4dE92ZXJyaWRlcyxcbiAgICAkSW5wdXRJbixcbiAgICAkSW5wdXRPdXQsXG4gICAgJE91dHB1dEluLFxuICAgICRPdXRwdXRPdXQsXG4gID4oXG4gICAgYnVpbGRlcjogT3ZlcndyaXRlPFRDb250ZXh0LCBUQ29udGV4dE92ZXJyaWRlcz4gZXh0ZW5kcyAkQ29udGV4dFxuICAgICAgPyBUTWV0YSBleHRlbmRzICRNZXRhXG4gICAgICAgID8gUHJvY2VkdXJlQnVpbGRlcjxcbiAgICAgICAgICAgICRDb250ZXh0LFxuICAgICAgICAgICAgJE1ldGEsXG4gICAgICAgICAgICAkQ29udGV4dE92ZXJyaWRlcyxcbiAgICAgICAgICAgICRJbnB1dEluLFxuICAgICAgICAgICAgJElucHV0T3V0LFxuICAgICAgICAgICAgJE91dHB1dEluLFxuICAgICAgICAgICAgJE91dHB1dE91dCxcbiAgICAgICAgICAgIFRDYWxsZXJcbiAgICAgICAgICA+XG4gICAgICAgIDogVHlwZUVycm9yPCdNZXRhIG1pc21hdGNoJz5cbiAgICAgIDogVHlwZUVycm9yPCdDb250ZXh0IG1pc21hdGNoJz4sXG4gICk6IFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgVENvbnRleHQsXG4gICAgVE1ldGEsXG4gICAgT3ZlcndyaXRlPFRDb250ZXh0T3ZlcnJpZGVzLCAkQ29udGV4dE92ZXJyaWRlcz4sXG4gICAgSW50ZXJzZWN0SWZEZWZpbmVkPFRJbnB1dEluLCAkSW5wdXRJbj4sXG4gICAgSW50ZXJzZWN0SWZEZWZpbmVkPFRJbnB1dE91dCwgJElucHV0T3V0PixcbiAgICBJbnRlcnNlY3RJZkRlZmluZWQ8VE91dHB1dEluLCAkT3V0cHV0SW4+LFxuICAgIEludGVyc2VjdElmRGVmaW5lZDxUT3V0cHV0T3V0LCAkT3V0cHV0T3V0PixcbiAgICBUQ2FsbGVyXG4gID47XG5cbiAgLyoqXG4gICAqIENvbWJpbmUgdHdvIHByb2NlZHVyZSBidWlsZGVyc1xuICAgKi9cbiAgY29uY2F0PFxuICAgICRDb250ZXh0LFxuICAgICRNZXRhLFxuICAgICRDb250ZXh0T3ZlcnJpZGVzLFxuICAgICRJbnB1dEluLFxuICAgICRJbnB1dE91dCxcbiAgICAkT3V0cHV0SW4sXG4gICAgJE91dHB1dE91dCxcbiAgPihcbiAgICBidWlsZGVyOiBPdmVyd3JpdGU8VENvbnRleHQsIFRDb250ZXh0T3ZlcnJpZGVzPiBleHRlbmRzICRDb250ZXh0XG4gICAgICA/IFRNZXRhIGV4dGVuZHMgJE1ldGFcbiAgICAgICAgPyBQcm9jZWR1cmVCdWlsZGVyPFxuICAgICAgICAgICAgJENvbnRleHQsXG4gICAgICAgICAgICAkTWV0YSxcbiAgICAgICAgICAgICRDb250ZXh0T3ZlcnJpZGVzLFxuICAgICAgICAgICAgJElucHV0SW4sXG4gICAgICAgICAgICAkSW5wdXRPdXQsXG4gICAgICAgICAgICAkT3V0cHV0SW4sXG4gICAgICAgICAgICAkT3V0cHV0T3V0LFxuICAgICAgICAgICAgVENhbGxlclxuICAgICAgICAgID5cbiAgICAgICAgOiBUeXBlRXJyb3I8J01ldGEgbWlzbWF0Y2gnPlxuICAgICAgOiBUeXBlRXJyb3I8J0NvbnRleHQgbWlzbWF0Y2gnPixcbiAgKTogUHJvY2VkdXJlQnVpbGRlcjxcbiAgICBUQ29udGV4dCxcbiAgICBUTWV0YSxcbiAgICBPdmVyd3JpdGU8VENvbnRleHRPdmVycmlkZXMsICRDb250ZXh0T3ZlcnJpZGVzPixcbiAgICBJbnRlcnNlY3RJZkRlZmluZWQ8VElucHV0SW4sICRJbnB1dEluPixcbiAgICBJbnRlcnNlY3RJZkRlZmluZWQ8VElucHV0T3V0LCAkSW5wdXRPdXQ+LFxuICAgIEludGVyc2VjdElmRGVmaW5lZDxUT3V0cHV0SW4sICRPdXRwdXRJbj4sXG4gICAgSW50ZXJzZWN0SWZEZWZpbmVkPFRPdXRwdXRPdXQsICRPdXRwdXRPdXQ+LFxuICAgIFRDYWxsZXJcbiAgPjtcbiAgLyoqXG4gICAqIFF1ZXJ5IHByb2NlZHVyZVxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9jb25jZXB0cyN2b2NhYnVsYXJ5XG4gICAqL1xuICBxdWVyeTwkT3V0cHV0PihcbiAgICByZXNvbHZlcjogUHJvY2VkdXJlUmVzb2x2ZXI8XG4gICAgICBUQ29udGV4dCxcbiAgICAgIFRNZXRhLFxuICAgICAgVENvbnRleHRPdmVycmlkZXMsXG4gICAgICBUSW5wdXRPdXQsXG4gICAgICBUT3V0cHV0SW4sXG4gICAgICAkT3V0cHV0XG4gICAgPixcbiAgKTogVENhbGxlciBleHRlbmRzIHRydWVcbiAgICA/IChcbiAgICAgICAgaW5wdXQ6IERlZmF1bHRWYWx1ZTxUSW5wdXRJbiwgdm9pZD4sXG4gICAgICApID0+IFByb21pc2U8RGVmYXVsdFZhbHVlPFRPdXRwdXRPdXQsICRPdXRwdXQ+PlxuICAgIDogUXVlcnlQcm9jZWR1cmU8e1xuICAgICAgICBpbnB1dDogRGVmYXVsdFZhbHVlPFRJbnB1dEluLCB2b2lkPjtcbiAgICAgICAgb3V0cHV0OiBEZWZhdWx0VmFsdWU8VE91dHB1dE91dCwgJE91dHB1dD47XG4gICAgICAgIG1ldGE6IFRNZXRhO1xuICAgICAgfT47XG5cbiAgLyoqXG4gICAqIE11dGF0aW9uIHByb2NlZHVyZVxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9jb25jZXB0cyN2b2NhYnVsYXJ5XG4gICAqL1xuICBtdXRhdGlvbjwkT3V0cHV0PihcbiAgICByZXNvbHZlcjogUHJvY2VkdXJlUmVzb2x2ZXI8XG4gICAgICBUQ29udGV4dCxcbiAgICAgIFRNZXRhLFxuICAgICAgVENvbnRleHRPdmVycmlkZXMsXG4gICAgICBUSW5wdXRPdXQsXG4gICAgICBUT3V0cHV0SW4sXG4gICAgICAkT3V0cHV0XG4gICAgPixcbiAgKTogVENhbGxlciBleHRlbmRzIHRydWVcbiAgICA/IChcbiAgICAgICAgaW5wdXQ6IERlZmF1bHRWYWx1ZTxUSW5wdXRJbiwgdm9pZD4sXG4gICAgICApID0+IFByb21pc2U8RGVmYXVsdFZhbHVlPFRPdXRwdXRPdXQsICRPdXRwdXQ+PlxuICAgIDogTXV0YXRpb25Qcm9jZWR1cmU8e1xuICAgICAgICBpbnB1dDogRGVmYXVsdFZhbHVlPFRJbnB1dEluLCB2b2lkPjtcbiAgICAgICAgb3V0cHV0OiBEZWZhdWx0VmFsdWU8VE91dHB1dE91dCwgJE91dHB1dD47XG4gICAgICAgIG1ldGE6IFRNZXRhO1xuICAgICAgfT47XG5cbiAgLyoqXG4gICAqIFN1YnNjcmlwdGlvbiBwcm9jZWR1cmVcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3N1YnNjcmlwdGlvbnNcbiAgICovXG4gIHN1YnNjcmlwdGlvbjwkT3V0cHV0IGV4dGVuZHMgQXN5bmNJdGVyYWJsZTxhbnksIHZvaWQsIGFueT4+KFxuICAgIHJlc29sdmVyOiBQcm9jZWR1cmVSZXNvbHZlcjxcbiAgICAgIFRDb250ZXh0LFxuICAgICAgVE1ldGEsXG4gICAgICBUQ29udGV4dE92ZXJyaWRlcyxcbiAgICAgIFRJbnB1dE91dCxcbiAgICAgIFRPdXRwdXRJbixcbiAgICAgICRPdXRwdXRcbiAgICA+LFxuICApOiBUQ2FsbGVyIGV4dGVuZHMgdHJ1ZVxuICAgID8gVHlwZUVycm9yPCdOb3QgaW1wbGVtZW50ZWQnPlxuICAgIDogU3Vic2NyaXB0aW9uUHJvY2VkdXJlPHtcbiAgICAgICAgaW5wdXQ6IERlZmF1bHRWYWx1ZTxUSW5wdXRJbiwgdm9pZD47XG4gICAgICAgIG91dHB1dDogaW5mZXJTdWJzY3JpcHRpb25PdXRwdXQ8RGVmYXVsdFZhbHVlPFRPdXRwdXRPdXQsICRPdXRwdXQ+PjtcbiAgICAgICAgbWV0YTogVE1ldGE7XG4gICAgICB9PjtcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzaW5nIHN1YnNjcmlwdGlvbnMgd2l0aCBhbiBvYnNlcnZhYmxlIGlzIGRlcHJlY2F0ZWQuIFVzZSBhbiBhc3luYyBnZW5lcmF0b3IgaW5zdGVhZC5cbiAgICogVGhpcyBmZWF0dXJlIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MTIgb2YgdFJQQy5cbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3N1YnNjcmlwdGlvbnNcbiAgICovXG4gIHN1YnNjcmlwdGlvbjwkT3V0cHV0IGV4dGVuZHMgT2JzZXJ2YWJsZTxhbnksIGFueT4+KFxuICAgIHJlc29sdmVyOiBQcm9jZWR1cmVSZXNvbHZlcjxcbiAgICAgIFRDb250ZXh0LFxuICAgICAgVE1ldGEsXG4gICAgICBUQ29udGV4dE92ZXJyaWRlcyxcbiAgICAgIFRJbnB1dE91dCxcbiAgICAgIFRPdXRwdXRJbixcbiAgICAgICRPdXRwdXRcbiAgICA+LFxuICApOiBUQ2FsbGVyIGV4dGVuZHMgdHJ1ZVxuICAgID8gVHlwZUVycm9yPCdOb3QgaW1wbGVtZW50ZWQnPlxuICAgIDogTGVnYWN5T2JzZXJ2YWJsZVN1YnNjcmlwdGlvblByb2NlZHVyZTx7XG4gICAgICAgIGlucHV0OiBEZWZhdWx0VmFsdWU8VElucHV0SW4sIHZvaWQ+O1xuICAgICAgICBvdXRwdXQ6IGluZmVyT2JzZXJ2YWJsZVZhbHVlPERlZmF1bHRWYWx1ZTxUT3V0cHV0T3V0LCAkT3V0cHV0Pj47XG4gICAgICAgIG1ldGE6IFRNZXRhO1xuICAgICAgfT47XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgdGhlIHdheSBhIHByb2NlZHVyZSBpcyBpbnZva2VkXG4gICAqIERvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgLSB0aGlzIGlzIGFuIGV4cGVyaW1lbnRhbCBBUElcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9jYWxsZXIoXG4gICAgY2FsbGVyOiBDYWxsZXJPdmVycmlkZTxUQ29udGV4dD4sXG4gICk6IFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgVENvbnRleHQsXG4gICAgVE1ldGEsXG4gICAgVENvbnRleHRPdmVycmlkZXMsXG4gICAgVElucHV0SW4sXG4gICAgVElucHV0T3V0LFxuICAgIFRPdXRwdXRJbixcbiAgICBUT3V0cHV0T3V0LFxuICAgIHRydWVcbiAgPjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2RlZjogUHJvY2VkdXJlQnVpbGRlckRlZjxUTWV0YT47XG59XG5cbnR5cGUgUHJvY2VkdXJlQnVpbGRlclJlc29sdmVyID0gKFxuICBvcHRzOiBQcm9jZWR1cmVSZXNvbHZlck9wdGlvbnM8YW55LCBhbnksIGFueSwgYW55PixcbikgPT4gUHJvbWlzZTx1bmtub3duPjtcblxuZnVuY3Rpb24gY3JlYXRlTmV3QnVpbGRlcihcbiAgZGVmMTogQW55UHJvY2VkdXJlQnVpbGRlckRlZixcbiAgZGVmMjogUGFydGlhbDxBbnlQcm9jZWR1cmVCdWlsZGVyRGVmPixcbik6IEFueVByb2NlZHVyZUJ1aWxkZXIge1xuICBjb25zdCB7IG1pZGRsZXdhcmVzID0gW10sIGlucHV0cywgbWV0YSwgLi4ucmVzdCB9ID0gZGVmMjtcblxuICAvLyBUT0RPOiBtYXliZSBoYXZlIGEgZm4gaGVyZSB0byB3YXJuIGFib3V0IGNhbGxzXG4gIHJldHVybiBjcmVhdGVCdWlsZGVyKHtcbiAgICAuLi5tZXJnZVdpdGhvdXRPdmVycmlkZXMoZGVmMSwgcmVzdCksXG4gICAgaW5wdXRzOiBbLi4uZGVmMS5pbnB1dHMsIC4uLihpbnB1dHMgPz8gW10pXSxcbiAgICBtaWRkbGV3YXJlczogWy4uLmRlZjEubWlkZGxld2FyZXMsIC4uLm1pZGRsZXdhcmVzXSxcbiAgICBtZXRhOiBkZWYxLm1ldGEgJiYgbWV0YSA/IHsgLi4uZGVmMS5tZXRhLCAuLi5tZXRhIH0gOiAobWV0YSA/PyBkZWYxLm1ldGEpLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJ1aWxkZXI8VENvbnRleHQsIFRNZXRhPihcbiAgaW5pdERlZjogUGFydGlhbDxBbnlQcm9jZWR1cmVCdWlsZGVyRGVmPiA9IHt9LFxuKTogUHJvY2VkdXJlQnVpbGRlcjxcbiAgVENvbnRleHQsXG4gIFRNZXRhLFxuICBvYmplY3QsXG4gIFVuc2V0TWFya2VyLFxuICBVbnNldE1hcmtlcixcbiAgVW5zZXRNYXJrZXIsXG4gIFVuc2V0TWFya2VyLFxuICBmYWxzZVxuPiB7XG4gIGNvbnN0IF9kZWY6IEFueVByb2NlZHVyZUJ1aWxkZXJEZWYgPSB7XG4gICAgcHJvY2VkdXJlOiB0cnVlLFxuICAgIGlucHV0czogW10sXG4gICAgbWlkZGxld2FyZXM6IFtdLFxuICAgIC4uLmluaXREZWYsXG4gIH07XG5cbiAgY29uc3QgYnVpbGRlcjogQW55UHJvY2VkdXJlQnVpbGRlciA9IHtcbiAgICBfZGVmLFxuICAgIGlucHV0KGlucHV0KSB7XG4gICAgICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZUZuKGlucHV0IGFzIFBhcnNlcik7XG4gICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgIGlucHV0czogW2lucHV0IGFzIFBhcnNlcl0sXG4gICAgICAgIG1pZGRsZXdhcmVzOiBbY3JlYXRlSW5wdXRNaWRkbGV3YXJlKHBhcnNlcildLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBvdXRwdXQob3V0cHV0OiBQYXJzZXIpIHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlRm4ob3V0cHV0KTtcbiAgICAgIHJldHVybiBjcmVhdGVOZXdCdWlsZGVyKF9kZWYsIHtcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBtaWRkbGV3YXJlczogW2NyZWF0ZU91dHB1dE1pZGRsZXdhcmUocGFyc2VyKV0sXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG1ldGEobWV0YSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICBtZXRhLFxuICAgICAgfSk7XG4gICAgfSxcbiAgICB1c2UobWlkZGxld2FyZUJ1aWxkZXJPckZuKSB7XG4gICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgbWlkZGxld2FyZSBidWlsZGVyIGFuZCBhIG1pZGRsZXdhcmUgZnVuY3Rpb25cbiAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID1cbiAgICAgICAgJ19taWRkbGV3YXJlcycgaW4gbWlkZGxld2FyZUJ1aWxkZXJPckZuXG4gICAgICAgICAgPyBtaWRkbGV3YXJlQnVpbGRlck9yRm4uX21pZGRsZXdhcmVzXG4gICAgICAgICAgOiBbbWlkZGxld2FyZUJ1aWxkZXJPckZuXTtcblxuICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICBtaWRkbGV3YXJlczogbWlkZGxld2FyZXMsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVuc3RhYmxlX2NvbmNhdChidWlsZGVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCAoYnVpbGRlciBhcyBBbnlQcm9jZWR1cmVCdWlsZGVyKS5fZGVmKTtcbiAgICB9LFxuICAgIGNvbmNhdChidWlsZGVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCAoYnVpbGRlciBhcyBBbnlQcm9jZWR1cmVCdWlsZGVyKS5fZGVmKTtcbiAgICB9LFxuICAgIHF1ZXJ5KHJlc29sdmVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVzb2x2ZXIoXG4gICAgICAgIHsgLi4uX2RlZiwgdHlwZTogJ3F1ZXJ5JyB9LFxuICAgICAgICByZXNvbHZlcixcbiAgICAgICkgYXMgQW55UXVlcnlQcm9jZWR1cmU7XG4gICAgfSxcbiAgICBtdXRhdGlvbihyZXNvbHZlcikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc29sdmVyKFxuICAgICAgICB7IC4uLl9kZWYsIHR5cGU6ICdtdXRhdGlvbicgfSxcbiAgICAgICAgcmVzb2x2ZXIsXG4gICAgICApIGFzIEFueU11dGF0aW9uUHJvY2VkdXJlO1xuICAgIH0sXG4gICAgc3Vic2NyaXB0aW9uKHJlc29sdmVyOiBQcm9jZWR1cmVSZXNvbHZlcjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55Pikge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc29sdmVyKHsgLi4uX2RlZiwgdHlwZTogJ3N1YnNjcmlwdGlvbicgfSwgcmVzb2x2ZXIpIGFzIGFueTtcbiAgICB9LFxuICAgIGV4cGVyaW1lbnRhbF9jYWxsZXIoY2FsbGVyKSB7XG4gICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgIGNhbGxlcixcbiAgICAgIH0pIGFzIGFueTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBidWlsZGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcihcbiAgX2RlZkluOiBBbnlQcm9jZWR1cmVCdWlsZGVyRGVmICYgeyB0eXBlOiBQcm9jZWR1cmVUeXBlIH0sXG4gIHJlc29sdmVyOiBBbnlSZXNvbHZlcixcbikge1xuICBjb25zdCBmaW5hbEJ1aWxkZXIgPSBjcmVhdGVOZXdCdWlsZGVyKF9kZWZJbiwge1xuICAgIHJlc29sdmVyLFxuICAgIG1pZGRsZXdhcmVzOiBbXG4gICAgICBhc3luYyBmdW5jdGlvbiByZXNvbHZlTWlkZGxld2FyZShvcHRzKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNvbHZlcihvcHRzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtYXJrZXI6IG1pZGRsZXdhcmVNYXJrZXIsXG4gICAgICAgICAgb2s6IHRydWUsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjdHg6IG9wdHMuY3R4LFxuICAgICAgICB9IGFzIGNvbnN0O1xuICAgICAgfSxcbiAgICBdLFxuICB9KTtcbiAgY29uc3QgX2RlZjogQW55UHJvY2VkdXJlWydfZGVmJ10gPSB7XG4gICAgLi4uZmluYWxCdWlsZGVyLl9kZWYsXG4gICAgdHlwZTogX2RlZkluLnR5cGUsXG4gICAgZXhwZXJpbWVudGFsX2NhbGxlcjogQm9vbGVhbihmaW5hbEJ1aWxkZXIuX2RlZi5jYWxsZXIpLFxuICAgIG1ldGE6IGZpbmFsQnVpbGRlci5fZGVmLm1ldGEsXG4gICAgJHR5cGVzOiBudWxsIGFzIGFueSxcbiAgfTtcblxuICBjb25zdCBpbnZva2UgPSBjcmVhdGVQcm9jZWR1cmVDYWxsZXIoZmluYWxCdWlsZGVyLl9kZWYpO1xuICBjb25zdCBjYWxsZXJPdmVycmlkZSA9IGZpbmFsQnVpbGRlci5fZGVmLmNhbGxlcjtcbiAgaWYgKCFjYWxsZXJPdmVycmlkZSkge1xuICAgIHJldHVybiBpbnZva2U7XG4gIH1cbiAgY29uc3QgY2FsbGVyV3JhcHBlciA9IGFzeW5jICguLi5hcmdzOiB1bmtub3duW10pID0+IHtcbiAgICByZXR1cm4gYXdhaXQgY2FsbGVyT3ZlcnJpZGUoe1xuICAgICAgYXJncyxcbiAgICAgIGludm9rZSxcbiAgICAgIF9kZWY6IF9kZWYsXG4gICAgfSk7XG4gIH07XG5cbiAgY2FsbGVyV3JhcHBlci5fZGVmID0gX2RlZjtcblxuICByZXR1cm4gY2FsbGVyV3JhcHBlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcm9jZWR1cmVDYWxsT3B0aW9uczxUQ29udGV4dD4ge1xuICBjdHg6IFRDb250ZXh0O1xuICBnZXRSYXdJbnB1dDogR2V0UmF3SW5wdXRGbjtcbiAgaW5wdXQ/OiB1bmtub3duO1xuICBwYXRoOiBzdHJpbmc7XG4gIHR5cGU6IFByb2NlZHVyZVR5cGU7XG4gIHNpZ25hbDogQWJvcnRTaWduYWwgfCB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IGNvZGVibG9jayA9IGBcblRoaXMgaXMgYSBjbGllbnQtb25seSBmdW5jdGlvbi5cbklmIHlvdSB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiBvbiB0aGUgc2VydmVyLCBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9zZXJ2ZXItc2lkZS1jYWxsc1xuYC50cmltKCk7XG5cbi8vIHJ1biB0aGUgbWlkZGxld2FyZXMgcmVjdXJzaXZlbHkgd2l0aCB0aGUgcmVzb2x2ZXIgYXMgdGhlIGxhc3Qgb25lXG5hc3luYyBmdW5jdGlvbiBjYWxsUmVjdXJzaXZlKFxuICBpbmRleDogbnVtYmVyLFxuICBfZGVmOiBBbnlQcm9jZWR1cmVCdWlsZGVyRGVmLFxuICBvcHRzOiBQcm9jZWR1cmVDYWxsT3B0aW9uczxhbnk+LFxuKTogUHJvbWlzZTxNaWRkbGV3YXJlUmVzdWx0PGFueT4+IHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IG1pZGRsZXdhcmUgPSBfZGVmLm1pZGRsZXdhcmVzW2luZGV4XSE7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWlkZGxld2FyZSh7XG4gICAgICAuLi5vcHRzLFxuICAgICAgbWV0YTogX2RlZi5tZXRhLFxuICAgICAgaW5wdXQ6IG9wdHMuaW5wdXQsXG4gICAgICBuZXh0KF9uZXh0T3B0cz86IGFueSkge1xuICAgICAgICBjb25zdCBuZXh0T3B0cyA9IF9uZXh0T3B0cyBhc1xuICAgICAgICAgIHwge1xuICAgICAgICAgICAgICBjdHg/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAgICAgICAgICAgaW5wdXQ/OiB1bmtub3duO1xuICAgICAgICAgICAgICBnZXRSYXdJbnB1dD86IEdldFJhd0lucHV0Rm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxSZWN1cnNpdmUoaW5kZXggKyAxLCBfZGVmLCB7XG4gICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICBjdHg6IG5leHRPcHRzPy5jdHggPyB7IC4uLm9wdHMuY3R4LCAuLi5uZXh0T3B0cy5jdHggfSA6IG9wdHMuY3R4LFxuICAgICAgICAgIGlucHV0OiBuZXh0T3B0cyAmJiAnaW5wdXQnIGluIG5leHRPcHRzID8gbmV4dE9wdHMuaW5wdXQgOiBvcHRzLmlucHV0LFxuICAgICAgICAgIGdldFJhd0lucHV0OiBuZXh0T3B0cz8uZ2V0UmF3SW5wdXQgPz8gb3B0cy5nZXRSYXdJbnB1dCxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb2s6IGZhbHNlLFxuICAgICAgZXJyb3I6IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSxcbiAgICAgIG1hcmtlcjogbWlkZGxld2FyZU1hcmtlcixcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb2NlZHVyZUNhbGxlcihfZGVmOiBBbnlQcm9jZWR1cmVCdWlsZGVyRGVmKTogQW55UHJvY2VkdXJlIHtcbiAgYXN5bmMgZnVuY3Rpb24gcHJvY2VkdXJlKG9wdHM6IFByb2NlZHVyZUNhbGxPcHRpb25zPHVua25vd24+KSB7XG4gICAgLy8gaXMgZGlyZWN0IHNlcnZlci1zaWRlIGNhbGxcbiAgICBpZiAoIW9wdHMgfHwgISgnZ2V0UmF3SW5wdXQnIGluIG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoY29kZWJsb2NrKTtcbiAgICB9XG5cbiAgICAvLyB0aGVyZSdzIGFsd2F5cyBhdCBsZWFzdCBvbmUgXCJuZXh0XCIgc2luY2Ugd2Ugd3JhcCB0aGlzLnJlc29sdmVyIGluIGEgbWlkZGxld2FyZVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxSZWN1cnNpdmUoMCwgX2RlZiwgb3B0cyk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdObyByZXN1bHQgZnJvbSBtaWRkbGV3YXJlcyAtIGRpZCB5b3UgZm9yZ2V0IHRvIGByZXR1cm4gbmV4dCgpYD8nLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAvLyByZS10aHJvdyBvcmlnaW5hbCBlcnJvclxuICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gIH1cblxuICBwcm9jZWR1cmUuX2RlZiA9IF9kZWY7XG4gIHByb2NlZHVyZS5wcm9jZWR1cmUgPSB0cnVlO1xuICBwcm9jZWR1cmUubWV0YSA9IF9kZWYubWV0YTtcblxuICAvLyBGSVhNRSB0eXBlY2FzdCBzaG91bGRuJ3QgYmUgbmVlZGVkIC0gZml4aXR0dFxuICByZXR1cm4gcHJvY2VkdXJlIGFzIHVua25vd24gYXMgQW55UHJvY2VkdXJlO1xufVxuIiwiaW1wb3J0IHR5cGUgeyBDb21iaW5lZERhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4uL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydCc7XG5pbXBvcnQgdHlwZSB7IERlZmF1bHRFcnJvclNoYXBlLCBFcnJvckZvcm1hdHRlciB9IGZyb20gJy4vZXJyb3IvZm9ybWF0dGVyJztcbmltcG9ydCB0eXBlIHsgSlNPTkxQcm9kdWNlck9wdGlvbnMgfSBmcm9tICcuL3N0cmVhbS9qc29ubCc7XG5pbXBvcnQgdHlwZSB7IFNTRVN0cmVhbVByb2R1Y2VyT3B0aW9ucyB9IGZyb20gJy4vc3RyZWFtL3NzZSc7XG5cbi8qKlxuICogVGhlIGluaXRpYWwgZ2VuZXJpY3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgaW5pdCBmdW5jdGlvblxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm9vdFR5cGVzIHtcbiAgY3R4OiBvYmplY3Q7XG4gIG1ldGE6IG9iamVjdDtcbiAgZXJyb3JTaGFwZTogRGVmYXVsdEVycm9yU2hhcGU7XG4gIHRyYW5zZm9ybWVyOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGNoZWNrIHRvIHNlZSBpZiB3ZSdyZSBpbiBhIHNlcnZlclxuICovXG5leHBvcnQgY29uc3QgaXNTZXJ2ZXJEZWZhdWx0OiBib29sZWFuID1cbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgJ0Rlbm8nIGluIHdpbmRvdyB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2RvdC1ub3RhdGlvblxuICBnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uWydOT0RFX0VOViddID09PSAndGVzdCcgfHxcbiAgISFnbG9iYWxUaGlzLnByb2Nlc3M/LmVudj8uWydKRVNUX1dPUktFUl9JRCddIHx8XG4gICEhZ2xvYmFsVGhpcy5wcm9jZXNzPy5lbnY/LlsnVklURVNUX1dPUktFUl9JRCddO1xuXG4vKipcbiAqIFRoZSB0UlBDIHJvb3QgY29uZmlnXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb290Q29uZmlnPFRUeXBlcyBleHRlbmRzIFJvb3RUeXBlcz4ge1xuICAvKipcbiAgICogVGhlIHR5cGVzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGNvbmZpZ1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gICR0eXBlczogVFR5cGVzO1xuICAvKipcbiAgICogVXNlIGEgZGF0YSB0cmFuc2Zvcm1lclxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9kYXRhLXRyYW5zZm9ybWVyc1xuICAgKi9cbiAgdHJhbnNmb3JtZXI6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyO1xuICAvKipcbiAgICogVXNlIGN1c3RvbSBlcnJvciBmb3JtYXR0aW5nXG4gICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL2Vycm9yLWZvcm1hdHRpbmdcbiAgICovXG4gIGVycm9yRm9ybWF0dGVyOiBFcnJvckZvcm1hdHRlcjxUVHlwZXNbJ2N0eCddLCBUVHlwZXNbJ2Vycm9yU2hhcGUnXT47XG4gIC8qKlxuICAgKiBBbGxvdyBgQHRycGMvc2VydmVyYCB0byBydW4gaW4gbm9uLXNlcnZlciBlbnZpcm9ubWVudHNcbiAgICogQHdhcm5pbmcgKipVc2Ugd2l0aCBjYXV0aW9uKiosIHRoaXMgc2hvdWxkIGxpa2VseSBtYWlubHkgYmUgdXNlZCB3aXRoaW4gdGVzdGluZy5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGFsbG93T3V0c2lkZU9mU2VydmVyOiBib29sZWFuO1xuICAvKipcbiAgICogSXMgdGhpcyBhIHNlcnZlciBlbnZpcm9ubWVudD9cbiAgICogQHdhcm5pbmcgKipVc2Ugd2l0aCBjYXV0aW9uKiosIHRoaXMgc2hvdWxkIGxpa2VseSBtYWlubHkgYmUgdXNlZCB3aXRoaW4gdGVzdGluZy5cbiAgICogQGRlZmF1bHQgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgJ0Rlbm8nIGluIHdpbmRvdyB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnXG4gICAqL1xuICBpc1NlcnZlcjogYm9vbGVhbjtcbiAgLyoqXG4gICAqIElzIHRoaXMgZGV2ZWxvcG1lbnQ/XG4gICAqIFdpbGwgYmUgdXNlZCB0byBkZWNpZGUgaWYgdGhlIEFQSSBzaG91bGQgcmV0dXJuIHN0YWNrIHRyYWNlc1xuICAgKiBAZGVmYXVsdCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAqL1xuICBpc0RldjogYm9vbGVhbjtcblxuICBkZWZhdWx0TWV0YT86IFRUeXBlc1snbWV0YSddIGV4dGVuZHMgb2JqZWN0ID8gVFR5cGVzWydtZXRhJ10gOiBuZXZlcjtcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3Igc2VydmVyLXNlbnQgZXZlbnRzIChTU0UpIHN1YnNjcmlwdGlvbnNcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9jbGllbnQvbGlua3MvaHR0cFN1YnNjcmlwdGlvbkxpbmtcbiAgICovXG4gIHNzZT86IHtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgc2VydmVyLXNlbnQgZXZlbnRzIChTU0UpIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgZW5hYmxlZD86IGJvb2xlYW47XG4gIH0gJiBQaWNrPFxuICAgIFNTRVN0cmVhbVByb2R1Y2VyT3B0aW9ucyxcbiAgICAncGluZycgfCAnZW1pdEFuZEVuZEltbWVkaWF0ZWx5JyB8ICdtYXhEdXJhdGlvbk1zJyB8ICdjbGllbnQnXG4gID47XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgZm9yIGJhdGNoIHN0cmVhbVxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL2NsaWVudC9saW5rcy9odHRwQmF0Y2hTdHJlYW1MaW5rXG4gICAqL1xuICBqc29ubD86IFBpY2s8SlNPTkxQcm9kdWNlck9wdGlvbnMsICdwaW5nTXMnPjtcbiAgZXhwZXJpbWVudGFsPzoge307XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIENyZWF0ZVJvb3RUeXBlczxUR2VuZXJpY3MgZXh0ZW5kcyBSb290VHlwZXM+ID0gVEdlbmVyaWNzO1xuXG5leHBvcnQgdHlwZSBBbnlSb290VHlwZXMgPSBDcmVhdGVSb290VHlwZXM8e1xuICBjdHg6IGFueTtcbiAgbWV0YTogYW55O1xuICBlcnJvclNoYXBlOiBhbnk7XG4gIHRyYW5zZm9ybWVyOiBhbnk7XG59PjtcblxudHlwZSBQYXJ0aWFsSWY8VENvbmRpdGlvbiBleHRlbmRzIGJvb2xlYW4sIFRUeXBlPiA9IFRDb25kaXRpb24gZXh0ZW5kcyB0cnVlXG4gID8gUGFydGlhbDxUVHlwZT5cbiAgOiBUVHlwZTtcblxuLyoqXG4gKiBBZGRzIGEgYGNyZWF0ZUNvbnRleHRgIG9wdGlvbiB3aXRoIGEgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb25cbiAqIElmIGNvbnRleHQgaXMgdGhlIGRlZmF1bHQgdmFsdWUsIHRoZW4gdGhlIGBjcmVhdGVDb250ZXh0YCBvcHRpb24gaXMgb3B0aW9uYWxcbiAqL1xuZXhwb3J0IHR5cGUgQ3JlYXRlQ29udGV4dENhbGxiYWNrPFxuICBUQ29udGV4dCxcbiAgVEZ1bmN0aW9uIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksXG4+ID0gUGFydGlhbElmPFxuICBvYmplY3QgZXh0ZW5kcyBUQ29udGV4dCA/IHRydWUgOiBmYWxzZSxcbiAge1xuICAgIC8qKlxuICAgICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL2NvbnRleHRcbiAgICAgKiovXG4gICAgY3JlYXRlQ29udGV4dDogVEZ1bmN0aW9uO1xuICB9XG4+O1xuIiwiaW1wb3J0IHtcbiAgZGVmYXVsdEZvcm1hdHRlcixcbiAgdHlwZSBEZWZhdWx0RXJyb3JTaGFwZSxcbiAgdHlwZSBFcnJvckZvcm1hdHRlcixcbn0gZnJvbSAnLi9lcnJvci9mb3JtYXR0ZXInO1xuaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlQnVpbGRlciwgTWlkZGxld2FyZUZ1bmN0aW9uIH0gZnJvbSAnLi9taWRkbGV3YXJlJztcbmltcG9ydCB7IGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5IH0gZnJvbSAnLi9taWRkbGV3YXJlJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlQnVpbGRlciB9IGZyb20gJy4vcHJvY2VkdXJlQnVpbGRlcic7XG5pbXBvcnQgeyBjcmVhdGVCdWlsZGVyIH0gZnJvbSAnLi9wcm9jZWR1cmVCdWlsZGVyJztcbmltcG9ydCB0eXBlIHsgQW55Um9vdFR5cGVzLCBDcmVhdGVSb290VHlwZXMgfSBmcm9tICcuL3Jvb3RDb25maWcnO1xuaW1wb3J0IHsgaXNTZXJ2ZXJEZWZhdWx0LCB0eXBlIFJvb3RDb25maWcgfSBmcm9tICcuL3Jvb3RDb25maWcnO1xuaW1wb3J0IHR5cGUge1xuICBBbnlSb3V0ZXIsXG4gIE1lcmdlUm91dGVycyxcbiAgUm91dGVyQnVpbGRlcixcbiAgUm91dGVyQ2FsbGVyRmFjdG9yeSxcbn0gZnJvbSAnLi9yb3V0ZXInO1xuaW1wb3J0IHtcbiAgY3JlYXRlQ2FsbGVyRmFjdG9yeSxcbiAgY3JlYXRlUm91dGVyRmFjdG9yeSxcbiAgbWVyZ2VSb3V0ZXJzLFxufSBmcm9tICcuL3JvdXRlcic7XG5pbXBvcnQgdHlwZSB7IERhdGFUcmFuc2Zvcm1lck9wdGlvbnMgfSBmcm9tICcuL3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IGRlZmF1bHRUcmFuc2Zvcm1lciwgZ2V0RGF0YVRyYW5zZm9ybWVyIH0gZnJvbSAnLi90cmFuc2Zvcm1lcic7XG5pbXBvcnQgdHlwZSB7IFVud3JhcCwgVmFsaWRhdGVTaGFwZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHR5cGUgeyBVbnNldE1hcmtlciB9IGZyb20gJy4vdXRpbHMnO1xuXG50eXBlIGluZmVyRXJyb3JGb3JtYXR0ZXJTaGFwZTxUVHlwZT4gPVxuICBUVHlwZSBleHRlbmRzIEVycm9yRm9ybWF0dGVyPGFueSwgaW5mZXIgVFNoYXBlPiA/IFRTaGFwZSA6IERlZmF1bHRFcnJvclNoYXBlO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGludGVyZmFjZSBSdW50aW1lQ29uZmlnT3B0aW9uczxcbiAgVENvbnRleHQgZXh0ZW5kcyBvYmplY3QsXG4gIFRNZXRhIGV4dGVuZHMgb2JqZWN0LFxuPiBleHRlbmRzIFBhcnRpYWw8XG4gICAgT21pdDxcbiAgICAgIFJvb3RDb25maWc8e1xuICAgICAgICBjdHg6IFRDb250ZXh0O1xuICAgICAgICBtZXRhOiBUTWV0YTtcbiAgICAgICAgZXJyb3JTaGFwZTogYW55O1xuICAgICAgICB0cmFuc2Zvcm1lcjogYW55O1xuICAgICAgfT4sXG4gICAgICAnJHR5cGVzJyB8ICd0cmFuc2Zvcm1lcidcbiAgICA+XG4gID4ge1xuICAvKipcbiAgICogVXNlIGEgZGF0YSB0cmFuc2Zvcm1lclxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9kYXRhLXRyYW5zZm9ybWVyc1xuICAgKi9cbiAgdHJhbnNmb3JtZXI/OiBEYXRhVHJhbnNmb3JtZXJPcHRpb25zO1xufVxuXG50eXBlIENvbnRleHRDYWxsYmFjayA9ICguLi5hcmdzOiBhbnlbXSkgPT4gb2JqZWN0IHwgUHJvbWlzZTxvYmplY3Q+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRSUENSb290T2JqZWN0PFxuICBUQ29udGV4dCBleHRlbmRzIG9iamVjdCxcbiAgVE1ldGEgZXh0ZW5kcyBvYmplY3QsXG4gIFRPcHRpb25zIGV4dGVuZHMgUnVudGltZUNvbmZpZ09wdGlvbnM8VENvbnRleHQsIFRNZXRhPixcbiAgJFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXMgPSB7XG4gICAgY3R4OiBUQ29udGV4dDtcbiAgICBtZXRhOiBUTWV0YTtcbiAgICBlcnJvclNoYXBlOiB1bmRlZmluZWQgZXh0ZW5kcyBUT3B0aW9uc1snZXJyb3JGb3JtYXR0ZXInXVxuICAgICAgPyBEZWZhdWx0RXJyb3JTaGFwZVxuICAgICAgOiBpbmZlckVycm9yRm9ybWF0dGVyU2hhcGU8VE9wdGlvbnNbJ2Vycm9yRm9ybWF0dGVyJ10+O1xuICAgIHRyYW5zZm9ybWVyOiB1bmRlZmluZWQgZXh0ZW5kcyBUT3B0aW9uc1sndHJhbnNmb3JtZXInXSA/IGZhbHNlIDogdHJ1ZTtcbiAgfSxcbj4ge1xuICAvKipcbiAgICogWW91ciByb3V0ZXIgY29uZmlnXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NvbmZpZzogUm9vdENvbmZpZzwkUm9vdD47XG5cbiAgLyoqXG4gICAqIEJ1aWxkZXIgb2JqZWN0IGZvciBjcmVhdGluZyBwcm9jZWR1cmVzXG4gICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9wcm9jZWR1cmVzXG4gICAqL1xuICBwcm9jZWR1cmU6IFByb2NlZHVyZUJ1aWxkZXI8XG4gICAgVENvbnRleHQsXG4gICAgVE1ldGEsXG4gICAgb2JqZWN0LFxuICAgIFVuc2V0TWFya2VyLFxuICAgIFVuc2V0TWFya2VyLFxuICAgIFVuc2V0TWFya2VyLFxuICAgIFVuc2V0TWFya2VyLFxuICAgIGZhbHNlXG4gID47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSByZXVzYWJsZSBtaWRkbGV3YXJlc1xuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvbWlkZGxld2FyZXNcbiAgICovXG4gIG1pZGRsZXdhcmU6IDwkQ29udGV4dE92ZXJyaWRlcz4oXG4gICAgZm46IE1pZGRsZXdhcmVGdW5jdGlvbjxUQ29udGV4dCwgVE1ldGEsIG9iamVjdCwgJENvbnRleHRPdmVycmlkZXMsIHVua25vd24+LFxuICApID0+IE1pZGRsZXdhcmVCdWlsZGVyPFRDb250ZXh0LCBUTWV0YSwgJENvbnRleHRPdmVycmlkZXMsIHVua25vd24+O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSByb3V0ZXJcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3JvdXRlcnNcbiAgICovXG4gIHJvdXRlcjogUm91dGVyQnVpbGRlcjwkUm9vdD47XG5cbiAgLyoqXG4gICAqIE1lcmdlIFJvdXRlcnNcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL21lcmdpbmctcm91dGVyc1xuICAgKi9cbiAgbWVyZ2VSb3V0ZXJzOiA8VFJvdXRlcnMgZXh0ZW5kcyBBbnlSb3V0ZXJbXT4oXG4gICAgLi4ucm91dGVyTGlzdDogWy4uLlRSb3V0ZXJzXVxuICApID0+IE1lcmdlUm91dGVyczxUUm91dGVycz47XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlcnZlci1zaWRlIGNhbGxlciBmb3IgYSByb3V0ZXJcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3NlcnZlci1zaWRlLWNhbGxzXG4gICAqL1xuICBjcmVhdGVDYWxsZXJGYWN0b3J5OiBSb3V0ZXJDYWxsZXJGYWN0b3J5PCRSb290Pjtcbn1cblxuY2xhc3MgVFJQQ0J1aWxkZXI8VENvbnRleHQgZXh0ZW5kcyBvYmplY3QsIFRNZXRhIGV4dGVuZHMgb2JqZWN0PiB7XG4gIC8qKlxuICAgKiBBZGQgYSBjb250ZXh0IHNoYXBlIGFzIGEgZ2VuZXJpYyB0byB0aGUgcm9vdCBvYmplY3RcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL2NvbnRleHRcbiAgICovXG4gIGNvbnRleHQ8VE5ld0NvbnRleHQgZXh0ZW5kcyBvYmplY3QgfCBDb250ZXh0Q2FsbGJhY2s+KCkge1xuICAgIHJldHVybiBuZXcgVFJQQ0J1aWxkZXI8XG4gICAgICBUTmV3Q29udGV4dCBleHRlbmRzIENvbnRleHRDYWxsYmFjayA/IFVud3JhcDxUTmV3Q29udGV4dD4gOiBUTmV3Q29udGV4dCxcbiAgICAgIFRNZXRhXG4gICAgPigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1ldGEgc2hhcGUgYXMgYSBnZW5lcmljIHRvIHRoZSByb290IG9iamVjdFxuICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9xdWlja3N0YXJ0XG4gICAqL1xuICBtZXRhPFROZXdNZXRhIGV4dGVuZHMgb2JqZWN0PigpIHtcbiAgICByZXR1cm4gbmV3IFRSUENCdWlsZGVyPFRDb250ZXh0LCBUTmV3TWV0YT4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHJvb3Qgb2JqZWN0XG4gICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9yb3V0ZXJzI2luaXRpYWxpemUtdHJwY1xuICAgKi9cbiAgY3JlYXRlPFRPcHRpb25zIGV4dGVuZHMgUnVudGltZUNvbmZpZ09wdGlvbnM8VENvbnRleHQsIFRNZXRhPj4oXG4gICAgb3B0cz86IFZhbGlkYXRlU2hhcGU8VE9wdGlvbnMsIFJ1bnRpbWVDb25maWdPcHRpb25zPFRDb250ZXh0LCBUTWV0YT4+LFxuICApOiBUUlBDUm9vdE9iamVjdDxUQ29udGV4dCwgVE1ldGEsIFRPcHRpb25zPiB7XG4gICAgdHlwZSAkUm9vdCA9IENyZWF0ZVJvb3RUeXBlczx7XG4gICAgICBjdHg6IFRDb250ZXh0O1xuICAgICAgbWV0YTogVE1ldGE7XG4gICAgICBlcnJvclNoYXBlOiB1bmRlZmluZWQgZXh0ZW5kcyBUT3B0aW9uc1snZXJyb3JGb3JtYXR0ZXInXVxuICAgICAgICA/IERlZmF1bHRFcnJvclNoYXBlXG4gICAgICAgIDogaW5mZXJFcnJvckZvcm1hdHRlclNoYXBlPFRPcHRpb25zWydlcnJvckZvcm1hdHRlciddPjtcbiAgICAgIHRyYW5zZm9ybWVyOiB1bmRlZmluZWQgZXh0ZW5kcyBUT3B0aW9uc1sndHJhbnNmb3JtZXInXSA/IGZhbHNlIDogdHJ1ZTtcbiAgICB9PjtcblxuICAgIGNvbnN0IGNvbmZpZzogUm9vdENvbmZpZzwkUm9vdD4gPSB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgdHJhbnNmb3JtZXI6IGdldERhdGFUcmFuc2Zvcm1lcihvcHRzPy50cmFuc2Zvcm1lciA/PyBkZWZhdWx0VHJhbnNmb3JtZXIpLFxuICAgICAgaXNEZXY6XG4gICAgICAgIG9wdHM/LmlzRGV2ID8/XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZG90LW5vdGF0aW9uXG4gICAgICAgIGdsb2JhbFRoaXMucHJvY2Vzcz8uZW52WydOT0RFX0VOViddICE9PSAncHJvZHVjdGlvbicsXG4gICAgICBhbGxvd091dHNpZGVPZlNlcnZlcjogb3B0cz8uYWxsb3dPdXRzaWRlT2ZTZXJ2ZXIgPz8gZmFsc2UsXG4gICAgICBlcnJvckZvcm1hdHRlcjogb3B0cz8uZXJyb3JGb3JtYXR0ZXIgPz8gZGVmYXVsdEZvcm1hdHRlcixcbiAgICAgIGlzU2VydmVyOiBvcHRzPy5pc1NlcnZlciA/PyBpc1NlcnZlckRlZmF1bHQsXG4gICAgICAvKipcbiAgICAgICAqIFRoZXNlIGFyZSBqdXN0IHR5cGVzLCB0aGV5IGNhbid0IGJlIHVzZWQgYXQgcnVudGltZVxuICAgICAgICogQGludGVybmFsXG4gICAgICAgKi9cbiAgICAgICR0eXBlczogbnVsbCBhcyBhbnksXG4gICAgfTtcblxuICAgIHtcbiAgICAgIC8vIFNlcnZlciBjaGVja1xuICAgICAgY29uc3QgaXNTZXJ2ZXI6IGJvb2xlYW4gPSBvcHRzPy5pc1NlcnZlciA/PyBpc1NlcnZlckRlZmF1bHQ7XG5cbiAgICAgIGlmICghaXNTZXJ2ZXIgJiYgb3B0cz8uYWxsb3dPdXRzaWRlT2ZTZXJ2ZXIgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UncmUgdHJ5aW5nIHRvIHVzZSBAdHJwYy9zZXJ2ZXIgaW4gYSBub24tc2VydmVyIGVudmlyb25tZW50LiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYnkgZGVmYXVsdC5gLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBZb3VyIHJvdXRlciBjb25maWdcbiAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICovXG4gICAgICBfY29uZmlnOiBjb25maWcsXG4gICAgICAvKipcbiAgICAgICAqIEJ1aWxkZXIgb2JqZWN0IGZvciBjcmVhdGluZyBwcm9jZWR1cmVzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvcHJvY2VkdXJlc1xuICAgICAgICovXG4gICAgICBwcm9jZWR1cmU6IGNyZWF0ZUJ1aWxkZXI8JFJvb3RbJ2N0eCddLCAkUm9vdFsnbWV0YSddPih7XG4gICAgICAgIG1ldGE6IG9wdHM/LmRlZmF1bHRNZXRhLFxuICAgICAgfSksXG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZSByZXVzYWJsZSBtaWRkbGV3YXJlc1xuICAgICAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL21pZGRsZXdhcmVzXG4gICAgICAgKi9cbiAgICAgIG1pZGRsZXdhcmU6IGNyZWF0ZU1pZGRsZXdhcmVGYWN0b3J5PCRSb290WydjdHgnXSwgJFJvb3RbJ21ldGEnXT4oKSxcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlIGEgcm91dGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvcm91dGVyc1xuICAgICAgICovXG4gICAgICByb3V0ZXI6IGNyZWF0ZVJvdXRlckZhY3Rvcnk8JFJvb3Q+KGNvbmZpZyksXG4gICAgICAvKipcbiAgICAgICAqIE1lcmdlIFJvdXRlcnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90cnBjLmlvL2RvY3MvdjExL3NlcnZlci9tZXJnaW5nLXJvdXRlcnNcbiAgICAgICAqL1xuICAgICAgbWVyZ2VSb3V0ZXJzLFxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGUgYSBzZXJ2ZXItc2lkZSBjYWxsZXIgZm9yIGEgcm91dGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9zZXJ2ZXIvc2VydmVyLXNpZGUtY2FsbHNcbiAgICAgICAqL1xuICAgICAgY3JlYXRlQ2FsbGVyRmFjdG9yeTogY3JlYXRlQ2FsbGVyRmFjdG9yeTwkUm9vdD4oKSxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQnVpbGRlciB0byBpbml0aWFsaXplIHRoZSB0UlBDIHJvb3Qgb2JqZWN0IC0gdXNlIHRoaXMgZXhhY3RseSBvbmNlIHBlciBiYWNrZW5kXG4gKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3YxMS9xdWlja3N0YXJ0XG4gKi9cbmV4cG9ydCBjb25zdCBpbml0VFJQQyA9IG5ldyBUUlBDQnVpbGRlcigpO1xuZXhwb3J0IHR5cGUgeyBUUlBDQnVpbGRlciB9O1xuIl0sIm5hbWVzIjpbIm1pZGRsZXdhcmVzOiBBbnlNaWRkbGV3YXJlRnVuY3Rpb25bXSIsImZuOiBNaWRkbGV3YXJlRnVuY3Rpb248XG4gICAgICBUQ29udGV4dCxcbiAgICAgIFRNZXRhLFxuICAgICAgb2JqZWN0LFxuICAgICAgJENvbnRleHRPdmVycmlkZXMsXG4gICAgICBUSW5wdXRPdXRcbiAgICA+IiwicGFyc2U6IFBhcnNlRm48VElucHV0PiIsImlucHV0TWlkZGxld2FyZTogQW55TWlkZGxld2FyZUZ1bmN0aW9uIiwicGFyc2VkSW5wdXQ6IFJldHVyblR5cGU8dHlwZW9mIHBhcnNlPiIsInBhcnNlOiBQYXJzZUZuPFRPdXRwdXQ+Iiwib3V0cHV0TWlkZGxld2FyZTogQW55TWlkZGxld2FyZUZ1bmN0aW9uIiwiaXNzdWVzOiBSZWFkb25seUFycmF5PFN0YW5kYXJkU2NoZW1hVjEuSXNzdWU+IiwicHJvY2VkdXJlUGFyc2VyOiBQYXJzZXIiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJkZWYxOiBBbnlQcm9jZWR1cmVCdWlsZGVyRGVmIiwiZGVmMjogUGFydGlhbDxBbnlQcm9jZWR1cmVCdWlsZGVyRGVmPiIsImluaXREZWY6IFBhcnRpYWw8QW55UHJvY2VkdXJlQnVpbGRlckRlZj4iLCJfZGVmOiBBbnlQcm9jZWR1cmVCdWlsZGVyRGVmIiwiYnVpbGRlcjogQW55UHJvY2VkdXJlQnVpbGRlciIsIm91dHB1dDogUGFyc2VyIiwiYnVpbGRlciIsInJlc29sdmVyOiBQcm9jZWR1cmVSZXNvbHZlcjxhbnksIGFueSwgYW55LCBhbnksIGFueSwgYW55PiIsIl9kZWZJbjogQW55UHJvY2VkdXJlQnVpbGRlckRlZiAmIHsgdHlwZTogUHJvY2VkdXJlVHlwZSB9IiwicmVzb2x2ZXI6IEFueVJlc29sdmVyIiwiX2RlZjogQW55UHJvY2VkdXJlWydfZGVmJ10iLCJpbmRleDogbnVtYmVyIiwib3B0czogUHJvY2VkdXJlQ2FsbE9wdGlvbnM8YW55PiIsIl9uZXh0T3B0cz86IGFueSIsIm9wdHM6IFByb2NlZHVyZUNhbGxPcHRpb25zPHVua25vd24+IiwiaXNTZXJ2ZXJEZWZhdWx0OiBib29sZWFuIiwib3B0cz86IFZhbGlkYXRlU2hhcGU8VE9wdGlvbnMsIFJ1bnRpbWVDb25maWdPcHRpb25zPFRDb250ZXh0LCBUTWV0YT4+IiwiY29uZmlnOiBSb290Q29uZmlnPCRSb290PiIsImlzU2VydmVyOiBib29sZWFuIl0sImlnbm9yZUxpc3QiOlszLDRdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/initTRPC-IT_6ZYJd.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observableToAsyncIterable: () => (/* binding */ observableToAsyncIterable),\n/* harmony export */   observableToPromise: () => (/* binding */ observableToPromise)\n/* harmony export */ });\n//#region src/observable/observable.ts\n/** @public */ function isObservable(x) {\n    return typeof x === \"object\" && x !== null && \"subscribe\" in x;\n}\n/** @public */ function observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) return;\n                unsubscribed = true;\n                if (typeof teardownRef === \"function\") teardownRef();\n                else if (teardownRef) teardownRef.unsubscribe();\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    var _observer$next;\n                    if (isDone) return;\n                    (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n                },\n                error (err) {\n                    var _observer$error;\n                    if (isDone) return;\n                    isDone = true;\n                    (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err);\n                    unsubscribe();\n                },\n                complete () {\n                    var _observer$complete;\n                    if (isDone) return;\n                    isDone = true;\n                    (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) unsubscribe();\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return operations.reduce(pipeReducer, self);\n        }\n    };\n    return self;\n}\nfunction pipeReducer(prev, fn) {\n    return fn(prev);\n}\n/** @internal */ function observableToPromise(observable$1) {\n    const ac = new AbortController();\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) return;\n            isDone = true;\n            obs$.unsubscribe();\n        }\n        ac.signal.addEventListener(\"abort\", ()=>{\n            reject(ac.signal.reason);\n        });\n        const obs$ = observable$1.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                reject(data);\n            },\n            complete () {\n                ac.abort();\n                onDone();\n            }\n        });\n    });\n    return promise;\n}\n/**\n* @internal\n*/ function observableToReadableStream(observable$1, signal) {\n    let unsub = null;\n    const onAbort = ()=>{\n        unsub === null || unsub === void 0 || unsub.unsubscribe();\n        unsub = null;\n        signal.removeEventListener(\"abort\", onAbort);\n    };\n    return new ReadableStream({\n        start (controller) {\n            unsub = observable$1.subscribe({\n                next (data) {\n                    controller.enqueue({\n                        ok: true,\n                        value: data\n                    });\n                },\n                error (error) {\n                    controller.enqueue({\n                        ok: false,\n                        error\n                    });\n                    controller.close();\n                },\n                complete () {\n                    controller.close();\n                }\n            });\n            if (signal.aborted) onAbort();\n            else signal.addEventListener(\"abort\", onAbort, {\n                once: true\n            });\n        },\n        cancel () {\n            onAbort();\n        }\n    });\n}\n/** @internal */ function observableToAsyncIterable(observable$1, signal) {\n    const stream = observableToReadableStream(observable$1, signal);\n    const reader = stream.getReader();\n    const iterator = {\n        async next () {\n            const value = await reader.read();\n            if (value.done) return {\n                value: void 0,\n                done: true\n            };\n            const { value: result } = value;\n            if (!result.ok) throw result.error;\n            return {\n                value: result.value,\n                done: false\n            };\n        },\n        async return () {\n            await reader.cancel();\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n    };\n    return {\n        [Symbol.asyncIterator] () {\n            return iterator;\n        }\n    };\n}\n//#endregion\n //# sourceMappingURL=observable-UMO3vUa_.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3Qvb2JzZXJ2YWJsZS1VTU8zdlVhXy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7ZUFlQSxTQUFnQixhQUFhQSxDQUFBQSxFQUErQztJQUMxRSxjQUFjLE1BQU0sWUFBWSxNQUFNLFFBQVEsZUFBZTtBQUM5RDtlQUdELFNBQWdCLFdBQ2RDLFNBQUFBLEVBQzRCO0lBQzVCLE1BQU1DLE9BQW1DO1FBQ3ZDLFdBQVUsVUFBVTtZQUNsQixJQUFJQyxjQUFvQztZQUN4QyxJQUFJLFNBQVM7WUFDYixJQUFJLGVBQWU7WUFDbkIsSUFBSSxzQkFBc0I7WUFDMUIsU0FBUyxjQUFjO2dCQUNyQixJQUFJLGdCQUFnQixNQUFNO29CQUN4QixzQkFBc0I7b0JBQ3RCO2dCQUNEO2dCQUNELElBQUksYUFDRjtnQkFFRixlQUFlO2dCQUVmLFdBQVcsZ0JBQWdCLFdBQ3pCLGNBQWE7eUJBQ0osWUFDVCxhQUFZLGFBQWE7WUFFNUI7WUFDRCxjQUFjLFVBQVU7Z0JBQ3RCLE1BQUssT0FBTzs7b0JBQ1YsSUFBSSxPQUNGO29CQUVGLDJCQUFTLCtDQUFULDhCQUFnQixNQUFNO2dCQUN2QjtnQkFDRCxPQUFNLEtBQUs7O29CQUNULElBQUksT0FDRjtvQkFFRixTQUFTO29CQUNULDRCQUFTLGlEQUFULCtCQUFpQixJQUFJO29CQUNyQixhQUFhO2dCQUNkO2dCQUNELFdBQVc7O29CQUNULElBQUksT0FDRjtvQkFFRixTQUFTO29CQUNULCtCQUFTLHVEQUFULGlDQUFxQjtvQkFDckIsYUFBYTtnQkFDZDtZQUNGLEVBQUM7WUFDRixJQUFJLG9CQUNGLGNBQWE7WUFFZixPQUFPO2dCQUNMO1lBQ0Q7UUFDRjtRQUNELE1BQ0UsR0FBRyxZQUNtQjtZQUN0QixPQUFPLFdBQVcsT0FBTyxhQUFhLEtBQUs7UUFDNUM7SUFDRjtJQUNELE9BQU87QUFDUjtBQUVELFNBQVMsWUFBWUMsSUFBQUEsRUFBV0MsRUFBQUEsRUFBNkI7SUFDM0QsT0FBTyxHQUFHLEtBQUs7QUFDaEI7aUJBR0QsU0FBZ0Isb0JBQ2RDLFlBQUFBLEVBQ0E7SUFDQSxNQUFNLEtBQUssSUFBSTtJQUNmLE1BQU0sVUFBVSxJQUFJLFFBQWdCLENBQUMsU0FBUztRQUM1QyxJQUFJLFNBQVM7UUFDYixTQUFTLFNBQVM7WUFDaEIsSUFBSSxPQUNGO1lBRUYsU0FBUztZQUNULEtBQUssYUFBYTtRQUNuQjtRQUNELEdBQUcsT0FBTyxpQkFBaUIsU0FBUztZQUNsQyxPQUFPLEdBQUcsT0FBTyxPQUFPO1FBQ3pCLEVBQUM7UUFDRixNQUFNLE9BQU8sYUFBVyxVQUFVO1lBQ2hDLE1BQUssTUFBTTtnQkFDVCxTQUFTO2dCQUNULFFBQVEsS0FBSztnQkFDYixRQUFRO1lBQ1Q7WUFDRCxPQUFNLE1BQU07Z0JBQ1YsT0FBTyxLQUFLO1lBQ2I7WUFDRCxXQUFXO2dCQUNULEdBQUcsT0FBTztnQkFDVixRQUFRO1lBQ1Q7UUFDRixFQUFDO0lBQ0g7SUFDRCxPQUFPO0FBQ1I7OztHQUtELFNBQVMsMkJBQ1BBLFlBQUFBLEVBQ0FDLE1BQUFBLEVBQ2dDO0lBQ2hDLElBQUlDLFFBQStCO0lBRW5DLE1BQU0sVUFBVTtRQUNkLDRDQUFPLGFBQWE7UUFDcEIsUUFBUTtRQUNSLE9BQU8sb0JBQW9CLFNBQVMsUUFBUTtJQUM3QztJQUVELE9BQU8sSUFBSSxlQUErQjtRQUN4QyxPQUFNLFlBQVk7WUFDaEIsUUFBUSxhQUFXLFVBQVU7Z0JBQzNCLE1BQUssTUFBTTtvQkFDVCxXQUFXLFFBQVE7d0JBQUUsSUFBSTt3QkFBTSxPQUFPO29CQUFNLEVBQUM7Z0JBQzlDO2dCQUNELE9BQU0sT0FBTztvQkFDWCxXQUFXLFFBQVE7d0JBQUUsSUFBSTt3QkFBTztvQkFBTyxFQUFDO29CQUN4QyxXQUFXLE9BQU87Z0JBQ25CO2dCQUNELFdBQVc7b0JBQ1QsV0FBVyxPQUFPO2dCQUNuQjtZQUNGLEVBQUM7WUFFRixJQUFJLE9BQU8sUUFDVCxVQUFTO2lCQUVULE9BQU8saUJBQWlCLFNBQVMsU0FBUztnQkFBRSxNQUFNO1lBQU0sRUFBQztRQUU1RDtRQUNELFNBQVM7WUFDUCxTQUFTO1FBQ1Y7SUFDRjtBQUNGO2lCQUdELFNBQWdCLDBCQUNkRixZQUFBQSxFQUNBQyxNQUFBQSxFQUN1QjtJQUN2QixNQUFNLFNBQVMsMkJBQTJCRSxjQUFZLE9BQU87SUFFN0QsTUFBTSxTQUFTLE9BQU8sV0FBVztJQUNqQyxNQUFNQyxXQUFrQztRQUN0QyxNQUFNLE9BQU87WUFDWCxNQUFNLFFBQVEsTUFBTSxPQUFPLE1BQU07WUFDakMsSUFBSSxNQUFNLEtBQ1IsUUFBTztnQkFDTDtnQkFDQSxNQUFNO1lBQ1A7WUFFSCxNQUFNLEVBQUUsT0FBTyxRQUFRLEdBQUc7WUFDMUIsS0FBSyxPQUFPLEdBQ1YsT0FBTSxPQUFPO1lBRWYsT0FBTztnQkFDTCxPQUFPLE9BQU87Z0JBQ2QsTUFBTTtZQUNQO1FBQ0Y7UUFDRCxNQUFNLFNBQVM7WUFDYixNQUFNLE9BQU8sUUFBUTtZQUNyQixPQUFPO2dCQUNMO2dCQUNBLE1BQU07WUFDUDtRQUNGO0lBQ0Y7SUFDRCxPQUFPO1FBQ0wsQ0FBQyxPQUFPLGlCQUFpQjtZQUN2QixPQUFPO1FBQ1I7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZXN1bHQgfSBmcm9tICcuLi91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQnO1xuaW1wb3J0IHR5cGUge1xuICBPYnNlcnZhYmxlLFxuICBPYnNlcnZlcixcbiAgT3BlcmF0b3JGdW5jdGlvbixcbiAgVGVhcmRvd25Mb2dpYyxcbiAgVW5hcnlGdW5jdGlvbixcbiAgVW5zdWJzY3JpYmFibGUsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgaW5mZXJPYnNlcnZhYmxlVmFsdWU8VE9ic2VydmFibGU+ID1cbiAgVE9ic2VydmFibGUgZXh0ZW5kcyBPYnNlcnZhYmxlPGluZmVyIFRWYWx1ZSwgdW5rbm93bj4gPyBUVmFsdWUgOiBuZXZlcjtcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09ic2VydmFibGUoeDogdW5rbm93bik6IHggaXMgT2JzZXJ2YWJsZTx1bmtub3duLCB1bmtub3duPiB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAnc3Vic2NyaWJlJyBpbiB4O1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGU8VFZhbHVlLCBURXJyb3IgPSB1bmtub3duPihcbiAgc3Vic2NyaWJlOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFRWYWx1ZSwgVEVycm9yPikgPT4gVGVhcmRvd25Mb2dpYyxcbik6IE9ic2VydmFibGU8VFZhbHVlLCBURXJyb3I+IHtcbiAgY29uc3Qgc2VsZjogT2JzZXJ2YWJsZTxUVmFsdWUsIFRFcnJvcj4gPSB7XG4gICAgc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICBsZXQgdGVhcmRvd25SZWY6IFRlYXJkb3duTG9naWMgfCBudWxsID0gbnVsbDtcbiAgICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIGxldCB1bnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGxldCB0ZWFyZG93bkltbWVkaWF0ZWx5ID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRlYXJkb3duUmVmID09PSBudWxsKSB7XG4gICAgICAgICAgdGVhcmRvd25JbW1lZGlhdGVseSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1YnNjcmliZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHRlYXJkb3duUmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGVhcmRvd25SZWYoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZWFyZG93blJlZikge1xuICAgICAgICAgIHRlYXJkb3duUmVmLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlYXJkb3duUmVmID0gc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4oZXJyKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGlmICh0ZWFyZG93bkltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBwaXBlKFxuICAgICAgLi4ub3BlcmF0aW9uczogT3BlcmF0b3JGdW5jdGlvbjxhbnksIGFueSwgYW55LCBhbnk+W11cbiAgICApOiBPYnNlcnZhYmxlPGFueSwgYW55PiB7XG4gICAgICByZXR1cm4gb3BlcmF0aW9ucy5yZWR1Y2UocGlwZVJlZHVjZXIsIHNlbGYpO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBwaXBlUmVkdWNlcihwcmV2OiBhbnksIGZuOiBVbmFyeUZ1bmN0aW9uPGFueSwgYW55Pikge1xuICByZXR1cm4gZm4ocHJldik7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlVG9Qcm9taXNlPFRWYWx1ZT4oXG4gIG9ic2VydmFibGU6IE9ic2VydmFibGU8VFZhbHVlLCB1bmtub3duPixcbikge1xuICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFRWYWx1ZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBvbkRvbmUoKSB7XG4gICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBvYnMkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgIHJlamVjdChhYy5zaWduYWwucmVhc29uKTtcbiAgICB9KTtcbiAgICBjb25zdCBvYnMkID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dChkYXRhKSB7XG4gICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIG9uRG9uZSgpO1xuICAgICAgfSxcbiAgICAgIGVycm9yKGRhdGEpIHtcbiAgICAgICAgcmVqZWN0KGRhdGEpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBvbkRvbmUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW08VFZhbHVlPihcbiAgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUVmFsdWUsIHVua25vd24+LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuKTogUmVhZGFibGVTdHJlYW08UmVzdWx0PFRWYWx1ZT4+IHtcbiAgbGV0IHVuc3ViOiBVbnN1YnNjcmliYWJsZSB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgdW5zdWI/LnVuc3Vic2NyaWJlKCk7XG4gICAgdW5zdWIgPSBudWxsO1xuICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpO1xuICB9O1xuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW08UmVzdWx0PFRWYWx1ZT4+KHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB1bnN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dChkYXRhKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgb2s6IHRydWUsIHZhbHVlOiBkYXRhIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IG9rOiBmYWxzZSwgZXJyb3IgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIG9uQWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICAgIG9uQWJvcnQoKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGU8VFZhbHVlPihcbiAgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUVmFsdWUsIHVua25vd24+LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuKTogQXN5bmNJdGVyYWJsZTxUVmFsdWU+IHtcbiAgY29uc3Qgc3RyZWFtID0gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSwgc2lnbmFsKTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGl0ZXJhdG9yOiBBc3luY0l0ZXJhdG9yPFRWYWx1ZT4gPSB7XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICh2YWx1ZS5kb25lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2YWx1ZTogcmVzdWx0IH0gPSB2YWx1ZTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbIng6IHVua25vd24iLCJzdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VFZhbHVlLCBURXJyb3I+KSA9PiBUZWFyZG93bkxvZ2ljIiwic2VsZjogT2JzZXJ2YWJsZTxUVmFsdWUsIFRFcnJvcj4iLCJ0ZWFyZG93blJlZjogVGVhcmRvd25Mb2dpYyB8IG51bGwiLCJwcmV2OiBhbnkiLCJmbjogVW5hcnlGdW5jdGlvbjxhbnksIGFueT4iLCJvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFRWYWx1ZSwgdW5rbm93bj4iLCJzaWduYWw6IEFib3J0U2lnbmFsIiwidW5zdWI6IFVuc3Vic2NyaWJhYmxlIHwgbnVsbCIsIm9ic2VydmFibGUiLCJpdGVyYXRvcjogQXN5bmNJdGVyYXRvcjxUVmFsdWU+Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpromise: () => (/* binding */ Unpromise),\n/* harmony export */   createDeferred: () => (/* binding */ createDeferred),\n/* harmony export */   getRequestInfo: () => (/* binding */ getRequestInfo),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iteratorResource: () => (/* binding */ iteratorResource),\n/* harmony export */   jsonlStreamConsumer: () => (/* binding */ jsonlStreamConsumer),\n/* harmony export */   jsonlStreamProducer: () => (/* binding */ jsonlStreamProducer),\n/* harmony export */   makeAsyncResource: () => (/* binding */ makeAsyncResource),\n/* harmony export */   makeResource: () => (/* binding */ makeResource),\n/* harmony export */   parseConnectionParamsFromString: () => (/* binding */ parseConnectionParamsFromString),\n/* harmony export */   parseConnectionParamsFromUnknown: () => (/* binding */ parseConnectionParamsFromUnknown),\n/* harmony export */   require_usingCtx: () => (/* binding */ require_usingCtx),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   sseHeaders: () => (/* binding */ sseHeaders),\n/* harmony export */   sseStreamConsumer: () => (/* binding */ sseStreamConsumer),\n/* harmony export */   sseStreamProducer: () => (/* binding */ sseStreamProducer),\n/* harmony export */   takeWithGrace: () => (/* binding */ takeWithGrace),\n/* harmony export */   throwAbortError: () => (/* binding */ throwAbortError),\n/* harmony export */   withMaxDuration: () => (/* binding */ withMaxDuration)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\");\n/* harmony import */ var _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-gU3ttYjg.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs\");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\");\n\n\n\n\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n    try {\n        if (parsed === null) return null;\n        if (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(parsed)) throw new Error(\"Expected object\");\n        const nonStringValues = Object.entries(parsed).filter(([_key, value])=>typeof value !== \"string\");\n        if (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value])=>`${key}: ${typeof value}`).join(\", \")}`);\n        return parsed;\n    } catch (cause) {\n        throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"PARSE_ERROR\",\n            message: \"Invalid connection params shape\",\n            cause\n        });\n    }\n}\nfunction parseConnectionParamsFromString(str) {\n    let parsed;\n    try {\n        parsed = JSON.parse(str);\n    } catch (cause) {\n        throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"PARSE_ERROR\",\n            message: \"Not JSON-parsable query params\",\n            cause\n        });\n    }\n    return parseConnectionParamsFromUnknown(parsed);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/ function memo(fn) {\n    let promise = null;\n    const sym = Symbol.for(\"@trpc/server/http/memo\");\n    let value = sym;\n    return {\n        read: async ()=>{\n            var _promise;\n            if (value !== sym) return value;\n            (_promise = promise) !== null && _promise !== void 0 || (promise = fn().catch((cause)=>{\n                if (cause instanceof _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError) throw cause;\n                throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"BAD_REQUEST\",\n                    message: cause instanceof Error ? cause.message : \"Invalid input\",\n                    cause\n                });\n            }));\n            value = await promise;\n            promise = null;\n            return value;\n        },\n        result: ()=>{\n            return value !== sym ? value : void 0;\n        }\n    };\n}\nconst jsonContentTypeHandler = {\n    isMatch (req) {\n        var _req$headers$get;\n        return !!((_req$headers$get = req.headers.get(\"content-type\")) === null || _req$headers$get === void 0 ? void 0 : _req$headers$get.startsWith(\"application/json\"));\n    },\n    async parse (opts) {\n        var _types$values$next$va;\n        const { req } = opts;\n        const isBatchCall = opts.searchParams.get(\"batch\") === \"1\";\n        const paths = isBatchCall ? opts.path.split(\",\") : [\n            opts.path\n        ];\n        const getInputs = memo(async ()=>{\n            let inputs = void 0;\n            if (req.method === \"GET\") {\n                const queryInput = opts.searchParams.get(\"input\");\n                if (queryInput) inputs = JSON.parse(queryInput);\n            } else inputs = await req.json();\n            if (inputs === void 0) return {};\n            if (!isBatchCall) return {\n                0: opts.router._def._config.transformer.input.deserialize(inputs)\n            };\n            if (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(inputs)) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                code: \"BAD_REQUEST\",\n                message: \"\\\"input\\\" needs to be an object when doing a batch call\"\n            });\n            const acc = {};\n            for (const index of paths.keys()){\n                const input = inputs[index];\n                if (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n            }\n            return acc;\n        });\n        const calls = await Promise.all(paths.map(async (path, index)=>{\n            const procedure = await (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, path);\n            return {\n                path,\n                procedure,\n                getRawInput: async ()=>{\n                    const inputs = await getInputs.read();\n                    let input = inputs[index];\n                    if ((procedure === null || procedure === void 0 ? void 0 : procedure._def.type) === \"subscription\") {\n                        var _ref, _opts$headers$get;\n                        const lastEventId = (_ref = (_opts$headers$get = opts.headers.get(\"last-event-id\")) !== null && _opts$headers$get !== void 0 ? _opts$headers$get : opts.searchParams.get(\"lastEventId\")) !== null && _ref !== void 0 ? _ref : opts.searchParams.get(\"Last-Event-Id\");\n                        if (lastEventId) if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) input = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, input), {}, {\n                            lastEventId\n                        });\n                        else {\n                            var _input;\n                            (_input = input) !== null && _input !== void 0 || (input = {\n                                lastEventId\n                            });\n                        }\n                    }\n                    return input;\n                },\n                result: ()=>{\n                    var _getInputs$result;\n                    return (_getInputs$result = getInputs.result()) === null || _getInputs$result === void 0 ? void 0 : _getInputs$result[index];\n                }\n            };\n        }));\n        const types = new Set(calls.map((call)=>{\n            var _call$procedure;\n            return (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n        }).filter(Boolean));\n        /* istanbul ignore if -- @preserve */ if (types.size > 1) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot mix procedure types in call: ${Array.from(types).join(\", \")}`\n        });\n        const type = (_types$values$next$va = types.values().next().value) !== null && _types$values$next$va !== void 0 ? _types$values$next$va : \"unknown\";\n        const connectionParamsStr = opts.searchParams.get(\"connectionParams\");\n        const info = {\n            isBatchCall,\n            accept: req.headers.get(\"trpc-accept\"),\n            calls,\n            type,\n            connectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n            signal: req.signal,\n            url: opts.url\n        };\n        return info;\n    }\n};\nconst formDataContentTypeHandler = {\n    isMatch (req) {\n        var _req$headers$get2;\n        return !!((_req$headers$get2 = req.headers.get(\"content-type\")) === null || _req$headers$get2 === void 0 ? void 0 : _req$headers$get2.startsWith(\"multipart/form-data\"));\n    },\n    async parse (opts) {\n        const { req } = opts;\n        if (req.method !== \"POST\") throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"METHOD_NOT_SUPPORTED\",\n            message: \"Only POST requests are supported for multipart/form-data requests\"\n        });\n        const getInputs = memo(async ()=>{\n            const fd = await req.formData();\n            return fd;\n        });\n        const procedure = await (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path);\n        return {\n            accept: null,\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure\n                }\n            ],\n            isBatchCall: false,\n            type: \"mutation\",\n            connectionParams: null,\n            signal: req.signal,\n            url: opts.url\n        };\n    }\n};\nconst octetStreamContentTypeHandler = {\n    isMatch (req) {\n        var _req$headers$get3;\n        return !!((_req$headers$get3 = req.headers.get(\"content-type\")) === null || _req$headers$get3 === void 0 ? void 0 : _req$headers$get3.startsWith(\"application/octet-stream\"));\n    },\n    async parse (opts) {\n        const { req } = opts;\n        if (req.method !== \"POST\") throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"METHOD_NOT_SUPPORTED\",\n            message: \"Only POST requests are supported for application/octet-stream requests\"\n        });\n        const getInputs = memo(async ()=>{\n            return req.body;\n        });\n        return {\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: await (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path)\n                }\n            ],\n            isBatchCall: false,\n            accept: null,\n            type: \"mutation\",\n            connectionParams: null,\n            signal: req.signal,\n            url: opts.url\n        };\n    }\n};\nconst handlers = [\n    jsonContentTypeHandler,\n    formDataContentTypeHandler,\n    octetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n    const handler = handlers.find((handler$1)=>handler$1.isMatch(req));\n    if (handler) return handler;\n    if (!handler && req.method === \"GET\") return jsonContentTypeHandler;\n    throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n        code: \"UNSUPPORTED_MEDIA_TYPE\",\n        message: req.headers.has(\"content-type\") ? `Unsupported content-type \"${req.headers.get(\"content-type\")}` : \"Missing content-type header\"\n    });\n}\nasync function getRequestInfo(opts) {\n    const handler = getContentTypeHandler(opts.req);\n    return await handler.parse(opts);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(error) && error[\"name\"] === \"AbortError\";\n}\nfunction throwAbortError(message = \"AbortError\") {\n    throw new DOMException(message, \"AbortError\");\n}\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_defineProperty)(), 1);\nlet _Symbol$toStringTag;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/ const subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */ const NOOP = ()=>{};\n_Symbol$toStringTag = Symbol.toStringTag;\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/ var Unpromise = class Unpromise {\n    constructor(arg){\n        (0, import_defineProperty.default)(this, \"promise\", void 0);\n        (0, import_defineProperty.default)(this, \"subscribers\", []);\n        (0, import_defineProperty.default)(this, \"settlement\", null);\n        (0, import_defineProperty.default)(this, _Symbol$toStringTag, \"Unpromise\");\n        if (typeof arg === \"function\") this.promise = new Promise(arg);\n        else this.promise = arg;\n        const thenReturn = this.promise.then((value)=>{\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"fulfilled\",\n                value\n            };\n            subscribers === null || subscribers === void 0 || subscribers.forEach(({ resolve })=>{\n                resolve(value);\n            });\n        });\n        if (\"catch\" in thenReturn) thenReturn.catch((reason)=>{\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"rejected\",\n                reason\n            };\n            subscribers === null || subscribers === void 0 || subscribers.forEach(({ reject })=>{\n                reject(reason);\n            });\n        });\n    }\n    /** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/ subscribe() {\n        let promise;\n        let unsubscribe;\n        const { settlement } = this;\n        if (settlement === null) {\n            if (this.subscribers === null) throw new Error(\"Unpromise settled but still has subscribers\");\n            const subscriber = withResolvers();\n            this.subscribers = listWithMember(this.subscribers, subscriber);\n            promise = subscriber.promise;\n            unsubscribe = ()=>{\n                if (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n            };\n        } else {\n            const { status } = settlement;\n            if (status === \"fulfilled\") promise = Promise.resolve(settlement.value);\n            else promise = Promise.reject(settlement.reason);\n            unsubscribe = NOOP;\n        }\n        return Object.assign(promise, {\n            unsubscribe\n        });\n    }\n    /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */ then(onfulfilled, onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.then(onfulfilled, onrejected), {\n            unsubscribe\n        });\n    }\n    catch(onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.catch(onrejected), {\n            unsubscribe\n        });\n    }\n    finally(onfinally) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.finally(onfinally), {\n            unsubscribe\n        });\n    }\n    /** Unpromise STATIC METHODS */ /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */ static proxy(promise) {\n        const cached = Unpromise.getSubscribablePromise(promise);\n        return typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n    }\n    /** Create and store an Unpromise keyed by an original Promise. */ static createSubscribablePromise(promise) {\n        const created = new Unpromise(promise);\n        subscribableCache.set(promise, created);\n        subscribableCache.set(created, created);\n        return created;\n    }\n    /** Retrieve a previously-created Unpromise keyed by an original Promise. */ static getSubscribablePromise(promise) {\n        return subscribableCache.get(promise);\n    }\n    /** Promise STATIC METHODS */ /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */ static resolve(value) {\n        const promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n        return Unpromise.proxy(promise).subscribe();\n    }\n    static async any(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.any(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    static async race(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.race(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    /** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */ static async raceReferences(promises) {\n        const selfPromises = promises.map(resolveSelfTuple);\n        try {\n            return await Promise.race(selfPromises);\n        } finally{\n            for (const promise of selfPromises)promise.unsubscribe();\n        }\n    }\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */ function resolveSelfTuple(promise) {\n    return Unpromise.proxy(promise).then(()=>[\n            promise\n        ]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */ /** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */ function withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject)=>{\n        resolve = _resolve;\n        reject = _reject;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n/** IMMUTABLE LIST OPERATIONS */ function listWithMember(arr, member) {\n    return [\n        ...arr,\n        member\n    ];\n}\nfunction listWithoutIndex(arr, index) {\n    return [\n        ...arr.slice(0, index),\n        ...arr.slice(index + 1)\n    ];\n}\nfunction listWithoutMember(arr, member) {\n    const index = arr.indexOf(member);\n    if (index !== -1) return listWithoutIndex(arr, index);\n    return arr;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nvar _Symbol, _Symbol$dispose, _Symbol2, _Symbol2$asyncDispose;\n(_Symbol$dispose = (_Symbol = Symbol).dispose) !== null && _Symbol$dispose !== void 0 || (_Symbol.dispose = Symbol());\n(_Symbol2$asyncDispose = (_Symbol2 = Symbol).asyncDispose) !== null && _Symbol2$asyncDispose !== void 0 || (_Symbol2.asyncDispose = Symbol());\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/ function makeResource(thing, dispose) {\n    const it = thing;\n    const existing = it[Symbol.dispose];\n    it[Symbol.dispose] = ()=>{\n        dispose();\n        existing === null || existing === void 0 || existing();\n    };\n    return it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/ function makeAsyncResource(thing, dispose) {\n    const it = thing;\n    const existing = it[Symbol.asyncDispose];\n    it[Symbol.asyncDispose] = async ()=>{\n        await dispose();\n        await (existing === null || existing === void 0 ? void 0 : existing());\n    };\n    return it;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n    let timer = null;\n    return makeResource({\n        start () {\n            if (timer) throw new Error(\"Timer already started\");\n            const promise = new Promise((resolve)=>{\n                timer = setTimeout(()=>resolve(disposablePromiseTimerResult), ms);\n            });\n            return promise;\n        }\n    }, ()=>{\n        if (timer) clearTimeout(timer);\n    });\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\" (exports, module) {\n        function _usingCtx() {\n            var r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n                var n$1 = Error();\n                return n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n            }, e = {}, n = [];\n            function using(r$1, e$1) {\n                if (null != e$1) {\n                    if (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n                    if (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n                    if (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n                    if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n                    t && (o = function o$1() {\n                        try {\n                            t.call(e$1);\n                        } catch (r$2) {\n                            return Promise.reject(r$2);\n                        }\n                    }), n.push({\n                        v: e$1,\n                        d: o,\n                        a: r$1\n                    });\n                } else r$1 && n.push({\n                    d: e$1,\n                    a: r$1\n                });\n                return e$1;\n            }\n            return {\n                e,\n                u: using.bind(null, !1),\n                a: using.bind(null, !0),\n                d: function d() {\n                    var o, t = this.e, s = 0;\n                    function next() {\n                        for(; o = n.pop();)try {\n                            if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n                            if (o.d) {\n                                var r$1 = o.d.call(o.v);\n                                if (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n                            } else s |= 1;\n                        } catch (r$2) {\n                            return err(r$2);\n                        }\n                        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n                        if (t !== e) throw t;\n                    }\n                    function err(n$1) {\n                        return t = t !== e ? new r(n$1, t) : n$1, next();\n                    }\n                    return next();\n                }\n            };\n        }\n        module.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\nvar require_OverloadYield = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\" (exports, module) {\n        function _OverloadYield(e, d) {\n            this.v = e, this.k = d;\n        }\n        module.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\nvar require_awaitAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\" (exports, module) {\n        var OverloadYield$2 = require_OverloadYield();\n        function _awaitAsyncGenerator$5(e) {\n            return new OverloadYield$2(e, 0);\n        }\n        module.exports = _awaitAsyncGenerator$5, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\nvar require_wrapAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\" (exports, module) {\n        var OverloadYield$1 = require_OverloadYield();\n        function _wrapAsyncGenerator$6(e) {\n            return function() {\n                return new AsyncGenerator(e.apply(this, arguments));\n            };\n        }\n        function AsyncGenerator(e) {\n            var r, t;\n            function resume(r$1, t$1) {\n                try {\n                    var n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield$1;\n                    Promise.resolve(u ? o.v : o).then(function(t$2) {\n                        if (u) {\n                            var i = \"return\" === r$1 ? \"return\" : \"next\";\n                            if (!o.k || t$2.done) return resume(i, t$2);\n                            t$2 = e[i](t$2).value;\n                        }\n                        settle(n.done ? \"return\" : \"normal\", t$2);\n                    }, function(e$1) {\n                        resume(\"throw\", e$1);\n                    });\n                } catch (e$1) {\n                    settle(\"throw\", e$1);\n                }\n            }\n            function settle(e$1, n) {\n                switch(e$1){\n                    case \"return\":\n                        r.resolve({\n                            value: n,\n                            done: !0\n                        });\n                        break;\n                    case \"throw\":\n                        r.reject(n);\n                        break;\n                    default:\n                        r.resolve({\n                            value: n,\n                            done: !1\n                        });\n                }\n                (r = r.next) ? resume(r.key, r.arg) : t = null;\n            }\n            this._invoke = function(e$1, n) {\n                return new Promise(function(o, u) {\n                    var i = {\n                        key: e$1,\n                        arg: n,\n                        resolve: o,\n                        reject: u,\n                        next: null\n                    };\n                    t ? t = t.next = i : (r = t = i, resume(e$1, n));\n                });\n            }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n        }\n        AsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function() {\n            return this;\n        }, AsyncGenerator.prototype.next = function(e) {\n            return this._invoke(\"next\", e);\n        }, AsyncGenerator.prototype[\"throw\"] = function(e) {\n            return this._invoke(\"throw\", e);\n        }, AsyncGenerator.prototype[\"return\"] = function(e) {\n            return this._invoke(\"return\", e);\n        };\n        module.exports = _wrapAsyncGenerator$6, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$5 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction iteratorResource(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    if (iterator[Symbol.asyncDispose]) return iterator;\n    return makeAsyncResource(iterator, async ()=>{\n        var _iterator$return;\n        await ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n    });\n}\n/**\n* Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n*/ function withMaxDuration(_x, _x2) {\n    return _withMaxDuration.apply(this, arguments);\n}\nfunction _withMaxDuration() {\n    _withMaxDuration = (0, import_wrapAsyncGenerator$5.default)(function*(iterable, opts) {\n        try {\n            var _usingCtx$1 = (0, import_usingCtx$4.default)();\n            const iterator = _usingCtx$1.a(iteratorResource(iterable));\n            const timer = _usingCtx$1.u(timerResource(opts.maxDurationMs));\n            const timerPromise = timer.start();\n            let result;\n            while(true){\n                result = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([\n                    iterator.next(),\n                    timerPromise\n                ]));\n                if (result === disposablePromiseTimerResult) throwAbortError();\n                if (result.done) return result;\n                yield result.value;\n                result = null;\n            }\n        } catch (_) {\n            _usingCtx$1.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator$4.default)(_usingCtx$1.d());\n        }\n    });\n    return _withMaxDuration.apply(this, arguments);\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/ function takeWithGrace(_x3, _x4) {\n    return _takeWithGrace.apply(this, arguments);\n}\nfunction _takeWithGrace() {\n    _takeWithGrace = (0, import_wrapAsyncGenerator$5.default)(function*(iterable, opts) {\n        try {\n            var _usingCtx3 = (0, import_usingCtx$4.default)();\n            const iterator = _usingCtx3.a(iteratorResource(iterable));\n            let result;\n            const timer = _usingCtx3.u(timerResource(opts.gracePeriodMs));\n            let count = opts.count;\n            let timerPromise = new Promise(()=>{});\n            while(true){\n                result = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([\n                    iterator.next(),\n                    timerPromise\n                ]));\n                if (result === disposablePromiseTimerResult) throwAbortError();\n                if (result.done) return result.value;\n                yield result.value;\n                if (--count === 0) timerPromise = timer.start();\n                result = null;\n            }\n        } catch (_) {\n            _usingCtx3.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator$4.default)(_usingCtx3.d());\n        }\n    });\n    return _takeWithGrace.apply(this, arguments);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction createManagedIterator(iterable, onResult) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let state = \"idle\";\n    function cleanup() {\n        state = \"done\";\n        onResult = ()=>{};\n    }\n    function pull() {\n        if (state !== \"idle\") return;\n        state = \"pending\";\n        const next = iterator.next();\n        next.then((result)=>{\n            if (result.done) {\n                state = \"done\";\n                onResult({\n                    status: \"return\",\n                    value: result.value\n                });\n                cleanup();\n                return;\n            }\n            state = \"idle\";\n            onResult({\n                status: \"yield\",\n                value: result.value\n            });\n        }).catch((cause)=>{\n            onResult({\n                status: \"error\",\n                error: cause\n            });\n            cleanup();\n        });\n    }\n    return {\n        pull,\n        destroy: async ()=>{\n            var _iterator$return;\n            cleanup();\n            await ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n        }\n    };\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/ function mergeAsyncIterables() {\n    let state = \"idle\";\n    let flushSignal = createDeferred();\n    /**\n\t* used while {@link state} is `idle`\n\t*/ const iterables = [];\n    /**\n\t* used while {@link state} is `pending`\n\t*/ const iterators = /* @__PURE__ */ new Set();\n    const buffer = [];\n    function initIterable(iterable) {\n        if (state !== \"pending\") return;\n        const iterator = createManagedIterator(iterable, (result)=>{\n            if (state !== \"pending\") return;\n            switch(result.status){\n                case \"yield\":\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    break;\n                case \"return\":\n                    iterators.delete(iterator);\n                    break;\n                case \"error\":\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    iterators.delete(iterator);\n                    break;\n            }\n            flushSignal.resolve();\n        });\n        iterators.add(iterator);\n        iterator.pull();\n    }\n    return {\n        add (iterable) {\n            switch(state){\n                case \"idle\":\n                    iterables.push(iterable);\n                    break;\n                case \"pending\":\n                    initIterable(iterable);\n                    break;\n                case \"done\":\n                    break;\n            }\n        },\n        [Symbol.asyncIterator] () {\n            return (0, import_wrapAsyncGenerator$4.default)(function*() {\n                try {\n                    var _usingCtx$1 = (0, import_usingCtx$3.default)();\n                    if (state !== \"idle\") throw new Error(\"Cannot iterate twice\");\n                    state = \"pending\";\n                    const _finally = _usingCtx$1.a(makeAsyncResource({}, async ()=>{\n                        state = \"done\";\n                        const errors = [];\n                        await Promise.all(Array.from(iterators.values()).map(async (it)=>{\n                            try {\n                                await it.destroy();\n                            } catch (cause) {\n                                errors.push(cause);\n                            }\n                        }));\n                        buffer.length = 0;\n                        iterators.clear();\n                        flushSignal.resolve();\n                        if (errors.length > 0) throw new AggregateError(errors);\n                    }));\n                    while(iterables.length > 0)initIterable(iterables.shift());\n                    while(iterators.size > 0){\n                        yield (0, import_awaitAsyncGenerator$3.default)(flushSignal.promise);\n                        while(buffer.length > 0){\n                            const [iterator, result] = buffer.shift();\n                            switch(result.status){\n                                case \"yield\":\n                                    yield result.value;\n                                    iterator.pull();\n                                    break;\n                                case \"error\":\n                                    throw result.error;\n                            }\n                        }\n                        flushSignal = createDeferred();\n                    }\n                } catch (_) {\n                    _usingCtx$1.e = _;\n                } finally{\n                    yield (0, import_awaitAsyncGenerator$3.default)(_usingCtx$1.d());\n                }\n            })();\n        }\n    };\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/ function readableStreamFrom(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async cancel () {\n            var _iterator$return;\n            await ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n        },\n        async pull (controller) {\n            const result = await iterator.next();\n            if (result.done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(result.value);\n        }\n    });\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nconst PING_SYM = Symbol(\"ping\");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/ function withPing(_x, _x2) {\n    return _withPing.apply(this, arguments);\n}\nfunction _withPing() {\n    _withPing = (0, import_wrapAsyncGenerator$3.default)(function*(iterable, pingIntervalMs) {\n        try {\n            var _usingCtx$1 = (0, import_usingCtx$2.default)();\n            const iterator = _usingCtx$1.a(iteratorResource(iterable));\n            let result;\n            let nextPromise = iterator.next();\n            while(true)try {\n                var _usingCtx3 = (0, import_usingCtx$2.default)();\n                const pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n                result = yield (0, import_awaitAsyncGenerator$2.default)(Unpromise.race([\n                    nextPromise,\n                    pingPromise.start()\n                ]));\n                if (result === disposablePromiseTimerResult) {\n                    yield PING_SYM;\n                    continue;\n                }\n                if (result.done) return result.value;\n                nextPromise = iterator.next();\n                yield result.value;\n                result = null;\n            } catch (_) {\n                _usingCtx3.e = _;\n            } finally{\n                _usingCtx3.d();\n            }\n        } catch (_) {\n            _usingCtx$1.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator$2.default)(_usingCtx$1.d());\n        }\n    });\n    return _withPing.apply(this, arguments);\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\nvar require_asyncIterator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\" (exports, module) {\n        function _asyncIterator$2(r) {\n            var n, t, o, e = 2;\n            for(\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;){\n                if (t && null != (n = r[t])) return n.call(r);\n                if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n                t = \"@@asyncIterator\", o = \"@@iterator\";\n            }\n            throw new TypeError(\"Object is not async iterable\");\n        }\n        function AsyncFromSyncIterator(r) {\n            function AsyncFromSyncIteratorContinuation(r$1) {\n                if (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + \" is not an object.\"));\n                var n = r$1.done;\n                return Promise.resolve(r$1.value).then(function(r$2) {\n                    return {\n                        value: r$2,\n                        done: n\n                    };\n                });\n            }\n            return AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {\n                this.s = r$1, this.n = r$1.next;\n            }, AsyncFromSyncIterator.prototype = {\n                s: null,\n                n: null,\n                next: function next() {\n                    return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n                },\n                \"return\": function _return(r$1) {\n                    var n = this.s[\"return\"];\n                    return void 0 === n ? Promise.resolve({\n                        value: r$1,\n                        done: !0\n                    }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n                },\n                \"throw\": function _throw(r$1) {\n                    var n = this.s[\"return\"];\n                    return void 0 === n ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n                }\n            }, new AsyncFromSyncIterator(r);\n        }\n        module.exports = _asyncIterator$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_awaitAsyncGenerator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_usingCtx$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_asyncIterator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nfunction isPlainObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n    return ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) && typeof (value === null || value === void 0 ? void 0 : value[\"then\"]) === \"function\" && typeof (value === null || value === void 0 ? void 0 : value[\"catch\"]) === \"function\";\n}\nvar MaxDepthError = class extends Error {\n    constructor(path){\n        super(\"Max depth reached at path: \" + path.join(\".\"));\n        this.path = path;\n    }\n};\nfunction createBatchStreamProducer(_x3) {\n    return _createBatchStreamProducer.apply(this, arguments);\n}\nfunction _createBatchStreamProducer() {\n    _createBatchStreamProducer = (0, import_wrapAsyncGenerator$2.default)(function*(opts) {\n        const { data } = opts;\n        let counter = 0;\n        const placeholder = 0;\n        const mergedIterables = mergeAsyncIterables();\n        function registerAsync(callback) {\n            const idx = counter++;\n            const iterable$1 = callback(idx);\n            mergedIterables.add(iterable$1);\n            return idx;\n        }\n        function encodePromise(promise, path) {\n            return registerAsync(/* @__PURE__ */ function() {\n                var _ref = (0, import_wrapAsyncGenerator$2.default)(function*(idx) {\n                    const error = checkMaxDepth(path);\n                    if (error) {\n                        promise.catch((cause)=>{\n                            var _opts$onError;\n                            (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n                                error: cause,\n                                path\n                            });\n                        });\n                        promise = Promise.reject(error);\n                    }\n                    try {\n                        const next = yield (0, import_awaitAsyncGenerator$1.default)(promise);\n                        yield [\n                            idx,\n                            PROMISE_STATUS_FULFILLED,\n                            encode(next, path)\n                        ];\n                    } catch (cause) {\n                        var _opts$onError2, _opts$formatError;\n                        (_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n                            error: cause,\n                            path\n                        });\n                        yield [\n                            idx,\n                            PROMISE_STATUS_REJECTED,\n                            (_opts$formatError = opts.formatError) === null || _opts$formatError === void 0 ? void 0 : _opts$formatError.call(opts, {\n                                error: cause,\n                                path\n                            })\n                        ];\n                    }\n                });\n                return function(_x) {\n                    return _ref.apply(this, arguments);\n                };\n            }());\n        }\n        function encodeAsyncIterable(iterable$1, path) {\n            return registerAsync(/* @__PURE__ */ function() {\n                var _ref2 = (0, import_wrapAsyncGenerator$2.default)(function*(idx) {\n                    try {\n                        var _usingCtx$1 = (0, import_usingCtx$1.default)();\n                        const error = checkMaxDepth(path);\n                        if (error) throw error;\n                        const iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n                        try {\n                            while(true){\n                                const next = yield (0, import_awaitAsyncGenerator$1.default)(iterator.next());\n                                if (next.done) {\n                                    yield [\n                                        idx,\n                                        ASYNC_ITERABLE_STATUS_RETURN,\n                                        encode(next.value, path)\n                                    ];\n                                    break;\n                                }\n                                yield [\n                                    idx,\n                                    ASYNC_ITERABLE_STATUS_YIELD,\n                                    encode(next.value, path)\n                                ];\n                            }\n                        } catch (cause) {\n                            var _opts$onError3, _opts$formatError2;\n                            (_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n                                error: cause,\n                                path\n                            });\n                            yield [\n                                idx,\n                                ASYNC_ITERABLE_STATUS_ERROR,\n                                (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n                                    error: cause,\n                                    path\n                                })\n                            ];\n                        }\n                    } catch (_) {\n                        _usingCtx$1.e = _;\n                    } finally{\n                        yield (0, import_awaitAsyncGenerator$1.default)(_usingCtx$1.d());\n                    }\n                });\n                return function(_x2) {\n                    return _ref2.apply(this, arguments);\n                };\n            }());\n        }\n        function checkMaxDepth(path) {\n            if (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n            return null;\n        }\n        function encodeAsync(value, path) {\n            if (isPromise(value)) return [\n                CHUNK_VALUE_TYPE_PROMISE,\n                encodePromise(value, path)\n            ];\n            if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value)) {\n                if (opts.maxDepth && path.length >= opts.maxDepth) throw new Error(\"Max depth reached\");\n                return [\n                    CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n                    encodeAsyncIterable(value, path)\n                ];\n            }\n            return null;\n        }\n        function encode(value, path) {\n            if (value === void 0) return [\n                []\n            ];\n            const reg = encodeAsync(value, path);\n            if (reg) return [\n                [\n                    placeholder\n                ],\n                [\n                    null,\n                    ...reg\n                ]\n            ];\n            if (!isPlainObject(value)) return [\n                [\n                    value\n                ]\n            ];\n            const newObj = {};\n            const asyncValues = [];\n            for (const [key, item] of Object.entries(value)){\n                const transformed = encodeAsync(item, [\n                    ...path,\n                    key\n                ]);\n                if (!transformed) {\n                    newObj[key] = item;\n                    continue;\n                }\n                newObj[key] = placeholder;\n                asyncValues.push([\n                    key,\n                    ...transformed\n                ]);\n            }\n            return [\n                [\n                    newObj\n                ],\n                ...asyncValues\n            ];\n        }\n        const newHead = {};\n        for (const [key, item] of Object.entries(data))newHead[key] = encode(item, [\n            key\n        ]);\n        yield newHead;\n        let iterable = mergedIterables;\n        if (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n            for(var _iterator = (0, import_asyncIterator$1.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator$1.default)(_iterator.next())).done; _iteratorAbruptCompletion = false){\n                const value = _step.value;\n                yield value;\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator$1.default)(_iterator.return());\n            } finally{\n                if (_didIteratorError) throw _iteratorError;\n            }\n        }\n    });\n    return _createBatchStreamProducer.apply(this, arguments);\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/ function jsonlStreamProducer(opts) {\n    let stream = readableStreamFrom(createBatchStreamProducer(opts));\n    const { serialize } = opts;\n    if (serialize) stream = stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk === PING_SYM) controller.enqueue(PING_SYM);\n            else controller.enqueue(serialize(chunk));\n        }\n    }));\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk === PING_SYM) controller.enqueue(\" \");\n            else controller.enqueue(JSON.stringify(chunk) + \"\\n\");\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n    constructor(data){\n        super(\"Received error from server\");\n        this.data = data;\n    }\n};\nconst nodeJsStreamToReaderEsque = (source)=>{\n    return {\n        getReader () {\n            const stream = new ReadableStream({\n                start (controller) {\n                    source.on(\"data\", (chunk)=>{\n                        controller.enqueue(chunk);\n                    });\n                    source.on(\"end\", ()=>{\n                        controller.close();\n                    });\n                    source.on(\"error\", (error)=>{\n                        controller.error(error);\n                    });\n                }\n            });\n            return stream.getReader();\n        }\n    };\n};\nfunction createLineAccumulator(from) {\n    const reader = \"getReader\" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n    let lineAggregate = \"\";\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await reader.read();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        cancel () {\n            return reader.cancel();\n        }\n    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            var _parts$pop;\n            lineAggregate += chunk;\n            const parts = lineAggregate.split(\"\\n\");\n            lineAggregate = (_parts$pop = parts.pop()) !== null && _parts$pop !== void 0 ? _parts$pop : \"\";\n            for (const part of parts)controller.enqueue(part);\n        }\n    }));\n}\nfunction createConsumerStream(from) {\n    const stream = createLineAccumulator(from);\n    let sentHead = false;\n    return stream.pipeThrough(new TransformStream({\n        transform (line, controller) {\n            if (!sentHead) {\n                const head = JSON.parse(line);\n                controller.enqueue(head);\n                sentHead = true;\n            } else {\n                const chunk = JSON.parse(line);\n                controller.enqueue(chunk);\n            }\n        }\n    }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/ function createStreamsManager(abortController) {\n    const controllerMap = /* @__PURE__ */ new Map();\n    /**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/ function isEmpty() {\n        return Array.from(controllerMap.values()).every((c)=>c.closed);\n    }\n    /**\n\t* Creates a stream controller\n\t*/ function createStreamController() {\n        let originalController;\n        const stream = new ReadableStream({\n            start (controller) {\n                originalController = controller;\n            }\n        });\n        const streamController = {\n            enqueue: (v)=>originalController.enqueue(v),\n            close: ()=>{\n                originalController.close();\n                clear();\n                if (isEmpty()) abortController.abort();\n            },\n            closed: false,\n            getReaderResource: ()=>{\n                const reader = stream.getReader();\n                return makeResource(reader, ()=>{\n                    reader.releaseLock();\n                    streamController.close();\n                });\n            },\n            error: (reason)=>{\n                originalController.error(reason);\n                clear();\n            }\n        };\n        function clear() {\n            Object.assign(streamController, {\n                closed: true,\n                close: ()=>{},\n                enqueue: ()=>{},\n                getReaderResource: null,\n                error: ()=>{}\n            });\n        }\n        return streamController;\n    }\n    /**\n\t* Gets or creates a stream controller\n\t*/ function getOrCreate(chunkId) {\n        let c = controllerMap.get(chunkId);\n        if (!c) {\n            c = createStreamController();\n            controllerMap.set(chunkId, c);\n        }\n        return c;\n    }\n    /**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/ function cancelAll(reason) {\n        for (const controller of controllerMap.values())controller.error(reason);\n    }\n    return {\n        getOrCreate,\n        isEmpty,\n        cancelAll\n    };\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/ async function jsonlStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let source = createConsumerStream(opts.from);\n    if (deserialize) source = source.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(deserialize(chunk));\n        }\n    }));\n    let headDeferred = createDeferred();\n    const streamManager = createStreamsManager(opts.abortController);\n    function decodeChunkDefinition(value) {\n        const [_path, type, chunkId] = value;\n        const controller = streamManager.getOrCreate(chunkId);\n        switch(type){\n            case CHUNK_VALUE_TYPE_PROMISE:\n                return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async ()=>{\n                    try {\n                        var _usingCtx3 = (0, import_usingCtx$1.default)();\n                        const reader = _usingCtx3.u(controller.getReaderResource());\n                        const { value: value$1 } = await reader.read();\n                        const [_chunkId, status, data] = value$1;\n                        switch(status){\n                            case PROMISE_STATUS_FULFILLED:\n                                return decode(data);\n                            case PROMISE_STATUS_REJECTED:\n                                var _opts$formatError3, _opts$formatError4;\n                                throw (_opts$formatError3 = (_opts$formatError4 = opts.formatError) === null || _opts$formatError4 === void 0 ? void 0 : _opts$formatError4.call(opts, {\n                                    error: data\n                                })) !== null && _opts$formatError3 !== void 0 ? _opts$formatError3 : new AsyncError(data);\n                        }\n                    } catch (_) {\n                        _usingCtx3.e = _;\n                    } finally{\n                        _usingCtx3.d();\n                    }\n                });\n            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:\n                return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$2.default)(function*() {\n                    try {\n                        var _usingCtx4 = (0, import_usingCtx$1.default)();\n                        const reader = _usingCtx4.u(controller.getReaderResource());\n                        while(true){\n                            const { value: value$1 } = yield (0, import_awaitAsyncGenerator$1.default)(reader.read());\n                            const [_chunkId, status, data] = value$1;\n                            switch(status){\n                                case ASYNC_ITERABLE_STATUS_YIELD:\n                                    yield decode(data);\n                                    break;\n                                case ASYNC_ITERABLE_STATUS_RETURN:\n                                    return decode(data);\n                                case ASYNC_ITERABLE_STATUS_ERROR:\n                                    var _opts$formatError5, _opts$formatError6;\n                                    throw (_opts$formatError5 = (_opts$formatError6 = opts.formatError) === null || _opts$formatError6 === void 0 ? void 0 : _opts$formatError6.call(opts, {\n                                        error: data\n                                    })) !== null && _opts$formatError5 !== void 0 ? _opts$formatError5 : new AsyncError(data);\n                            }\n                        }\n                    } catch (_) {\n                        _usingCtx4.e = _;\n                    } finally{\n                        _usingCtx4.d();\n                    }\n                }));\n        }\n    }\n    function decode(value) {\n        const [[data], ...asyncProps] = value;\n        for (const value$1 of asyncProps){\n            const [key] = value$1;\n            const decoded = decodeChunkDefinition(value$1);\n            if (key === null) return decoded;\n            data[key] = decoded;\n        }\n        return data;\n    }\n    const closeOrAbort = (reason)=>{\n        headDeferred === null || headDeferred === void 0 || headDeferred.reject(reason);\n        streamManager.cancelAll(reason);\n    };\n    source.pipeTo(new WritableStream({\n        write (chunkOrHead) {\n            if (headDeferred) {\n                const head = chunkOrHead;\n                for (const [key, value] of Object.entries(chunkOrHead)){\n                    const parsed = decode(value);\n                    head[key] = parsed;\n                }\n                headDeferred.resolve(head);\n                headDeferred = null;\n                return;\n            }\n            const chunk = chunkOrHead;\n            const [idx] = chunk;\n            const controller = streamManager.getOrCreate(idx);\n            controller.enqueue(chunk);\n        },\n        close: ()=>closeOrAbort(new Error(\"Stream closed\")),\n        abort: closeOrAbort\n    }), {\n        signal: opts.abortController.signal\n    }).catch((error)=>{\n        var _opts$onError4;\n        (_opts$onError4 = opts.onError) === null || _opts$onError4 === void 0 || _opts$onError4.call(opts, {\n            error\n        });\n        closeOrAbort(error);\n    });\n    return [\n        await headDeferred.promise,\n        streamManager\n    ];\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\nvar require_asyncGeneratorDelegate = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\" (exports, module) {\n        var OverloadYield = require_OverloadYield();\n        function _asyncGeneratorDelegate$1(t) {\n            var e = {}, n = !1;\n            function pump(e$1, r) {\n                return n = !0, r = new Promise(function(n$1) {\n                    n$1(t[e$1](r));\n                }), {\n                    done: !1,\n                    value: new OverloadYield(r, 1)\n                };\n            }\n            return e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function() {\n                return this;\n            }, e.next = function(t$1) {\n                return n ? (n = !1, t$1) : pump(\"next\", t$1);\n            }, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function(t$1) {\n                if (n) throw n = !1, t$1;\n                return pump(\"throw\", t$1);\n            }), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function(t$1) {\n                return n ? (n = !1, t$1) : pump(\"return\", t$1);\n            }), e;\n        }\n        module.exports = _asyncGeneratorDelegate$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_asyncIterator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nvar import_awaitAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_asyncGeneratorDelegate = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncGeneratorDelegate(), 1);\nvar import_usingCtx = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nconst PING_EVENT = \"ping\";\nconst SERIALIZED_ERROR_EVENT = \"serialized-error\";\nconst CONNECTED_EVENT = \"connected\";\nconst RETURN_EVENT = \"return\";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/ function sseStreamProducer(opts) {\n    var _opts$ping$enabled, _opts$ping, _opts$ping$intervalMs, _opts$ping2, _opts$client;\n    const { serialize = _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.identity } = opts;\n    const ping = {\n        enabled: (_opts$ping$enabled = (_opts$ping = opts.ping) === null || _opts$ping === void 0 ? void 0 : _opts$ping.enabled) !== null && _opts$ping$enabled !== void 0 ? _opts$ping$enabled : false,\n        intervalMs: (_opts$ping$intervalMs = (_opts$ping2 = opts.ping) === null || _opts$ping2 === void 0 ? void 0 : _opts$ping2.intervalMs) !== null && _opts$ping$intervalMs !== void 0 ? _opts$ping$intervalMs : 1e3\n    };\n    const client = (_opts$client = opts.client) !== null && _opts$client !== void 0 ? _opts$client : {};\n    if (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n    function generator() {\n        return _generator.apply(this, arguments);\n    }\n    function _generator() {\n        _generator = (0, import_wrapAsyncGenerator$1.default)(function*() {\n            yield {\n                event: CONNECTED_EVENT,\n                data: JSON.stringify(client)\n            };\n            let iterable = opts.data;\n            if (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n                count: 1,\n                gracePeriodMs: 1\n            });\n            if (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) iterable = withMaxDuration(iterable, {\n                maxDurationMs: opts.maxDurationMs\n            });\n            if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n            let value;\n            let chunk;\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n            var _iteratorError;\n            try {\n                for(var _iterator = (0, import_asyncIterator.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator.default)(_iterator.next())).done; _iteratorAbruptCompletion = false){\n                    value = _step.value;\n                    {\n                        if (value === PING_SYM) {\n                            yield {\n                                event: PING_EVENT,\n                                data: \"\"\n                            };\n                            continue;\n                        }\n                        chunk = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.isTrackedEnvelope)(value) ? {\n                            id: value[0],\n                            data: value[1]\n                        } : {\n                            data: value\n                        };\n                        chunk.data = JSON.stringify(serialize(chunk.data));\n                        yield chunk;\n                        value = null;\n                        chunk = null;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator.default)(_iterator.return());\n                } finally{\n                    if (_didIteratorError) throw _iteratorError;\n                }\n            }\n        });\n        return _generator.apply(this, arguments);\n    }\n    function generatorWithErrorHandling() {\n        return _generatorWithErrorHandling.apply(this, arguments);\n    }\n    function _generatorWithErrorHandling() {\n        _generatorWithErrorHandling = (0, import_wrapAsyncGenerator$1.default)(function*() {\n            try {\n                yield* (0, import_asyncGeneratorDelegate.default)((0, import_asyncIterator.default)(generator()));\n                yield {\n                    event: RETURN_EVENT,\n                    data: \"\"\n                };\n            } catch (cause) {\n                var _opts$formatError, _opts$formatError2;\n                if (isAbortError(cause)) return;\n                const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n                const data = (_opts$formatError = (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n                    error\n                })) !== null && _opts$formatError !== void 0 ? _opts$formatError : null;\n                yield {\n                    event: SERIALIZED_ERROR_EVENT,\n                    data: JSON.stringify(serialize(data))\n                };\n            }\n        });\n        return _generatorWithErrorHandling.apply(this, arguments);\n    }\n    const stream = readableStreamFrom(generatorWithErrorHandling());\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (\"event\" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n            if (\"data\" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n            if (\"id\" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n            if (\"comment\" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n            controller.enqueue(\"\\n\\n\");\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n    try {\n        var _usingCtx$1 = (0, import_usingCtx.default)();\n        const timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n        const res = await Unpromise.race([\n            opts.promise,\n            timeoutPromise.start()\n        ]);\n        if (res === disposablePromiseTimerResult) return await opts.onTimeout();\n        return res;\n    } catch (_) {\n        _usingCtx$1.e = _;\n    } finally{\n        _usingCtx$1.d();\n    }\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/ function sseStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let clientOptions = {};\n    const signal = opts.signal;\n    let _es = null;\n    const createStream = ()=>new ReadableStream({\n            async start (controller) {\n                const [url, init] = await Promise.all([\n                    opts.url(),\n                    opts.init()\n                ]);\n                const eventSource = _es = new opts.EventSource(url, init);\n                controller.enqueue({\n                    type: \"connecting\",\n                    eventSource: _es,\n                    event: null\n                });\n                eventSource.addEventListener(CONNECTED_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    const options = JSON.parse(msg.data);\n                    clientOptions = options;\n                    controller.enqueue({\n                        type: \"connected\",\n                        options,\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    controller.enqueue({\n                        type: \"serialized-error\",\n                        error: deserialize(JSON.parse(msg.data)),\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(PING_EVENT, ()=>{\n                    controller.enqueue({\n                        type: \"ping\",\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(RETURN_EVENT, ()=>{\n                    eventSource.close();\n                    controller.close();\n                    _es = null;\n                });\n                eventSource.addEventListener(\"error\", (event)=>{\n                    if (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n                    else controller.enqueue({\n                        type: \"connecting\",\n                        eventSource,\n                        event\n                    });\n                });\n                eventSource.addEventListener(\"message\", (_msg)=>{\n                    const msg = _msg;\n                    const chunk = deserialize(JSON.parse(msg.data));\n                    const def = {\n                        data: chunk\n                    };\n                    if (msg.lastEventId) def.id = msg.lastEventId;\n                    controller.enqueue({\n                        type: \"data\",\n                        data: def,\n                        eventSource\n                    });\n                });\n                const onAbort = ()=>{\n                    try {\n                        eventSource.close();\n                        controller.close();\n                    } catch (_unused) {}\n                };\n                if (signal.aborted) onAbort();\n                else signal.addEventListener(\"abort\", onAbort);\n            },\n            cancel () {\n                _es === null || _es === void 0 || _es.close();\n            }\n        });\n    const getStreamResource = ()=>{\n        let stream = createStream();\n        let reader = stream.getReader();\n        async function dispose() {\n            await reader.cancel();\n            _es = null;\n        }\n        return makeAsyncResource({\n            read () {\n                return reader.read();\n            },\n            async recreate () {\n                await dispose();\n                stream = createStream();\n                reader = stream.getReader();\n            }\n        }, dispose);\n    };\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$1.default)(function*() {\n        try {\n            var _usingCtx3 = (0, import_usingCtx.default)();\n            const stream = _usingCtx3.a(getStreamResource());\n            while(true){\n                let promise = stream.read();\n                const timeoutMs = clientOptions.reconnectAfterInactivityMs;\n                if (timeoutMs) promise = withTimeout({\n                    promise,\n                    timeoutMs,\n                    onTimeout: async ()=>{\n                        const res = {\n                            value: {\n                                type: \"timeout\",\n                                ms: timeoutMs,\n                                eventSource: _es\n                            },\n                            done: false\n                        };\n                        await stream.recreate();\n                        return res;\n                    }\n                });\n                const result = yield (0, import_awaitAsyncGenerator.default)(promise);\n                if (result.done) return result.value;\n                yield result.value;\n            }\n        } catch (_) {\n            _usingCtx3.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator.default)(_usingCtx3.d());\n        }\n    }));\n}\nconst sseHeaders = {\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache, no-transform\",\n    \"X-Accel-Buffering\": \"no\",\n    Connection: \"keep-alive\"\n};\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nvar import_wrapAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\nfunction errorToAsyncIterable(err) {\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator.default)(function*() {\n        throw err;\n    }));\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n    mutation: [\n        \"POST\"\n    ],\n    query: [\n        \"GET\"\n    ],\n    subscription: [\n        \"GET\"\n    ]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n    mutation: [\n        \"POST\"\n    ],\n    query: [\n        \"GET\",\n        \"POST\"\n    ],\n    subscription: [\n        \"GET\",\n        \"POST\"\n    ]\n};\nfunction initResponse(initOpts) {\n    var _responseMeta, _info$calls$find$proc, _info$calls$find;\n    const { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n    let status = untransformedJSON ? (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getHTTPStatusCode)(untransformedJSON) : 200;\n    const eagerGeneration = !untransformedJSON;\n    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [\n        untransformedJSON\n    ];\n    const meta = (_responseMeta = responseMeta === null || responseMeta === void 0 ? void 0 : responseMeta({\n        ctx,\n        info,\n        paths: info === null || info === void 0 ? void 0 : info.calls.map((call)=>call.path),\n        data,\n        errors,\n        eagerGeneration,\n        type: (_info$calls$find$proc = info === null || info === void 0 || (_info$calls$find = info.calls.find((call)=>{\n            var _call$procedure;\n            return (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n        })) === null || _info$calls$find === void 0 || (_info$calls$find = _info$calls$find.procedure) === null || _info$calls$find === void 0 ? void 0 : _info$calls$find._def.type) !== null && _info$calls$find$proc !== void 0 ? _info$calls$find$proc : \"unknown\"\n    })) !== null && _responseMeta !== void 0 ? _responseMeta : {};\n    if (meta.headers) {\n        if (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries())headers.append(key, value);\n        else /**\n\t\t* @deprecated, delete in v12\n\t\t*/ for (const [key, value] of Object.entries(meta.headers))if (Array.isArray(value)) for (const v of value)headers.append(key, v);\n        else if (typeof value === \"string\") headers.set(key, value);\n    }\n    if (meta.status) status = meta.status;\n    return {\n        status\n    };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n    const { router, req, onError } = errorOpts.opts;\n    const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n    onError === null || onError === void 0 || onError({\n        error,\n        path: errorOpts.path,\n        input: errorOpts.input,\n        ctx: errorOpts.ctx,\n        type: errorOpts.type,\n        req\n    });\n    const untransformedJSON = {\n        error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n            config: router._def._config,\n            error,\n            type: errorOpts.type,\n            path: errorOpts.path,\n            input: errorOpts.input,\n            ctx: errorOpts.ctx\n        })\n    };\n    const transformedJSON = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(router._def._config, untransformedJSON);\n    const body = JSON.stringify(transformedJSON);\n    return {\n        error,\n        untransformedJSON,\n        body\n    };\n}\n/**\n* Check if a value is a stream-like object\n* - if it's an async iterable\n* - if it's an object with async iterables or promises\n*/ function isDataStream(v) {\n    if (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(v)) return false;\n    if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(v)) return true;\n    return Object.values(v).some(isPromise) || Object.values(v).some(_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n    var _ref, _opts$allowBatching, _opts$batching, _opts$allowMethodOver, _config$sse$enabled, _config$sse;\n    const { router, req } = opts;\n    const headers = new Headers([\n        [\n            \"vary\",\n            \"trpc-accept\"\n        ]\n    ]);\n    const config = router._def._config;\n    const url = new URL(req.url);\n    if (req.method === \"HEAD\") return new Response(null, {\n        status: 204\n    });\n    const allowBatching = (_ref = (_opts$allowBatching = opts.allowBatching) !== null && _opts$allowBatching !== void 0 ? _opts$allowBatching : (_opts$batching = opts.batching) === null || _opts$batching === void 0 ? void 0 : _opts$batching.enabled) !== null && _ref !== void 0 ? _ref : true;\n    const allowMethodOverride = ((_opts$allowMethodOver = opts.allowMethodOverride) !== null && _opts$allowMethodOver !== void 0 ? _opts$allowMethodOver : false) && req.method === \"POST\";\n    const infoTuple = await (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async ()=>{\n        try {\n            return [\n                void 0,\n                await getRequestInfo({\n                    req,\n                    path: decodeURIComponent(opts.path),\n                    router,\n                    searchParams: url.searchParams,\n                    headers: opts.req.headers,\n                    url\n                })\n            ];\n        } catch (cause) {\n            return [\n                (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                void 0\n            ];\n        }\n    });\n    const ctxManager = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(()=>{\n        let result = void 0;\n        return {\n            valueOrUndefined: ()=>{\n                if (!result) return void 0;\n                return result[1];\n            },\n            value: ()=>{\n                const [err, ctx] = result;\n                if (err) throw err;\n                return ctx;\n            },\n            create: async (info)=>{\n                if (result) throw new Error(\"This should only be called once - report a bug in tRPC\");\n                try {\n                    const ctx = await opts.createContext({\n                        info\n                    });\n                    result = [\n                        void 0,\n                        ctx\n                    ];\n                } catch (cause) {\n                    result = [\n                        (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                        void 0\n                    ];\n                }\n            }\n        };\n    });\n    const methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n    /**\n\t* @deprecated\n\t*/ const isStreamCall = req.headers.get(\"trpc-accept\") === \"application/jsonl\";\n    const experimentalSSE = (_config$sse$enabled = (_config$sse = config.sse) === null || _config$sse === void 0 ? void 0 : _config$sse.enabled) !== null && _config$sse$enabled !== void 0 ? _config$sse$enabled : true;\n    try {\n        const [infoError, info] = infoTuple;\n        if (infoError) throw infoError;\n        if (info.isBatchCall && !allowBatching) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Batching is not enabled on the server`\n        });\n        /* istanbul ignore if -- @preserve */ if (isStreamCall && !info.isBatchCall) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            message: `Streaming requests must be batched (you can do a batch of 1)`,\n            code: \"BAD_REQUEST\"\n        });\n        await ctxManager.create(info);\n        const rpcCalls = info.calls.map(async (call)=>{\n            const proc = call.procedure;\n            try {\n                if (opts.error) throw opts.error;\n                if (!proc) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"NOT_FOUND\",\n                    message: `No procedure found on path \"${call.path}\"`\n                });\n                if (!methodMapper[proc._def.type].includes(req.method)) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"METHOD_NOT_SUPPORTED\",\n                    message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n                });\n                if (proc._def.type === \"subscription\") {\n                    /* istanbul ignore if -- @preserve */ if (info.isBatchCall) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                        code: \"BAD_REQUEST\",\n                        message: `Cannot batch subscription calls`\n                    });\n                }\n                const data = await proc({\n                    path: call.path,\n                    getRawInput: call.getRawInput,\n                    ctx: ctxManager.value(),\n                    type: proc._def.type,\n                    signal: opts.req.signal\n                });\n                return [\n                    void 0,\n                    {\n                        data\n                    }\n                ];\n            } catch (cause) {\n                var _opts$onError, _call$procedure$_def$, _call$procedure2;\n                const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n                const input = call.result();\n                (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n                    error,\n                    path: call.path,\n                    input,\n                    ctx: ctxManager.valueOrUndefined(),\n                    type: (_call$procedure$_def$ = (_call$procedure2 = call.procedure) === null || _call$procedure2 === void 0 ? void 0 : _call$procedure2._def.type) !== null && _call$procedure$_def$ !== void 0 ? _call$procedure$_def$ : \"unknown\",\n                    req: opts.req\n                });\n                return [\n                    error,\n                    void 0\n                ];\n            }\n        });\n        if (!info.isBatchCall) {\n            const [call] = info.calls;\n            const [error, result] = await rpcCalls[0];\n            switch(info.type){\n                case \"unknown\":\n                case \"mutation\":\n                case \"query\":\n                    {\n                        headers.set(\"content-type\", \"application/json\");\n                        if (isDataStream(result === null || result === void 0 ? void 0 : result.data)) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                            code: \"UNSUPPORTED_MEDIA_TYPE\",\n                            message: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n                        });\n                        const res = error ? {\n                            error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: info.type\n                            })\n                        } : {\n                            result: {\n                                data: result.data\n                            }\n                        };\n                        const headResponse$1 = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: error ? [\n                                error\n                            ] : [],\n                            headers,\n                            untransformedJSON: [\n                                res\n                            ]\n                        });\n                        return new Response(JSON.stringify((0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, res)), {\n                            status: headResponse$1.status,\n                            headers\n                        });\n                    }\n                case \"subscription\":\n                    {\n                        const iterable = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(()=>{\n                            if (error) return errorToAsyncIterable(error);\n                            if (!experimentalSSE) return errorToAsyncIterable(new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                                code: \"METHOD_NOT_SUPPORTED\",\n                                message: \"Missing experimental flag \\\"sseSubscriptions\\\"\"\n                            }));\n                            if (!(0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) && !(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(result.data)) return errorToAsyncIterable(new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                                message: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n                                code: \"INTERNAL_SERVER_ERROR\"\n                            }));\n                            const dataAsIterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : result.data;\n                            return dataAsIterable;\n                        });\n                        const stream = sseStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.sse), {}, {\n                            data: iterable,\n                            serialize: (v)=>config.transformer.output.serialize(v),\n                            formatError (errorOpts) {\n                                var _call$procedure$_def$2, _call$procedure3, _opts$onError2;\n                                const error$1 = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n                                const input = call === null || call === void 0 ? void 0 : call.result();\n                                const path = call === null || call === void 0 ? void 0 : call.path;\n                                const type = (_call$procedure$_def$2 = call === null || call === void 0 || (_call$procedure3 = call.procedure) === null || _call$procedure3 === void 0 ? void 0 : _call$procedure3._def.type) !== null && _call$procedure$_def$2 !== void 0 ? _call$procedure$_def$2 : \"unknown\";\n                                (_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n                                    error: error$1,\n                                    path,\n                                    input,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    req: opts.req,\n                                    type\n                                });\n                                const shape = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                    config,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    error: error$1,\n                                    input,\n                                    path,\n                                    type\n                                });\n                                return shape;\n                            }\n                        }));\n                        for (const [key, value] of Object.entries(sseHeaders))headers.set(key, value);\n                        const headResponse$1 = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: [],\n                            headers,\n                            untransformedJSON: null\n                        });\n                        return new Response(stream, {\n                            headers,\n                            status: headResponse$1.status\n                        });\n                    }\n            }\n        }\n        if (info.accept === \"application/jsonl\") {\n            headers.set(\"content-type\", \"application/json\");\n            headers.set(\"transfer-encoding\", \"chunked\");\n            const headResponse$1 = initResponse({\n                ctx: ctxManager.valueOrUndefined(),\n                info,\n                responseMeta: opts.responseMeta,\n                errors: [],\n                headers,\n                untransformedJSON: null\n            });\n            const stream = jsonlStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.jsonl), {}, {\n                maxDepth: Infinity,\n                data: rpcCalls.map(async (res)=>{\n                    const [error, result] = await res;\n                    const call = info.calls[0];\n                    if (error) {\n                        var _procedure$_def$type, _procedure;\n                        return {\n                            error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: (_procedure$_def$type = (_procedure = call.procedure) === null || _procedure === void 0 ? void 0 : _procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n                            })\n                        };\n                    }\n                    /**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/ const iterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : Promise.resolve(result.data);\n                    return {\n                        result: Promise.resolve({\n                            data: iterable\n                        })\n                    };\n                }),\n                serialize: config.transformer.output.serialize,\n                onError: (cause)=>{\n                    var _opts$onError3, _info$type;\n                    (_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n                        error: (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                        path: void 0,\n                        input: void 0,\n                        ctx: ctxManager.valueOrUndefined(),\n                        req: opts.req,\n                        type: (_info$type = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type !== void 0 ? _info$type : \"unknown\"\n                    });\n                },\n                formatError (errorOpts) {\n                    var _call$procedure$_def$3, _call$procedure4;\n                    const call = info === null || info === void 0 ? void 0 : info.calls[errorOpts.path[0]];\n                    const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n                    const input = call === null || call === void 0 ? void 0 : call.result();\n                    const path = call === null || call === void 0 ? void 0 : call.path;\n                    const type = (_call$procedure$_def$3 = call === null || call === void 0 || (_call$procedure4 = call.procedure) === null || _call$procedure4 === void 0 ? void 0 : _call$procedure4._def.type) !== null && _call$procedure$_def$3 !== void 0 ? _call$procedure$_def$3 : \"unknown\";\n                    const shape = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input,\n                        path,\n                        type\n                    });\n                    return shape;\n                }\n            }));\n            return new Response(stream, {\n                headers,\n                status: headResponse$1.status\n            });\n        }\n        /**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/ headers.set(\"content-type\", \"application/json\");\n        const results = (await Promise.all(rpcCalls)).map((res)=>{\n            const [error, result] = res;\n            if (error) return res;\n            if (isDataStream(result.data)) return [\n                new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"UNSUPPORTED_MEDIA_TYPE\",\n                    message: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n                }),\n                void 0\n            ];\n            return res;\n        });\n        const resultAsRPCResponse = results.map(([error, result], index)=>{\n            const call = info.calls[index];\n            if (error) {\n                var _call$procedure$_def$4, _call$procedure5;\n                return {\n                    error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input: call.result(),\n                        path: call.path,\n                        type: (_call$procedure$_def$4 = (_call$procedure5 = call.procedure) === null || _call$procedure5 === void 0 ? void 0 : _call$procedure5._def.type) !== null && _call$procedure$_def$4 !== void 0 ? _call$procedure$_def$4 : \"unknown\"\n                    })\n                };\n            }\n            return {\n                result: {\n                    data: result.data\n                }\n            };\n        });\n        const errors = results.map(([error])=>error).filter(Boolean);\n        const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON: resultAsRPCResponse,\n            errors,\n            headers\n        });\n        return new Response(JSON.stringify((0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, resultAsRPCResponse)), {\n            status: headResponse.status,\n            headers\n        });\n    } catch (cause) {\n        var _info$type2;\n        const [_infoError, info] = infoTuple;\n        const ctx = ctxManager.valueOrUndefined();\n        const { error, untransformedJSON, body } = caughtErrorToData(cause, {\n            opts,\n            ctx: ctxManager.valueOrUndefined(),\n            type: (_info$type2 = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type2 !== void 0 ? _info$type2 : \"unknown\"\n        });\n        const headResponse = initResponse({\n            ctx,\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON,\n            errors: [\n                error\n            ],\n            headers\n        });\n        return new Response(body, {\n            status: headResponse.status,\n            headers\n        });\n    }\n}\n//#endregion\n //# sourceMappingURL=resolveResponse-CzlbRpCI.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvcmVzb2x2ZVJlc3BvbnNlLUN6bGJScENJLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLFNBQWdCLGlDQUNkQSxNQUFBQSxFQUNxQztJQUNyQyxJQUFJO1FBQ0YsSUFBSSxXQUFXLEtBQ2IsUUFBTztRQUVULEtBQUssNkRBQVEsQ0FBQyxPQUFPLENBQ25CLE9BQU0sSUFBSSxNQUFNO1FBRWxCLE1BQU0sa0JBQWtCLE9BQU8sUUFBUSxPQUFPLENBQUMsT0FDN0MsQ0FBQyxDQUFDLE1BQU0sTUFBTSxVQUFZLFVBQVUsU0FDckM7UUFFRCxJQUFJLGdCQUFnQixTQUFTLEVBQzNCLE9BQU0sSUFBSSxPQUNQLHFEQUFxRCxnQkFDbkQsSUFBSSxDQUFDLENBQUMsS0FBSyxNQUFNLElBQU0sRUFBRSxJQUFJLFdBQVcsTUFBTSxFQUFFLENBQ2hELEtBQUssS0FBSyxDQUFDO1FBR2xCLE9BQU87SUFDUixTQUFRLE9BQU87UUFDZCxNQUFNLElBQUksNERBQVMsQ0FBQztZQUNsQixNQUFNO1lBQ04sU0FBUztZQUNUO1FBQ0Q7SUFDRjtBQUNGO0FBQ0QsU0FBZ0IsZ0NBQ2RDLEdBQUFBLEVBQ3FDO0lBQ3JDLElBQUlEO0lBQ0osSUFBSTtRQUNGLFNBQVMsS0FBSyxNQUFNLElBQUk7SUFDekIsU0FBUSxPQUFPO1FBQ2QsTUFBTSxJQUFJLDREQUFTLENBQUM7WUFDbEIsTUFBTTtZQUNOLFNBQVM7WUFDVDtRQUNEO0lBQ0Y7SUFDRCxPQUFPLGlDQUFpQyxPQUFPO0FBQ2hEOzs7Ozs7O0dDdkJELFNBQVMsS0FBY0UsRUFBQUEsRUFBNEI7SUFDakQsSUFBSUMsVUFBbUM7SUFDdkMsTUFBTSxNQUFNLE9BQU8sSUFBSSx5QkFBeUI7SUFDaEQsSUFBSUMsUUFBOEI7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QUFNLEVBQUUsT0FBTyxtQkFBbUIsTUFBTSxHQUFHLGtCQUFrQixPQUFPO1lBQ2xFO1lBQ0EsS0FBSyxXQUFXLGtCQUFrQjtZQUNsQyxpRUFBTSxLQUFNLHlEQUFRO1FBQ3JCLEVBQUM7UUFFRixNQUFNLGVBQWUsYUFBYTtZQUNoQztZQUNBO1lBQ0EsY0FBYyxLQUFLO1lBQ25CO1lBQ0EsUUFBUTtnQkFBQyxLQUFNO2FBQUE7WUFDZjtRQUNELEVBQUM7UUFFRixPQUFPLElBQUksU0FBUyxNQUFNO1lBQ3hCLFFBQVEsYUFBYTtZQUNyQjtRQUNEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvcGFyc2VDb25uZWN0aW9uUGFyYW1zLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvY29udGVudFR5cGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9hYm9ydEVycm9yLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdmVuZG9yL3VucHJvbWlzZS91bnByb21pc2UudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2Rpc3Bvc2FibGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3RpbWVyUmVzb3VyY2UudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3VzaW5nQ3R4LmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9PdmVybG9hZFlpZWxkLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3IuanMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2FzeW5jSXRlcmFibGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2NyZWF0ZURlZmVycmVkLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9tZXJnZUFzeW5jSXRlcmFibGVzLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20udHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3dpdGhQaW5nLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS9qc29ubC50cyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZS5qcyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vc3NlLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvcmVzb2x2ZVJlc3BvbnNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRSUENFcnJvciB9IGZyb20gJy4uL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgVFJQQ1JlcXVlc3RJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93bihcbiAgcGFyc2VkOiB1bmtub3duLFxuKTogVFJQQ1JlcXVlc3RJbmZvWydjb25uZWN0aW9uUGFyYW1zJ10ge1xuICB0cnkge1xuICAgIGlmIChwYXJzZWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KHBhcnNlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG5vblN0cmluZ1ZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHBhcnNlZCkuZmlsdGVyKFxuICAgICAgKFtfa2V5LCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycsXG4gICAgKTtcblxuICAgIGlmIChub25TdHJpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgY29ubmVjdGlvblBhcmFtcyB0byBiZSBzdHJpbmcgdmFsdWVzLiBHb3QgJHtub25TdHJpbmdWYWx1ZXNcbiAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06ICR7dHlwZW9mIHZhbHVlfWApXG4gICAgICAgICAgLmpvaW4oJywgJyl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgIGNvZGU6ICdQQVJTRV9FUlJPUicsXG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBjb25uZWN0aW9uIHBhcmFtcyBzaGFwZScsXG4gICAgICBjYXVzZSxcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoXG4gIHN0cjogc3RyaW5nLFxuKTogVFJQQ1JlcXVlc3RJbmZvWydjb25uZWN0aW9uUGFyYW1zJ10ge1xuICBsZXQgcGFyc2VkOiB1bmtub3duO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgIGNvZGU6ICdQQVJTRV9FUlJPUicsXG4gICAgICBtZXNzYWdlOiAnTm90IEpTT04tcGFyc2FibGUgcXVlcnkgcGFyYW1zJyxcbiAgICAgIGNhdXNlLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93bihwYXJzZWQpO1xufVxuIiwiaW1wb3J0IHsgVFJQQ0Vycm9yIH0gZnJvbSAnLi4vZXJyb3IvVFJQQ0Vycm9yJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlVHlwZSB9IGZyb20gJy4uL3Byb2NlZHVyZSc7XG5pbXBvcnQgeyBnZXRQcm9jZWR1cmVBdFBhdGgsIHR5cGUgQW55Um91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVN0cmluZyB9IGZyb20gJy4vcGFyc2VDb25uZWN0aW9uUGFyYW1zJztcbmltcG9ydCB0eXBlIHsgVFJQQ0FjY2VwdEhlYWRlciwgVFJQQ1JlcXVlc3RJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgR2V0UmVxdWVzdEluZm9PcHRpb25zID0ge1xuICBwYXRoOiBzdHJpbmc7XG4gIHJlcTogUmVxdWVzdDtcbiAgdXJsOiBVUkwgfCBudWxsO1xuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcztcbiAgaGVhZGVyczogSGVhZGVycztcbiAgcm91dGVyOiBBbnlSb3V0ZXI7XG59O1xuXG50eXBlIENvbnRlbnRUeXBlSGFuZGxlciA9IHtcbiAgaXNNYXRjaDogKG9wdHM6IFJlcXVlc3QpID0+IGJvb2xlYW47XG4gIHBhcnNlOiAob3B0czogR2V0UmVxdWVzdEluZm9PcHRpb25zKSA9PiBQcm9taXNlPFRSUENSZXF1ZXN0SW5mbz47XG59O1xuXG4vKipcbiAqIE1lbW9pemUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIGFyZ3VtZW50c1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1lbW88VFJldHVybj4oZm46ICgpID0+IFByb21pc2U8VFJldHVybj4pIHtcbiAgbGV0IHByb21pc2U6IFByb21pc2U8VFJldHVybj4gfCBudWxsID0gbnVsbDtcbiAgY29uc3Qgc3ltID0gU3ltYm9sLmZvcignQHRycGMvc2VydmVyL2h0dHAvbWVtbycpO1xuICBsZXQgdmFsdWU6IFRSZXR1cm4gfCB0eXBlb2Ygc3ltID0gc3ltO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIExhemlseSByZWFkIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIHJlYWQ6IGFzeW5jICgpOiBQcm9taXNlPFRSZXR1cm4+ID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gc3ltKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVkdXBlcyBwcm9taXNlcyBhbmQgY2F0Y2hlcyBlcnJvcnNcbiAgICAgIHByb21pc2UgPz89IGZuKCkuY2F0Y2goKGNhdXNlKSA9PiB7XG4gICAgICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikge1xuICAgICAgICAgIHRocm93IGNhdXNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6ICdCQURfUkVRVUVTVCcsXG4gICAgICAgICAgbWVzc2FnZTogY2F1c2UgaW5zdGFuY2VvZiBFcnJvciA/IGNhdXNlLm1lc3NhZ2UgOiAnSW52YWxpZCBpbnB1dCcsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYWxyZWFkeSBzdG9yZWQgcmVzdWx0XG4gICAgICovXG4gICAgcmVzdWx0OiAoKTogVFJldHVybiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHN5bSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gIH07XG59XG5cbmNvbnN0IGpzb25Db250ZW50VHlwZUhhbmRsZXI6IENvbnRlbnRUeXBlSGFuZGxlciA9IHtcbiAgaXNNYXRjaChyZXEpIHtcbiAgICByZXR1cm4gISFyZXEuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpPy5zdGFydHNXaXRoKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIH0sXG4gIGFzeW5jIHBhcnNlKG9wdHMpIHtcbiAgICBjb25zdCB7IHJlcSB9ID0gb3B0cztcbiAgICBjb25zdCBpc0JhdGNoQ2FsbCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnYmF0Y2gnKSA9PT0gJzEnO1xuICAgIGNvbnN0IHBhdGhzID0gaXNCYXRjaENhbGwgPyBvcHRzLnBhdGguc3BsaXQoJywnKSA6IFtvcHRzLnBhdGhdO1xuXG4gICAgdHlwZSBJbnB1dFJlY29yZCA9IFJlY29yZDxudW1iZXIsIHVua25vd24+O1xuICAgIGNvbnN0IGdldElucHV0cyA9IG1lbW8oYXN5bmMgKCk6IFByb21pc2U8SW5wdXRSZWNvcmQ+ID0+IHtcbiAgICAgIGxldCBpbnB1dHM6IHVua25vd24gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgY29uc3QgcXVlcnlJbnB1dCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnaW5wdXQnKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5wdXQpIHtcbiAgICAgICAgICBpbnB1dHMgPSBKU09OLnBhcnNlKHF1ZXJ5SW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dHMgPSBhd2FpdCByZXEuanNvbigpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0JhdGNoQ2FsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIDA6IG9wdHMucm91dGVyLl9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lci5pbnB1dC5kZXNlcmlhbGl6ZShpbnB1dHMpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzT2JqZWN0KGlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICBtZXNzYWdlOiAnXCJpbnB1dFwiIG5lZWRzIHRvIGJlIGFuIG9iamVjdCB3aGVuIGRvaW5nIGEgYmF0Y2ggY2FsbCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYWNjOiBJbnB1dFJlY29yZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBwYXRocy5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dHNbaW5kZXhdO1xuICAgICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFjY1tpbmRleF0gPVxuICAgICAgICAgICAgb3B0cy5yb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLmlucHV0LmRlc2VyaWFsaXplKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY2FsbHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHBhdGhzLm1hcChcbiAgICAgICAgYXN5bmMgKHBhdGgsIGluZGV4KTogUHJvbWlzZTxUUlBDUmVxdWVzdEluZm9bJ2NhbGxzJ11bbnVtYmVyXT4gPT4ge1xuICAgICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBwcm9jZWR1cmUsXG4gICAgICAgICAgICBnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBhd2FpdCBnZXRJbnB1dHMucmVhZCgpO1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9jZWR1cmU/Ll9kZWYudHlwZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0RXZlbnRJZCA9XG4gICAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuZ2V0KCdsYXN0LWV2ZW50LWlkJykgPz9cbiAgICAgICAgICAgICAgICAgIG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnbGFzdEV2ZW50SWQnKSA/P1xuICAgICAgICAgICAgICAgICAgb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KCdMYXN0LUV2ZW50LUlkJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdEV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQ6IGxhc3RFdmVudElkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPz89IHtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZDogbGFzdEV2ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldElucHV0cy5yZXN1bHQoKT8uW2luZGV4XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIGNvbnN0IHR5cGVzID0gbmV3IFNldChcbiAgICAgIGNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSkuZmlsdGVyKEJvb2xlYW4pLFxuICAgICk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLS0gQHByZXNlcnZlICovXG4gICAgaWYgKHR5cGVzLnNpemUgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgbWVzc2FnZTogYENhbm5vdCBtaXggcHJvY2VkdXJlIHR5cGVzIGluIGNhbGw6ICR7QXJyYXkuZnJvbSh0eXBlcykuam9pbihcbiAgICAgICAgICAnLCAnLFxuICAgICAgICApfWAsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdHlwZTogUHJvY2VkdXJlVHlwZSB8ICd1bmtub3duJyA9XG4gICAgICB0eXBlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgPz8gJ3Vua25vd24nO1xuXG4gICAgY29uc3QgY29ubmVjdGlvblBhcmFtc1N0ciA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnY29ubmVjdGlvblBhcmFtcycpO1xuXG4gICAgY29uc3QgaW5mbzogVFJQQ1JlcXVlc3RJbmZvID0ge1xuICAgICAgaXNCYXRjaENhbGwsXG4gICAgICBhY2NlcHQ6IHJlcS5oZWFkZXJzLmdldCgndHJwYy1hY2NlcHQnKSBhcyBUUlBDQWNjZXB0SGVhZGVyIHwgbnVsbCxcbiAgICAgIGNhbGxzLFxuICAgICAgdHlwZSxcbiAgICAgIGNvbm5lY3Rpb25QYXJhbXM6XG4gICAgICAgIGNvbm5lY3Rpb25QYXJhbXNTdHIgPT09IG51bGxcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoY29ubmVjdGlvblBhcmFtc1N0ciksXG4gICAgICBzaWduYWw6IHJlcS5zaWduYWwsXG4gICAgICB1cmw6IG9wdHMudXJsLFxuICAgIH07XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG59O1xuXG5jb25zdCBmb3JtRGF0YUNvbnRlbnRUeXBlSGFuZGxlcjogQ29udGVudFR5cGVIYW5kbGVyID0ge1xuICBpc01hdGNoKHJlcSkge1xuICAgIHJldHVybiAhIXJlcS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk/LnN0YXJ0c1dpdGgoJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcbiAgfSxcbiAgYXN5bmMgcGFyc2Uob3B0cykge1xuICAgIGNvbnN0IHsgcmVxIH0gPSBvcHRzO1xuICAgIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBjb2RlOiAnTUVUSE9EX05PVF9TVVBQT1JURUQnLFxuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSByZXF1ZXN0cycsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmZCA9IGF3YWl0IHJlcS5mb3JtRGF0YSgpO1xuICAgICAgcmV0dXJuIGZkO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgb3B0cy5wYXRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjZXB0OiBudWxsLFxuICAgICAgY2FsbHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6IG9wdHMucGF0aCxcbiAgICAgICAgICBnZXRSYXdJbnB1dDogZ2V0SW5wdXRzLnJlYWQsXG4gICAgICAgICAgcmVzdWx0OiBnZXRJbnB1dHMucmVzdWx0LFxuICAgICAgICAgIHByb2NlZHVyZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBpc0JhdGNoQ2FsbDogZmFsc2UsXG4gICAgICB0eXBlOiAnbXV0YXRpb24nLFxuICAgICAgY29ubmVjdGlvblBhcmFtczogbnVsbCxcbiAgICAgIHNpZ25hbDogcmVxLnNpZ25hbCxcbiAgICAgIHVybDogb3B0cy51cmwsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IG9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyOiBDb250ZW50VHlwZUhhbmRsZXIgPSB7XG4gIGlzTWF0Y2gocmVxKSB7XG4gICAgcmV0dXJuICEhcmVxLmhlYWRlcnNcbiAgICAgIC5nZXQoJ2NvbnRlbnQtdHlwZScpXG4gICAgICA/LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICB9LFxuICBhc3luYyBwYXJzZShvcHRzKSB7XG4gICAgY29uc3QgeyByZXEgfSA9IG9wdHM7XG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgJ09ubHkgUE9TVCByZXF1ZXN0cyBhcmUgc3VwcG9ydGVkIGZvciBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0gcmVxdWVzdHMnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGdldElucHV0cyA9IG1lbW8oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlcS5ib2R5O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsczogW1xuICAgICAgICB7XG4gICAgICAgICAgcGF0aDogb3B0cy5wYXRoLFxuICAgICAgICAgIGdldFJhd0lucHV0OiBnZXRJbnB1dHMucmVhZCxcbiAgICAgICAgICByZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG4gICAgICAgICAgcHJvY2VkdXJlOiBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIG9wdHMucGF0aCksXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgaXNCYXRjaENhbGw6IGZhbHNlLFxuICAgICAgYWNjZXB0OiBudWxsLFxuICAgICAgdHlwZTogJ211dGF0aW9uJyxcbiAgICAgIGNvbm5lY3Rpb25QYXJhbXM6IG51bGwsXG4gICAgICBzaWduYWw6IHJlcS5zaWduYWwsXG4gICAgICB1cmw6IG9wdHMudXJsLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBoYW5kbGVycyA9IFtcbiAganNvbkNvbnRlbnRUeXBlSGFuZGxlcixcbiAgZm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXIsXG4gIG9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyLFxuXTtcblxuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVIYW5kbGVyKHJlcTogUmVxdWVzdCk6IENvbnRlbnRUeXBlSGFuZGxlciB7XG4gIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVycy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyLmlzTWF0Y2gocmVxKSk7XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBpZiAoIWhhbmRsZXIgJiYgcmVxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAvLyBmYWxsYmFjayB0byBKU09OIGZvciBnZXQgcmVxdWVzdHMgc28gR0VULXJlcXVlc3RzIGNhbiBiZSBvcGVuZWQgaW4gYnJvd3NlciBlYXNpbHlcbiAgICByZXR1cm4ganNvbkNvbnRlbnRUeXBlSGFuZGxlcjtcbiAgfVxuXG4gIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgIGNvZGU6ICdVTlNVUFBPUlRFRF9NRURJQV9UWVBFJyxcbiAgICBtZXNzYWdlOiByZXEuaGVhZGVycy5oYXMoJ2NvbnRlbnQtdHlwZScpXG4gICAgICA/IGBVbnN1cHBvcnRlZCBjb250ZW50LXR5cGUgXCIke3JlcS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyl9YFxuICAgICAgOiAnTWlzc2luZyBjb250ZW50LXR5cGUgaGVhZGVyJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZXF1ZXN0SW5mbyhcbiAgb3B0czogR2V0UmVxdWVzdEluZm9PcHRpb25zLFxuKTogUHJvbWlzZTxUUlBDUmVxdWVzdEluZm8+IHtcbiAgY29uc3QgaGFuZGxlciA9IGdldENvbnRlbnRUeXBlSGFuZGxlcihvcHRzLnJlcSk7XG4gIHJldHVybiBhd2FpdCBoYW5kbGVyLnBhcnNlKG9wdHMpO1xufVxuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fib3J0RXJyb3IoXG4gIGVycm9yOiB1bmtub3duLFxuKTogZXJyb3IgaXMgRE9NRXhjZXB0aW9uIHwgRXJyb3IgfCB7IG5hbWU6ICdBYm9ydEVycm9yJyB9IHtcbiAgcmV0dXJuIGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvclsnbmFtZSddID09PSAnQWJvcnRFcnJvcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0Fib3J0RXJyb3IobWVzc2FnZSA9ICdBYm9ydEVycm9yJyk6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihtZXNzYWdlLCAnQWJvcnRFcnJvcicpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG4gXG4gXG5cbmltcG9ydCB0eXBlIHtcbiAgUHJvbWlzZUV4ZWN1dG9yLFxuICBQcm9taXNlV2l0aFJlc29sdmVycyxcbiAgUHJveHlQcm9taXNlLFxuICBTdWJzY3JpYmVkUHJvbWlzZSxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLyoqIE1lbW9yeSBzYWZlICh3ZWFrbWFwcGVkKSBjYWNoZSBvZiB0aGUgUHJveHlQcm9taXNlIGZvciBlYWNoIFByb21pc2UsXG4gKiB3aGljaCBpcyByZXRhaW5lZCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBvcmlnaW5hbCBQcm9taXNlLlxuICovXG5jb25zdCBzdWJzY3JpYmFibGVDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBQcm9taXNlTGlrZTx1bmtub3duPixcbiAgUHJveHlQcm9taXNlPHVua25vd24+XG4+KCk7XG5cbi8qKiBBIE5PT1AgZnVuY3Rpb24gYWxsb3dpbmcgYSBjb25zaXN0ZW50IGludGVyZmFjZSBmb3Igc2V0dGxlZFxuICogU3Vic2NyaWJlZFByb21pc2VzIChzZXR0bGVkIHByb21pc2VzIGFyZSBub3Qgc3Vic2NyaWJlZCAtIHRoZXkgcmVzb2x2ZVxuICogaW1tZWRpYXRlbHkpLiAqL1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbiAgLy8gbm9vcFxufTtcblxuLyoqXG4gKiBFdmVyeSBgUHJvbWlzZTxUPmAgY2FuIGJlIHNoYWRvd2VkIGJ5IGEgc2luZ2xlIGBQcm94eVByb21pc2U8VD5gLiBJdCBpc1xuICogY3JlYXRlZCBvbmNlLCBjYWNoZWQgYW5kIHJldXNlZCB0aHJvdWdob3V0IHRoZSBsaWZldGltZSBvZiB0aGUgUHJvbWlzZS4gR2V0IGFcbiAqIFByb21pc2UncyBQcm94eVByb21pc2UgdXNpbmcgYFVucHJvbWlzZS5wcm94eShwcm9taXNlKWAuXG4gKlxuICogVGhlIGBQcm94eVByb21pc2U8VD5gIGF0dGFjaGVzIGhhbmRsZXJzIHRvIHRoZSBvcmlnaW5hbCBgUHJvbWlzZTxUPmBcbiAqIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBqdXN0IG9uY2UuIFByb21pc2VzIGRlcml2ZWQgZnJvbSBpdCB1c2UgYVxuICogc3Vic2NyaXB0aW9uLSAoYW5kIHVuc3Vic2NyaXB0aW9uLSkgYmFzZWQgbWVjaGFuaXNtIHRoYXQgbW9uaXRvcnMgdGhlc2VcbiAqIGhhbmRsZXJzLlxuICpcbiAqIEV2ZXJ5IHRpbWUgeW91IGNhbGwgYC5zdWJzY3JpYmUoKWAsIGAudGhlbigpYCBgLmNhdGNoKClgIG9yIGAuZmluYWxseSgpYCBvbiBhXG4gKiBgUHJveHlQcm9taXNlPFQ+YCBpdCByZXR1cm5zIGEgYFN1YnNjcmliZWRQcm9taXNlPFQ+YCBoYXZpbmcgYW4gYWRkaXRpb25hbFxuICogYHVuc3Vic2NyaWJlKClgIG1ldGhvZC4gQ2FsbGluZyBgdW5zdWJzY3JpYmUoKWAgZGV0YWNoZXMgcmVmZXJlbmNlIGNoYWluc1xuICogZnJvbSB0aGUgb3JpZ2luYWwsIHBvdGVudGlhbGx5IGxvbmctbGl2ZWQgUHJvbWlzZSwgZWxpbWluYXRpbmcgbWVtb3J5IGxlYWtzLlxuICpcbiAqIFRoaXMgYXBwcm9hY2ggY2FuIGVsaW1pbmF0ZSB0aGUgbWVtb3J5IGxlYWtzIHRoYXQgb3RoZXJ3aXNlIGNvbWUgYWJvdXQgZnJvbVxuICogcmVwZWF0ZWQgYHJhY2UoKWAgb3IgYGFueSgpYCBjYWxscyBpbnZva2luZyBgLnRoZW4oKWAgYW5kIGAuY2F0Y2goKWAgbXVsdGlwbGVcbiAqIHRpbWVzIG9uIHRoZSBzYW1lIGxvbmctbGl2ZWQgbmF0aXZlIFByb21pc2UgKHN1YnNjcmlwdGlvbnMgd2hpY2ggY2FuIG5ldmVyIGJlXG4gKiBjbGVhbmVkIHVwKS5cbiAqXG4gKiBgVW5wcm9taXNlLnJhY2UocHJvbWlzZXMpYCBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBgUHJvbWlzZS5yYWNlYFxuICogYXZvaWRpbmcgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgbG9uZy1saXZlZCB1bnNldHRsZWQgUHJvbWlzZXMuXG4gKlxuICogYFVucHJvbWlzZS5hbnkocHJvbWlzZXMpYCBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBgUHJvbWlzZS5hbnlgXG4gKiBhdm9pZGluZyBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyBsb25nLWxpdmVkIHVuc2V0dGxlZCBQcm9taXNlcy5cbiAqXG4gKiBgVW5wcm9taXNlLnJlc29sdmUocHJvbWlzZSlgIHJldHVybnMgYW4gZXBoZW1lcmFsIGBTdWJzY3JpYmVkUHJvbWlzZTxUPmAgZm9yXG4gKiBhbnkgZ2l2ZW4gYFByb21pc2U8VD5gIGZhY2lsaXRhdGluZyBhcmJpdHJhcnkgYXN5bmMvYXdhaXQgcGF0dGVybnMuIEJlaGluZFxuICogdGhlIHNjZW5lcywgYHJlc29sdmVgIGlzIGltcGxlbWVudGVkIHNpbXBseSBhc1xuICogYFVucHJvbWlzZS5wcm94eShwcm9taXNlKS5zdWJzY3JpYmUoKWAuIERvbid0IGZvcmdldCB0byBjYWxsIGAudW5zdWJzY3JpYmUoKWBcbiAqIHRvIHRpZHkgdXAhXG4gKlxuICovXG5leHBvcnQgY2xhc3MgVW5wcm9taXNlPFQ+IGltcGxlbWVudHMgUHJveHlQcm9taXNlPFQ+IHtcbiAgLyoqIElOU1RBTkNFIElNUExFTUVOVEFUSU9OICovXG5cbiAgLyoqIFRoZSBwcm9taXNlIHNoYWRvd2VkIGJ5IHRoaXMgVW5wcm9taXNlPFQ+ICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPiB8IFByb21pc2VMaWtlPFQ+O1xuXG4gIC8qKiBQcm9taXNlcyBleHBlY3RpbmcgZXZlbnR1YWwgc2V0dGxlbWVudCAodW5sZXNzIHVuc3Vic2NyaWJlZCBmaXJzdCkuIFRoaXMgbGlzdCBpcyBkZWxldGVkXG4gICAqIGFmdGVyIHRoZSBvcmlnaW5hbCBwcm9taXNlIHNldHRsZXMgLSBubyBmdXJ0aGVyIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBpc3N1ZWQuICovXG4gIHByb3RlY3RlZCBzdWJzY3JpYmVyczogUmVhZG9ubHlBcnJheTxQcm9taXNlV2l0aFJlc29sdmVyczxUPj4gfCBudWxsID0gW107XG5cbiAgLyoqIFRoZSBQcm9taXNlJ3Mgc2V0dGxlbWVudCAocmVjb3JkZWQgd2hlbiBpdCBmdWxmaWxzIG9yIHJlamVjdHMpLiBUaGlzIGlzIGNvbnN1bHRlZCB3aGVuXG4gICAqIGNhbGxpbmcgLnN1YnNjcmliZSgpIC50aGVuKCkgLmNhdGNoKCkgLmZpbmFsbHkoKSB0byBzZWUgaWYgYW4gaW1tZWRpYXRlbHktcmVzb2x2aW5nIFByb21pc2VcbiAgICogY2FuIGJlIHJldHVybmVkLCBhbmQgdGhlcmVmb3JlIHN1YnNjcmlwdGlvbiBjYW4gYmUgYnlwYXNzZWQuICovXG4gIHByb3RlY3RlZCBzZXR0bGVtZW50OiBQcm9taXNlU2V0dGxlZFJlc3VsdDxUPiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBDb25zdHJ1Y3RvciBhY2NlcHRzIGEgbm9ybWFsIFByb21pc2UgZXhlY3V0b3IgZnVuY3Rpb24gbGlrZSBgbmV3XG4gICAqIFVucHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7Li4ufSlgIG9yIGFjY2VwdHMgYSBwcmUtZXhpc3RpbmcgUHJvbWlzZVxuICAgKiBsaWtlIGBuZXcgVW5wcm9taXNlKGV4aXN0aW5nUHJvbWlzZSlgLiBBZGRzIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYFxuICAgKiBoYW5kbGVycyB0byB0aGUgUHJvbWlzZS4gVGhlc2UgaGFuZGxlcnMgcGFzcyBmdWxmaWxtZW50IGFuZCByZWplY3Rpb25cbiAgICogbm90aWZpY2F0aW9ucyB0byBkb3duc3RyZWFtIHN1YnNjcmliZXJzIGFuZCBtYWludGFpbnMgcmVjb3JkcyBvZiB2YWx1ZVxuICAgKiBvciBlcnJvciBpZiB0aGUgUHJvbWlzZSBldmVyIHNldHRsZXMuICovXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihwcm9taXNlOiBQcm9taXNlPFQ+KTtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb21pc2U6IFByb21pc2VMaWtlPFQ+KTtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGV4ZWN1dG9yOiBQcm9taXNlRXhlY3V0b3I8VD4pO1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYXJnOiBQcm9taXNlPFQ+IHwgUHJvbWlzZUxpa2U8VD4gfCBQcm9taXNlRXhlY3V0b3I8VD4pIHtcbiAgICAvLyBoYW5kbGUgZWl0aGVyIGEgUHJvbWlzZSBvciBhIFByb21pc2UgZXhlY3V0b3IgZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb21pc2UgPSBhcmc7XG4gICAgfVxuXG4gICAgLy8gc3Vic2NyaWJlIGZvciBldmVudHVhbCBmdWxmaWxtZW50IGFuZCByZWplY3Rpb25cblxuICAgIC8vIGhhbmRsZSBQcm9taXNlTGlrZSBvYmplY3RzICh0aGF0IGF0IGxlYXN0IGhhdmUgLnRoZW4pXG4gICAgY29uc3QgdGhlblJldHVybiA9IHRoaXMucHJvbWlzZS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgLy8gYXRvbWljYWxseSByZWNvcmQgZnVsZmlsbWVudCBhbmQgZGV0YWNoIHN1YnNjcmliZXIgbGlzdFxuICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gdGhpcztcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBudWxsO1xuICAgICAgdGhpcy5zZXR0bGVtZW50ID0ge1xuICAgICAgICBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfTtcbiAgICAgIC8vIG5vdGlmeSBmdWxmaWxtZW50IHRvIHN1YnNjcmliZXIgbGlzdFxuICAgICAgc3Vic2NyaWJlcnM/LmZvckVhY2goKHsgcmVzb2x2ZSB9KSA9PiB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgUHJvbWlzZSAodGhhdCBhbHNvIGhhdmUgYSAuY2F0Y2ggYmVoYXZpb3VyKVxuICAgIGlmIChcImNhdGNoXCIgaW4gdGhlblJldHVybikge1xuICAgICAgdGhlblJldHVybi5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIC8vIGF0b21pY2FsbHkgcmVjb3JkIHJlamVjdGlvbiBhbmQgZGV0YWNoIHN1YnNjcmliZXIgbGlzdFxuICAgICAgICBjb25zdCB7IHN1YnNjcmliZXJzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXR0bGVtZW50ID0ge1xuICAgICAgICAgIHN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbm90aWZ5IHJlamVjdGlvbiB0byBzdWJzY3JpYmVyIGxpc3RcbiAgICAgICAgc3Vic2NyaWJlcnM/LmZvckVhY2goKHsgcmVqZWN0IH0pID0+IHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IG1pdGlnYXRlcyB1bmNvbnRyb2xsZWQgc3Vic2NyaXB0aW9uIHRvIGEgbG9uZy1saXZlZFxuICAgKiBQcm9taXNlIHZpYSAudGhlbigpIGFuZCAuY2F0Y2goKSAtIG90aGVyd2lzZSBhIHNvdXJjZSBvZiBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIGhhcyBhbiBgdW5zdWJzY3JpYmUoKWAgbWV0aG9kIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2hlblxuICAgKiB0aGUgUHJvbWlzZSBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZCBieSBhcHBsaWNhdGlvbiBsb2dpYywgYW5kIHdoaWNoXG4gICAqIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBubyByZWZlcmVuY2UgY2hhaW4gZnJvbSB0aGUgb3JpZ2luYWwgcHJvbWlzZSB0byB0aGVcbiAgICogbmV3IG9uZSwgYW5kIHRoZXJlZm9yZSBubyBtZW1vcnkgbGVhay5cbiAgICpcbiAgICogSWYgb3JpZ2luYWwgcHJvbWlzZSBoYXMgbm90IHlldCBzZXR0bGVkLCB0aGlzIGFkZHMgYSBuZXcgdW5pcXVlIHByb21pc2VcbiAgICogdGhhdCBsaXN0ZW5zIHRvIHRoZW4vY2F0Y2ggZXZlbnRzLCBhbG9uZyB3aXRoIGFuIGB1bnN1YnNjcmliZSgpYCBtZXRob2QgdG9cbiAgICogZGV0YWNoIGl0LlxuICAgKlxuICAgKiBJZiBvcmlnaW5hbCBwcm9taXNlIGhhcyBzZXR0bGVkLCB0aGVuIGNyZWF0ZXMgYSBuZXcgUHJvbWlzZS5yZXNvbHZlKCkgb3JcbiAgICogUHJvbWlzZS5yZWplY3QoKSBhbmQgcHJvdmlkZWQgdW5zdWJzY3JpYmUgaXMgYSBub29wLlxuICAgKlxuICAgKiBJZiB5b3UgY2FsbCBgdW5zdWJzY3JpYmUoKWAgYmVmb3JlIHRoZSByZXR1cm5lZCBQcm9taXNlIGhhcyBzZXR0bGVkLCBpdFxuICAgKiB3aWxsIG5ldmVyIHNldHRsZS5cbiAgICovXG4gIHN1YnNjcmliZSgpOiBTdWJzY3JpYmVkUHJvbWlzZTxUPiB7XG4gICAgLy8gaW4gYWxsIGNhc2VzIHdlIHdpbGwgY29tYmluZSBzb21lIHByb21pc2Ugd2l0aCBpdHMgdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgICBsZXQgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQ7XG5cbiAgICBjb25zdCB7IHNldHRsZW1lbnQgfSA9IHRoaXM7XG4gICAgaWYgKHNldHRsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vdCB5ZXQgc2V0dGxlZCAtIHN1YnNjcmliZSBuZXcgcHJvbWlzZS4gRXhwZWN0IGV2ZW50dWFsIHNldHRsZW1lbnRcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJzID09PSBudWxsKSB7XG4gICAgICAgIC8vIGludmFyaWFudCAtIGl0IGlzIG5vdCBzZXR0bGVkLCBzbyBpdCBtdXN0IGhhdmUgc3Vic2NyaWJlcnNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5wcm9taXNlIHNldHRsZWQgYnV0IHN0aWxsIGhhcyBzdWJzY3JpYmVyc1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB3aXRoUmVzb2x2ZXJzPFQ+KCk7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzID0gbGlzdFdpdGhNZW1iZXIodGhpcy5zdWJzY3JpYmVycywgc3Vic2NyaWJlcik7XG4gICAgICBwcm9taXNlID0gc3Vic2NyaWJlci5wcm9taXNlO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRob3V0TWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXR0bGVkIC0gZG9uJ3QgY3JlYXRlIHN1YnNjcmliZWQgcHJvbWlzZS4gSnVzdCByZXNvbHZlIG9yIHJlamVjdFxuICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHNldHRsZW1lbnQ7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc2V0dGxlbWVudC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3Qoc2V0dGxlbWVudC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgdW5zdWJzY3JpYmUgPSBOT09QO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBwcm9taXNlIHNpZ25hdHVyZSB3aXRoIHRoZSBleHRyYSBtZXRob2RcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7IHVuc3Vic2NyaWJlIH0pO1xuICB9XG5cbiAgLyoqIFNUQU5EQVJEIFBST01JU0UgTUVUSE9EUyAoYnV0IHJldHVybmluZyBhIFN1YnNjcmliZWRQcm9taXNlKSAqL1xuXG4gIHRoZW48VFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgICBvbmZ1bGZpbGxlZD86XG4gICAgICB8ICgodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KVxuICAgICAgfCBudWxsXG4gICAgICAgLFxuICAgIG9ucmVqZWN0ZWQ/OlxuICAgICAgfCAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPilcbiAgICAgIHwgbnVsbFxuICAgICAgIFxuICApOiBTdWJzY3JpYmVkUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgY29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpLCB7XG4gICAgICB1bnN1YnNjcmliZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG4gICAgb25yZWplY3RlZD86XG4gICAgICB8ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PilcbiAgICAgIHwgbnVsbFxuICAgICAgIFxuICApOiBTdWJzY3JpYmVkUHJvbWlzZTxUIHwgVFJlc3VsdD4ge1xuICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLnN1YnNjcmliZSgpO1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHN1YnNjcmliZWQ7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3Vic2NyaWJlZC5jYXRjaChvbnJlamVjdGVkKSwge1xuICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfSk7XG4gIH1cblxuICBmaW5hbGx5KG9uZmluYWxseT86ICgoKSA9PiB2b2lkKSB8IG51bGwgICk6IFN1YnNjcmliZWRQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5zdWJzY3JpYmUoKTtcbiAgICBjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBzdWJzY3JpYmVkO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN1YnNjcmliZWQuZmluYWxseShvbmZpbmFsbHkpLCB7XG4gICAgICB1bnN1YnNjcmliZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUT1NUUklORyBTVVBQT1JUICovXG5cbiAgcmVhZG9ubHkgW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIlVucHJvbWlzZVwiO1xuXG4gIC8qKiBVbnByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblxuICAvKiogQ3JlYXRlIG9yIFJldHJpZXZlIHRoZSBwcm94eSBVbnByb21pc2UgKGEgcmUtdXNlZCBVbnByb21pc2UgZm9yIHRoZSBWTSBsaWZldGltZVxuICAgKiBvZiB0aGUgcHJvdmlkZWQgUHJvbWlzZSByZWZlcmVuY2UpICovXG4gIHN0YXRpYyBwcm94eTxUPihwcm9taXNlOiBQcm9taXNlTGlrZTxUPik6IFByb3h5UHJvbWlzZTxUPiB7XG4gICAgY29uc3QgY2FjaGVkID0gVW5wcm9taXNlLmdldFN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSk7XG4gICAgcmV0dXJuIHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgID8gY2FjaGVkXG4gICAgICA6IFVucHJvbWlzZS5jcmVhdGVTdWJzY3JpYmFibGVQcm9taXNlKHByb21pc2UpO1xuICB9XG5cbiAgLyoqIENyZWF0ZSBhbmQgc3RvcmUgYW4gVW5wcm9taXNlIGtleWVkIGJ5IGFuIG9yaWdpbmFsIFByb21pc2UuICovXG4gIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlU3Vic2NyaWJhYmxlUHJvbWlzZTxUPihwcm9taXNlOiBQcm9taXNlTGlrZTxUPikge1xuICAgIGNvbnN0IGNyZWF0ZWQgPSBuZXcgVW5wcm9taXNlPFQ+KHByb21pc2UpO1xuICAgIHN1YnNjcmliYWJsZUNhY2hlLnNldChwcm9taXNlLCBjcmVhdGVkIGFzIFVucHJvbWlzZTx1bmtub3duPik7IC8vIHJlc29sdmUgcHJvbWlzZSB0byB1bnByb21pc2VcbiAgICBzdWJzY3JpYmFibGVDYWNoZS5zZXQoY3JlYXRlZCwgY3JlYXRlZCBhcyBVbnByb21pc2U8dW5rbm93bj4pOyAvLyByZXNvbHZlIHRoZSB1bnByb21pc2UgdG8gaXRzZWxmXG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvKiogUmV0cmlldmUgYSBwcmV2aW91c2x5LWNyZWF0ZWQgVW5wcm9taXNlIGtleWVkIGJ5IGFuIG9yaWdpbmFsIFByb21pc2UuICovXG4gIHByb3RlY3RlZCBzdGF0aWMgZ2V0U3Vic2NyaWJhYmxlUHJvbWlzZTxUPihwcm9taXNlOiBQcm9taXNlTGlrZTxUPikge1xuICAgIHJldHVybiBzdWJzY3JpYmFibGVDYWNoZS5nZXQocHJvbWlzZSkgYXMgUHJveHlQcm9taXNlPFQ+IHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIFByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblxuICAvKiogTG9va3VwIHRoZSBVbnByb21pc2UgZm9yIHRoaXMgcHJvbWlzZSwgYW5kIGRlcml2ZSBhIFN1YnNjcmliZWRQcm9taXNlIGZyb21cbiAgICogaXQgKHRoYXQgY2FuIGJlIGxhdGVyIHVuc3Vic2NyaWJlZCB0byBlbGltaW5hdGUgTWVtb3J5IGxlYWtzKSAqL1xuICBzdGF0aWMgcmVzb2x2ZTxUPih2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSB7XG4gICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZUxpa2U8VD4gPVxuICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgXCJ0aGVuXCIgaW4gdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS5zdWJzY3JpYmUoKSBhcyBTdWJzY3JpYmVkUHJvbWlzZTxcbiAgICAgIEF3YWl0ZWQ8VD5cbiAgICA+O1xuICB9XG5cbiAgLyoqIFBlcmZvcm0gUHJvbWlzZS5hbnkoKSB2aWEgU3Vic2NyaWJlZFByb21pc2VzLCB0aGVuIHVuc3Vic2NyaWJlIHRoZW0uXG4gICAqIEVxdWl2YWxlbnQgdG8gUHJvbWlzZS5hbnkgYnV0IGVsaW1pbmF0ZXMgbWVtb3J5IGxlYWtzIGZyb20gbG9uZy1saXZlZFxuICAgKiBwcm9taXNlcyBhY2N1bXVsYXRpbmcgLnRoZW4oKSBhbmQgLmNhdGNoKCkgc3Vic2NyaWJlcnMuICovXG4gIHN0YXRpYyBhc3luYyBhbnk8VCBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXSB8IFtdPihcbiAgICB2YWx1ZXM6IFRcbiAgKTogUHJvbWlzZTxBd2FpdGVkPFRbbnVtYmVyXT4+O1xuICBzdGF0aWMgYXN5bmMgYW55PFQ+KFxuICAgIHZhbHVlczogSXRlcmFibGU8VCB8IFByb21pc2VMaWtlPFQ+PlxuICApOiBQcm9taXNlPEF3YWl0ZWQ8VD4+IHtcbiAgICBjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFsuLi52YWx1ZXNdO1xuICAgIGNvbnN0IHN1YnNjcmliZWRQcm9taXNlcyA9IHZhbHVlc0FycmF5Lm1hcChVbnByb21pc2UucmVzb2x2ZSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFueShzdWJzY3JpYmVkUHJvbWlzZXMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzdWJzY3JpYmVkUHJvbWlzZXMuZm9yRWFjaCgoeyB1bnN1YnNjcmliZSB9KSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogUGVyZm9ybSBQcm9taXNlLnJhY2UgdmlhIFN1YnNjcmliZWRQcm9taXNlcywgdGhlbiB1bnN1YnNjcmliZSB0aGVtLlxuICAgKiBFcXVpdmFsZW50IHRvIFByb21pc2UucmFjZSBidXQgZWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkXG4gICAqIHByb21pc2VzIGFjY3VtdWxhdGluZyAudGhlbigpIGFuZCAuY2F0Y2goKSBzdWJzY3JpYmVycy4gKi9cbiAgc3RhdGljIGFzeW5jIHJhY2U8VCBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXSB8IFtdPihcbiAgICB2YWx1ZXM6IFRcbiAgKTogUHJvbWlzZTxBd2FpdGVkPFRbbnVtYmVyXT4+O1xuICBzdGF0aWMgYXN5bmMgcmFjZTxUPihcbiAgICB2YWx1ZXM6IEl0ZXJhYmxlPFQgfCBQcm9taXNlTGlrZTxUPj5cbiAgKTogUHJvbWlzZTxBd2FpdGVkPFQ+PiB7XG4gICAgY29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbLi4udmFsdWVzXTtcbiAgICBjb25zdCBzdWJzY3JpYmVkUHJvbWlzZXMgPSB2YWx1ZXNBcnJheS5tYXAoVW5wcm9taXNlLnJlc29sdmUpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKHN1YnNjcmliZWRQcm9taXNlcyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHN1YnNjcmliZWRQcm9taXNlcy5mb3JFYWNoKCh7IHVuc3Vic2NyaWJlIH0pID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgYSByYWNlIG9mIFN1YnNjcmliZWRQcm9taXNlcyB0aGF0IHdpbGwgZnVsZmlsIHRvIGEgc2luZ2xlIHdpbm5pbmdcbiAgICogUHJvbWlzZSAoaW4gYSAxLVR1cGxlKS4gRWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkIHByb21pc2VzXG4gICAqIGFjY3VtdWxhdGluZyAudGhlbigpIGFuZCAuY2F0Y2goKSBzdWJzY3JpYmVycy4gQWxsb3dzIHNpbXBsZSBsb2dpYyB0b1xuICAgKiBjb25zdW1lIHRoZSByZXN1bHQsIGxpa2UuLi5cbiAgICogYGBgdHNcbiAgICogY29uc3QgWyB3aW5uZXIgXSA9IGF3YWl0IFVucHJvbWlzZS5yYWNlKFsgcHJvbWlzZUEsIHByb21pc2VCIF0pO1xuICAgKiBpZih3aW5uZXIgPT09IHByb21pc2VCKXtcbiAgICogICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlQjtcbiAgICogICAvLyBkbyB0aGUgdGhpbmdcbiAgICogfVxuICAgKiBgYGBcbiAgICogKi9cbiAgc3RhdGljIGFzeW5jIHJhY2VSZWZlcmVuY2VzPFRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTx1bmtub3duPj4oXG4gICAgcHJvbWlzZXM6IHJlYWRvbmx5IFRQcm9taXNlW11cbiAgKSB7XG4gICAgLy8gbWFwIGVhY2ggcHJvbWlzZSB0byBhbiBldmVudHVhbCAxLXR1cGxlIGNvbnRhaW5pbmcgaXRzZWxmXG4gICAgY29uc3Qgc2VsZlByb21pc2VzID0gcHJvbWlzZXMubWFwKHJlc29sdmVTZWxmVHVwbGUpO1xuXG4gICAgLy8gbm93IHJhY2UgdGhlbS4gVGhleSB3aWxsIGZ1bGZpbCB0byBhIHJlYWRvbmx5IFtQXSBvciByZWplY3QuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2Uoc2VsZlByb21pc2VzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHNlbGZQcm9taXNlcykge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBwcm94eSBwcm9taXNlcyB3aGVuIHRoZSByYWNlIGlzIG92ZXIgdG8gbWl0aWdhdGUgbWVtb3J5IGxlYWtzXG4gICAgICAgIHByb21pc2UudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIFByb21pc2VzIGEgMS10dXBsZSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBwcm9taXNlIHdoZW4gaXQgcmVzb2x2ZXMuIEFsbG93c1xuICogYXdhaXRpbmcgdGhlIGV2ZW50dWFsIFByb21pc2UgKioqcmVmZXJlbmNlKioqIChlYXN5IHRvIGRlc3RydWN0dXJlIGFuZFxuICogZXhhY3RseSBjb21wYXJlIHdpdGggPT09KS4gQXZvaWRzIHJlc29sdmluZyB0byB0aGUgUHJvbWlzZSAqKip2YWx1ZSoqKiAod2hpY2hcbiAqIG1heSBiZSBhbWJpZ3VvdXMgYW5kIHRoZXJlZm9yZSBoYXJkIHRvIGlkZW50aWZ5IGFzIHRoZSB3aW5uZXIgb2YgYSByYWNlKS5cbiAqIFlvdSBjYW4gY2FsbCB1bnN1YnNjcmliZSBvbiB0aGUgUHJvbWlzZSB0byBtaXRpZ2F0ZSBtZW1vcnkgbGVha3MuXG4gKiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVTZWxmVHVwbGU8VFByb21pc2UgZXh0ZW5kcyBQcm9taXNlPHVua25vd24+PihcbiAgcHJvbWlzZTogVFByb21pc2Vcbik6IFN1YnNjcmliZWRQcm9taXNlPHJlYWRvbmx5IFtUUHJvbWlzZV0+IHtcbiAgcmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS50aGVuKCgpID0+IFtwcm9taXNlXSBhcyBjb25zdCk7XG59XG5cbi8qKiBWRU5ET1JFRCAoRnV0dXJlKSBQUk9NSVNFIFVUSUxJVElFUyAqL1xuXG4vKiogUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2Utd2l0aC1yZXNvbHZlcnMgKi9cbmZ1bmN0aW9uIHdpdGhSZXNvbHZlcnM8VD4oKTogUHJvbWlzZVdpdGhSZXNvbHZlcnM8VD4ge1xuICBsZXQgcmVzb2x2ZSE6IFByb21pc2VXaXRoUmVzb2x2ZXJzPFQ+W1wicmVzb2x2ZVwiXTtcbiAgbGV0IHJlamVjdCE6IFByb21pc2VXaXRoUmVzb2x2ZXJzPFQ+W1wicmVqZWN0XCJdO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgIHJlamVjdCA9IF9yZWplY3Q7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3QsXG4gIH07XG59XG5cbi8qKiBJTU1VVEFCTEUgTElTVCBPUEVSQVRJT05TICovXG5cbmZ1bmN0aW9uIGxpc3RXaXRoTWVtYmVyPFQ+KGFycjogcmVhZG9ubHkgVFtdLCBtZW1iZXI6IFQpOiByZWFkb25seSBUW10ge1xuICByZXR1cm4gWy4uLmFyciwgbWVtYmVyXTtcbn1cblxuZnVuY3Rpb24gbGlzdFdpdGhvdXRJbmRleDxUPihhcnI6IHJlYWRvbmx5IFRbXSwgaW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gWy4uLmFyci5zbGljZSgwLCBpbmRleCksIC4uLmFyci5zbGljZShpbmRleCArIDEpXTtcbn1cblxuZnVuY3Rpb24gbGlzdFdpdGhvdXRNZW1iZXI8VD4oYXJyOiByZWFkb25seSBUW10sIG1lbWJlcjogdW5rbm93bikge1xuICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKG1lbWJlciBhcyBUKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBsaXN0V2l0aG91dEluZGV4KGFyciwgaW5kZXgpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG4iLCIvLyBAdHMtZXhwZWN0LWVycm9yIC0gcG9seWZpbGxpbmcgc3ltYm9sXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblN5bWJvbC5kaXNwb3NlID8/PSBTeW1ib2woKTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvciAtIHBvbHlmaWxsaW5nIHN5bWJvbFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5TeW1ib2wuYXN5bmNEaXNwb3NlID8/PSBTeW1ib2woKTtcblxuLyoqXG4gKiBUYWtlcyBhIHZhbHVlIGFuZCBhIGRpc3Bvc2UgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgRGlzcG9zYWJsZSBpbnRlcmZhY2UuXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCB2YWx1ZSBhdWdtZW50ZWQgd2l0aCBhIFN5bWJvbC5kaXNwb3NlIG1ldGhvZC5cbiAqIEBwYXJhbSB0aGluZyBUaGUgdmFsdWUgdG8gbWFrZSBkaXNwb3NhYmxlXG4gKiBAcGFyYW0gZGlzcG9zZSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZGlzcG9zaW5nIHRoZSByZXNvdXJjZVxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmRpc3Bvc2UgbWV0aG9kIGFkZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVzb3VyY2U8VD4odGhpbmc6IFQsIGRpc3Bvc2U6ICgpID0+IHZvaWQpOiBUICYgRGlzcG9zYWJsZSB7XG4gIGNvbnN0IGl0ID0gdGhpbmcgYXMgVCAmIFBhcnRpYWw8RGlzcG9zYWJsZT47XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmRpc3Bvc2VdO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICBpdFtTeW1ib2wuZGlzcG9zZV0gPSAoKSA9PiB7XG4gICAgZGlzcG9zZSgpO1xuICAgIGV4aXN0aW5nPy4oKTtcbiAgfTtcblxuICByZXR1cm4gaXQgYXMgVCAmIERpc3Bvc2FibGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSB2YWx1ZSBhbmQgYW4gYXN5bmMgZGlzcG9zZSBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBBc3luY0Rpc3Bvc2FibGUgaW50ZXJmYWNlLlxuICogVGhlIHJldHVybmVkIG9iamVjdCBpcyB0aGUgb3JpZ2luYWwgdmFsdWUgYXVnbWVudGVkIHdpdGggYSBTeW1ib2wuYXN5bmNEaXNwb3NlIG1ldGhvZC5cbiAqIEBwYXJhbSB0aGluZyBUaGUgdmFsdWUgdG8gbWFrZSBhc3luYyBkaXNwb3NhYmxlXG4gKiBAcGFyYW0gZGlzcG9zZSBBc3luYyBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZGlzcG9zaW5nIHRoZSByZXNvdXJjZVxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmFzeW5jRGlzcG9zZSBtZXRob2QgYWRkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3luY1Jlc291cmNlPFQ+KFxuICB0aGluZzogVCxcbiAgZGlzcG9zZTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbik6IFQgJiBBc3luY0Rpc3Bvc2FibGUge1xuICBjb25zdCBpdCA9IHRoaW5nIGFzIFQgJiBQYXJ0aWFsPEFzeW5jRGlzcG9zYWJsZT47XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGl0W1N5bWJvbC5hc3luY0Rpc3Bvc2VdID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRpc3Bvc2UoKTtcbiAgICBhd2FpdCBleGlzdGluZz8uKCk7XG4gIH07XG5cbiAgcmV0dXJuIGl0IGFzIFQgJiBBc3luY0Rpc3Bvc2FibGU7XG59XG4iLCJpbXBvcnQgeyBtYWtlUmVzb3VyY2UgfSBmcm9tICcuL2Rpc3Bvc2FibGUnO1xuXG5leHBvcnQgY29uc3QgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCA9IFN5bWJvbCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJSZXNvdXJjZShtczogbnVtYmVyKSB7XG4gIGxldCB0aW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCBudWxsID0gbnVsbDtcblxuICByZXR1cm4gbWFrZVJlc291cmNlKFxuICAgIHtcbiAgICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVyIGFscmVhZHkgc3RhcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0PihcbiAgICAgICAgICAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCksIG1zKTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9LFxuICApO1xufVxuIiwiZnVuY3Rpb24gX3VzaW5nQ3R4KCkge1xuICB2YXIgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKHIsIGUpIHtcbiAgICAgIHZhciBuID0gRXJyb3IoKTtcbiAgICAgIHJldHVybiBuLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBuLmVycm9yID0gciwgbi5zdXBwcmVzc2VkID0gZSwgbjtcbiAgICB9LFxuICAgIGUgPSB7fSxcbiAgICBuID0gW107XG4gIGZ1bmN0aW9uIHVzaW5nKHIsIGUpIHtcbiAgICBpZiAobnVsbCAhPSBlKSB7XG4gICAgICBpZiAoT2JqZWN0KGUpICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNpbmcgZGVjbGFyYXRpb25zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBvYmplY3RzLCBmdW5jdGlvbnMsIG51bGwsIG9yIHVuZGVmaW5lZC5cIik7XG4gICAgICBpZiAocikgdmFyIG8gPSBlW1N5bWJvbC5hc3luY0Rpc3Bvc2UgfHwgU3ltYm9sW1wiZm9yXCJdKFwiU3ltYm9sLmFzeW5jRGlzcG9zZVwiKV07XG4gICAgICBpZiAodm9pZCAwID09PSBvICYmIChvID0gZVtTeW1ib2wuZGlzcG9zZSB8fCBTeW1ib2xbXCJmb3JcIl0oXCJTeW1ib2wuZGlzcG9zZVwiKV0sIHIpKSB2YXIgdCA9IG87XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICAgIHQgJiYgKG8gPSBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHQuY2FsbChlKTtcbiAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgfVxuICAgICAgfSksIG4ucHVzaCh7XG4gICAgICAgIHY6IGUsXG4gICAgICAgIGQ6IG8sXG4gICAgICAgIGE6IHJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSByICYmIG4ucHVzaCh7XG4gICAgICBkOiBlLFxuICAgICAgYTogclxuICAgIH0pO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZTogZSxcbiAgICB1OiB1c2luZy5iaW5kKG51bGwsICExKSxcbiAgICBhOiB1c2luZy5iaW5kKG51bGwsICEwKSxcbiAgICBkOiBmdW5jdGlvbiBkKCkge1xuICAgICAgdmFyIG8sXG4gICAgICAgIHQgPSB0aGlzLmUsXG4gICAgICAgIHMgPSAwO1xuICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgZm9yICg7IG8gPSBuLnBvcCgpOykgdHJ5IHtcbiAgICAgICAgICBpZiAoIW8uYSAmJiAxID09PSBzKSByZXR1cm4gcyA9IDAsIG4ucHVzaChvKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcbiAgICAgICAgICBpZiAoby5kKSB7XG4gICAgICAgICAgICB2YXIgciA9IG8uZC5jYWxsKG8udik7XG4gICAgICAgICAgICBpZiAoby5hKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocikudGhlbihuZXh0LCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSBzIHw9IDE7XG4gICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICByZXR1cm4gZXJyKHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgxID09PSBzKSByZXR1cm4gdCAhPT0gZSA/IFByb21pc2UucmVqZWN0KHQpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICh0ICE9PSBlKSB0aHJvdyB0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXJyKG4pIHtcbiAgICAgICAgcmV0dXJuIHQgPSB0ICE9PSBlID8gbmV3IHIobiwgdCkgOiBuLCBuZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3VzaW5nQ3R4LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX092ZXJsb2FkWWllbGQoZSwgZCkge1xuICB0aGlzLnYgPSBlLCB0aGlzLmsgPSBkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfT3ZlcmxvYWRZaWVsZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbmZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKGUpIHtcbiAgcmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkKGUsIDApO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXdhaXRBc3luY0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbmZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQXN5bmNHZW5lcmF0b3IoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGUpIHtcbiAgdmFyIHIsIHQ7XG4gIGZ1bmN0aW9uIHJlc3VtZShyLCB0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBuID0gZVtyXSh0KSxcbiAgICAgICAgbyA9IG4udmFsdWUsXG4gICAgICAgIHUgPSBvIGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZDtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh1ID8gby52IDogbykudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciBpID0gXCJyZXR1cm5cIiA9PT0gciA/IFwicmV0dXJuXCIgOiBcIm5leHRcIjtcbiAgICAgICAgICBpZiAoIW8uayB8fCB0LmRvbmUpIHJldHVybiByZXN1bWUoaSwgdCk7XG4gICAgICAgICAgdCA9IGVbaV0odCkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGxlKG4uZG9uZSA/IFwicmV0dXJuXCIgOiBcIm5vcm1hbFwiLCB0KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJlc3VtZShcInRocm93XCIsIGUpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2V0dGxlKFwidGhyb3dcIiwgZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldHRsZShlLCBuKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgIHIucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgZG9uZTogITBcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRocm93XCI6XG4gICAgICAgIHIucmVqZWN0KG4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgZG9uZTogITFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIChyID0gci5uZXh0KSA/IHJlc3VtZShyLmtleSwgci5hcmcpIDogdCA9IG51bGw7XG4gIH1cbiAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24gKGUsIG4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKG8sIHUpIHtcbiAgICAgIHZhciBpID0ge1xuICAgICAgICBrZXk6IGUsXG4gICAgICAgIGFyZzogbixcbiAgICAgICAgcmVzb2x2ZTogbyxcbiAgICAgICAgcmVqZWN0OiB1LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgdCA/IHQgPSB0Lm5leHQgPSBpIDogKHIgPSB0ID0gaSwgcmVzdW1lKGUsIG4pKTtcbiAgICB9KTtcbiAgfSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlW1wicmV0dXJuXCJdICYmICh0aGlzW1wicmV0dXJuXCJdID0gdm9pZCAwKTtcbn1cbkFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGUpO1xufSwgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1widGhyb3dcIl0gPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwidGhyb3dcIiwgZSk7XG59LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwicmV0dXJuXCIsIGUpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gX3dyYXBBc3luY0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImltcG9ydCB7IFVucHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uL3ZlbmRvci91bnByb21pc2UnO1xuaW1wb3J0IHsgdGhyb3dBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vaHR0cC9hYm9ydEVycm9yJztcbmltcG9ydCB7IG1ha2VBc3luY1Jlc291cmNlIH0gZnJvbSAnLi9kaXNwb3NhYmxlJztcbmltcG9ydCB7IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQsIHRpbWVyUmVzb3VyY2UgfSBmcm9tICcuL3RpbWVyUmVzb3VyY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXRlcmF0b3JSZXNvdXJjZTxUWWllbGQsIFRSZXR1cm4sIFROZXh0PihcbiAgaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCBUUmV0dXJuLCBUTmV4dD4sXG4pOiBBc3luY0l0ZXJhdG9yPFRZaWVsZCwgVFJldHVybiwgVE5leHQ+ICYgQXN5bmNEaXNwb3NhYmxlIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdGhpcyBpcyBhZGRlZCBpbiBub2RlIDI0IHdoaWNoIHdlIGRvbid0IG9mZmljaWFsbHkgc3VwcG9ydCB5ZXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGlmIChpdGVyYXRvcltTeW1ib2wuYXN5bmNEaXNwb3NlXSkge1xuICAgIHJldHVybiBpdGVyYXRvciBhcyBBc3luY0l0ZXJhdG9yPFRZaWVsZCwgVFJldHVybiwgVE5leHQ+ICYgQXN5bmNEaXNwb3NhYmxlO1xuICB9XG5cbiAgcmV0dXJuIG1ha2VBc3luY1Jlc291cmNlKGl0ZXJhdG9yLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuPy4oKTtcbiAgfSk7XG59XG4vKipcbiAqIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvbiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IGF1dG9tYXRpY2FsbHkgYWJvcnRzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogd2l0aE1heER1cmF0aW9uPFQ+KFxuICBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPixcbiAgb3B0czogeyBtYXhEdXJhdGlvbk1zOiBudW1iZXIgfSxcbik6IEFzeW5jR2VuZXJhdG9yPFQ+IHtcbiAgYXdhaXQgdXNpbmcgaXRlcmF0b3IgPSBpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKTtcblxuICB1c2luZyB0aW1lciA9IHRpbWVyUmVzb3VyY2Uob3B0cy5tYXhEdXJhdGlvbk1zKTtcblxuICBjb25zdCB0aW1lclByb21pc2UgPSB0aW1lci5zdGFydCgpO1xuXG4gIC8vIGRlY2xhcmF0aW9uIG91dHNpZGUgdGhlIGxvb3AgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiByZWFzb25zXG4gIGxldCByZXN1bHQ6IG51bGwgfCBJdGVyYXRvclJlc3VsdDxUPiB8IHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW2l0ZXJhdG9yLm5leHQoKSwgdGltZXJQcm9taXNlXSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkge1xuICAgICAgLy8gY2FuY2VsbGVkIGR1ZSB0byB0aW1lb3V0XG4gICAgICB0aHJvd0Fib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB5aWVsZCByZXN1bHQudmFsdWU7XG4gICAgLy8gZnJlZSB1cCByZWZlcmVuY2UgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIHJlc3VsdCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEgbmV3IHtAbGluayBBc3luY0dlbmVyYXRvcn0gYmFzZWQgb2Yge0BsaW5rIGl0ZXJhYmxlfSwgdGhhdCB5aWVsZHMgaXRzIGZpcnN0XG4gKiB7QGxpbmsgY291bnR9IHZhbHVlcy4gVGhlbiwgYSBncmFjZSBwZXJpb2Qgb2Yge0BsaW5rIGdyYWNlUGVyaW9kTXN9IGlzIHN0YXJ0ZWQgaW4gd2hpY2ggZnVydGhlclxuICogdmFsdWVzIG1heSBzdGlsbCBjb21lIHRocm91Z2guIEFmdGVyIHRoaXMgcGVyaW9kLCB0aGUgZ2VuZXJhdG9yIGFib3J0cy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiB0YWtlV2l0aEdyYWNlPFQ+KFxuICBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPixcbiAgb3B0czoge1xuICAgIGNvdW50OiBudW1iZXI7XG4gICAgZ3JhY2VQZXJpb2RNczogbnVtYmVyO1xuICB9LFxuKTogQXN5bmNHZW5lcmF0b3I8VD4ge1xuICBhd2FpdCB1c2luZyBpdGVyYXRvciA9IGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpO1xuXG4gIC8vIGRlY2xhcmF0aW9uIG91dHNpZGUgdGhlIGxvb3AgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiByZWFzb25zXG4gIGxldCByZXN1bHQ6IG51bGwgfCBJdGVyYXRvclJlc3VsdDxUPiB8IHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0O1xuXG4gIHVzaW5nIHRpbWVyID0gdGltZXJSZXNvdXJjZShvcHRzLmdyYWNlUGVyaW9kTXMpO1xuXG4gIGxldCBjb3VudCA9IG9wdHMuY291bnQ7XG5cbiAgbGV0IHRpbWVyUHJvbWlzZSA9IG5ldyBQcm9taXNlPHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0PigoKSA9PiB7XG4gICAgLy8gbmV2ZXIgcmVzb2x2ZXNcbiAgfSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICByZXN1bHQgPSBhd2FpdCBVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKTtcbiAgICBpZiAocmVzdWx0ID09PSBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0KSB7XG4gICAgICB0aHJvd0Fib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICB5aWVsZCByZXN1bHQudmFsdWU7XG4gICAgaWYgKC0tY291bnQgPT09IDApIHtcbiAgICAgIHRpbWVyUHJvbWlzZSA9IHRpbWVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8vIGZyZWUgdXAgcmVmZXJlbmNlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICByZXN1bHQgPSBudWxsO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWQ8VFZhbHVlID0gdm9pZD4oKSB7XG4gIGxldCByZXNvbHZlOiAodmFsdWU6IFRWYWx1ZSkgPT4gdm9pZDtcbiAgbGV0IHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VFZhbHVlPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzb2x2ZSEsIHJlamVjdDogcmVqZWN0ISB9O1xufVxuZXhwb3J0IHR5cGUgRGVmZXJyZWQ8VFZhbHVlPiA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZURlZmVycmVkPFRWYWx1ZT4+O1xuIiwiaW1wb3J0IHsgY3JlYXRlRGVmZXJyZWQgfSBmcm9tICcuL2NyZWF0ZURlZmVycmVkJztcbmltcG9ydCB7IG1ha2VBc3luY1Jlc291cmNlIH0gZnJvbSAnLi9kaXNwb3NhYmxlJztcblxudHlwZSBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCBUUmV0dXJuPiA9XG4gIHwgeyBzdGF0dXM6ICd5aWVsZCc7IHZhbHVlOiBUWWllbGQgfVxuICB8IHsgc3RhdHVzOiAncmV0dXJuJzsgdmFsdWU6IFRSZXR1cm4gfVxuICB8IHsgc3RhdHVzOiAnZXJyb3InOyBlcnJvcjogdW5rbm93biB9O1xuZnVuY3Rpb24gY3JlYXRlTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgVFJldHVybj4oXG4gIGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZCwgVFJldHVybj4sXG4gIG9uUmVzdWx0OiAocmVzdWx0OiBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCBUUmV0dXJuPikgPT4gdm9pZCxcbikge1xuICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICBsZXQgc3RhdGU6ICdpZGxlJyB8ICdwZW5kaW5nJyB8ICdkb25lJyA9ICdpZGxlJztcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHN0YXRlID0gJ2RvbmUnO1xuICAgIG9uUmVzdWx0ID0gKCkgPT4ge1xuICAgICAgLy8gbm9vcFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsKCkge1xuICAgIGlmIChzdGF0ZSAhPT0gJ2lkbGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlID0gJ3BlbmRpbmcnO1xuXG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBuZXh0XG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHN0YXRlID0gJ2RvbmUnO1xuICAgICAgICAgIG9uUmVzdWx0KHsgc3RhdHVzOiAncmV0dXJuJywgdmFsdWU6IHJlc3VsdC52YWx1ZSB9KTtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gJ2lkbGUnO1xuICAgICAgICBvblJlc3VsdCh7IHN0YXR1czogJ3lpZWxkJywgdmFsdWU6IHJlc3VsdC52YWx1ZSB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGNhdXNlKSA9PiB7XG4gICAgICAgIG9uUmVzdWx0KHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogY2F1c2UgfSk7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdWxsLFxuICAgIGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybj8uKCk7XG4gICAgfSxcbiAgfTtcbn1cbnR5cGUgTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgVFJldHVybj4gPSBSZXR1cm5UeXBlPFxuICB0eXBlb2YgY3JlYXRlTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgVFJldHVybj5cbj47XG5cbmludGVyZmFjZSBNZXJnZWRBc3luY0l0ZXJhYmxlczxUWWllbGQ+XG4gIGV4dGVuZHMgQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQsIHVua25vd24+IHtcbiAgYWRkKGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZD4pOiB2b2lkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXN5bmMgaXRlcmFibGUgdGhhdCBtZXJnZXMgbXVsdGlwbGUgYXN5bmMgaXRlcmFibGVzIGludG8gYSBzaW5nbGUgc3RyZWFtLlxuICogVmFsdWVzIGZyb20gdGhlIGlucHV0IGl0ZXJhYmxlcyBhcmUgeWllbGRlZCBpbiB0aGUgb3JkZXIgdGhleSByZXNvbHZlLCBzaW1pbGFyIHRvIFByb21pc2UucmFjZSgpLlxuICpcbiAqIE5ldyBpdGVyYWJsZXMgY2FuIGJlIGFkZGVkIGR5bmFtaWNhbGx5IHVzaW5nIHRoZSByZXR1cm5lZCB7QGxpbmsgTWVyZ2VkQXN5bmNJdGVyYWJsZXMuYWRkfSBtZXRob2QsIGV2ZW4gYWZ0ZXIgaXRlcmF0aW9uIGhhcyBzdGFydGVkLlxuICpcbiAqIElmIGFueSBvZiB0aGUgaW5wdXQgaXRlcmFibGVzIHRocm93cyBhbiBlcnJvciwgdGhhdCBlcnJvciB3aWxsIGJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgbWVyZ2VkIHN0cmVhbS5cbiAqIE90aGVyIGl0ZXJhYmxlcyB3aWxsIG5vdCBjb250aW51ZSB0byBiZSBwcm9jZXNzZWQuXG4gKlxuICogQHRlbXBsYXRlIFRZaWVsZCBUaGUgdHlwZSBvZiB2YWx1ZXMgeWllbGRlZCBieSB0aGUgaW5wdXQgaXRlcmFibGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFzeW5jSXRlcmFibGVzPFRZaWVsZD4oKTogTWVyZ2VkQXN5bmNJdGVyYWJsZXM8VFlpZWxkPiB7XG4gIGxldCBzdGF0ZTogJ2lkbGUnIHwgJ3BlbmRpbmcnIHwgJ2RvbmUnID0gJ2lkbGUnO1xuICBsZXQgZmx1c2hTaWduYWwgPSBjcmVhdGVEZWZlcnJlZCgpO1xuXG4gIC8qKlxuICAgKiB1c2VkIHdoaWxlIHtAbGluayBzdGF0ZX0gaXMgYGlkbGVgXG4gICAqL1xuICBjb25zdCBpdGVyYWJsZXM6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCB2b2lkLCB1bmtub3duPltdID0gW107XG4gIC8qKlxuICAgKiB1c2VkIHdoaWxlIHtAbGluayBzdGF0ZX0gaXMgYHBlbmRpbmdgXG4gICAqL1xuICBjb25zdCBpdGVyYXRvcnMgPSBuZXcgU2V0PE1hbmFnZWRJdGVyYXRvcjxUWWllbGQsIHZvaWQ+PigpO1xuXG4gIGNvbnN0IGJ1ZmZlcjogQXJyYXk8XG4gICAgW1xuICAgICAgaXRlcmF0b3I6IE1hbmFnZWRJdGVyYXRvcjxUWWllbGQsIHZvaWQ+LFxuICAgICAgcmVzdWx0OiBFeGNsdWRlPFxuICAgICAgICBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCB2b2lkPixcbiAgICAgICAgeyBzdGF0dXM6ICdyZXR1cm4nIH1cbiAgICAgID4sXG4gICAgXVxuICA+ID0gW107XG5cbiAgZnVuY3Rpb24gaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZCwgdm9pZCwgdW5rbm93bj4pIHtcbiAgICBpZiAoc3RhdGUgIT09ICdwZW5kaW5nJykge1xuICAgICAgLy8gc2hvdWxkbid0IGhhcHBlblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVyYXRvciA9IGNyZWF0ZU1hbmFnZWRJdGVyYXRvcihpdGVyYWJsZSwgKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHN0YXRlICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgLy8gc2hvdWxkbid0IGhhcHBlblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFtpdGVyYXRvciwgcmVzdWx0XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JldHVybic6XG4gICAgICAgICAgaXRlcmF0b3JzLmRlbGV0ZShpdGVyYXRvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBidWZmZXIucHVzaChbaXRlcmF0b3IsIHJlc3VsdF0pO1xuICAgICAgICAgIGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmx1c2hTaWduYWwucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIGl0ZXJhdG9ycy5hZGQoaXRlcmF0b3IpO1xuICAgIGl0ZXJhdG9yLnB1bGwoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkKGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZCwgdm9pZCwgdW5rbm93bj4pIHtcbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnaWRsZSc6XG4gICAgICAgICAgaXRlcmFibGVzLnB1c2goaXRlcmFibGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICBpbml0SXRlcmFibGUoaXRlcmFibGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb25lJzoge1xuICAgICAgICAgIC8vIHNob3VsZG4ndCBoYXBwZW5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBpZiAoc3RhdGUgIT09ICdpZGxlJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIHR3aWNlJyk7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9ICdwZW5kaW5nJztcblxuICAgICAgYXdhaXQgdXNpbmcgX2ZpbmFsbHkgPSBtYWtlQXN5bmNSZXNvdXJjZSh7fSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBzdGF0ZSA9ICdkb25lJztcblxuICAgICAgICBjb25zdCBlcnJvcnM6IHVua25vd25bXSA9IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBBcnJheS5mcm9tKGl0ZXJhdG9ycy52YWx1ZXMoKSkubWFwKGFzeW5jIChpdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgaXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2goY2F1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgICBidWZmZXIubGVuZ3RoID0gMDtcbiAgICAgICAgaXRlcmF0b3JzLmNsZWFyKCk7XG4gICAgICAgIGZsdXNoU2lnbmFsLnJlc29sdmUoKTtcblxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlIChpdGVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBpbml0SXRlcmFibGUoaXRlcmFibGVzLnNoaWZ0KCkhKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGl0ZXJhdG9ycy5zaXplID4gMCkge1xuICAgICAgICBhd2FpdCBmbHVzaFNpZ25hbC5wcm9taXNlO1xuXG4gICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgY29uc3QgW2l0ZXJhdG9yLCByZXN1bHRdID0gYnVmZmVyLnNoaWZ0KCkhO1xuXG4gICAgICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICd5aWVsZCc6XG4gICAgICAgICAgICAgIHlpZWxkIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgaXRlcmF0b3IucHVsbCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVzaFNpZ25hbCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cbiIsIi8qKlxuICogQ3JlYXRlcyBhIFJlYWRhYmxlU3RyZWFtIGZyb20gYW4gQXN5bmNJdGVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gaXRlcmFibGUgLSBUaGUgc291cmNlIEFzeW5jSXRlcmFibGUgdG8gc3RyZWFtIGZyb21cbiAqIEByZXR1cm5zIEEgUmVhZGFibGVTdHJlYW0gdGhhdCB5aWVsZHMgdmFsdWVzIGZyb20gdGhlIEFzeW5jSXRlcmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtRnJvbTxUWWllbGQ+KFxuICBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQ+LFxuKTogUmVhZGFibGVTdHJlYW08VFlpZWxkPiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuPy4oKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBVbnByb21pc2UgfSBmcm9tICcuLi8uLi8uLi92ZW5kb3IvdW5wcm9taXNlJztcbmltcG9ydCB7IGl0ZXJhdG9yUmVzb3VyY2UgfSBmcm9tICcuL2FzeW5jSXRlcmFibGUnO1xuaW1wb3J0IHsgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCwgdGltZXJSZXNvdXJjZSB9IGZyb20gJy4vdGltZXJSZXNvdXJjZSc7XG5cbmV4cG9ydCBjb25zdCBQSU5HX1NZTSA9IFN5bWJvbCgncGluZycpO1xuXG4vKipcbiAqIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvZiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IHlpZWxkcyB7QGxpbmsgUElOR19TWU19XG4gKiB3aGVuZXZlciBubyB2YWx1ZSBoYXMgYmVlbiB5aWVsZGVkIGZvciB7QGxpbmsgcGluZ0ludGVydmFsTXN9LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHdpdGhQaW5nPFRWYWx1ZT4oXG4gIGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRWYWx1ZT4sXG4gIHBpbmdJbnRlcnZhbE1zOiBudW1iZXIsXG4pOiBBc3luY0dlbmVyYXRvcjxUVmFsdWUgfCB0eXBlb2YgUElOR19TWU0+IHtcbiAgYXdhaXQgdXNpbmcgaXRlcmF0b3IgPSBpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKTtcblxuICAvLyBkZWNsYXJhdGlvbiBvdXRzaWRlIHRoZSBsb29wIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gcmVhc29uc1xuICBsZXQgcmVzdWx0OlxuICAgIHwgbnVsbFxuICAgIHwgSXRlcmF0b3JSZXN1bHQ8VFZhbHVlPlxuICAgIHwgdHlwZW9mIGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQ7XG5cbiAgbGV0IG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdXNpbmcgcGluZ1Byb21pc2UgPSB0aW1lclJlc291cmNlKHBpbmdJbnRlcnZhbE1zKTtcblxuICAgIHJlc3VsdCA9IGF3YWl0IFVucHJvbWlzZS5yYWNlKFtuZXh0UHJvbWlzZSwgcGluZ1Byb21pc2Uuc3RhcnQoKV0pO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkge1xuICAgICAgLy8gY2FuY2VsbGVkXG5cbiAgICAgIHlpZWxkIFBJTkdfU1lNO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHlpZWxkIHJlc3VsdC52YWx1ZTtcblxuICAgIC8vIGZyZWUgdXAgcmVmZXJlbmNlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICByZXN1bHQgPSBudWxsO1xuICB9XG59XG4iLCJmdW5jdGlvbiBfYXN5bmNJdGVyYXRvcihyKSB7XG4gIHZhciBuLFxuICAgIHQsXG4gICAgbyxcbiAgICBlID0gMjtcbiAgZm9yIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgKHQgPSBTeW1ib2wuYXN5bmNJdGVyYXRvciwgbyA9IFN5bWJvbC5pdGVyYXRvcik7IGUtLTspIHtcbiAgICBpZiAodCAmJiBudWxsICE9IChuID0gclt0XSkpIHJldHVybiBuLmNhbGwocik7XG4gICAgaWYgKG8gJiYgbnVsbCAhPSAobiA9IHJbb10pKSByZXR1cm4gbmV3IEFzeW5jRnJvbVN5bmNJdGVyYXRvcihuLmNhbGwocikpO1xuICAgIHQgPSBcIkBAYXN5bmNJdGVyYXRvclwiLCBvID0gXCJAQGl0ZXJhdG9yXCI7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGVcIik7XG59XG5mdW5jdGlvbiBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocikge1xuICBmdW5jdGlvbiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24ocikge1xuICAgIGlmIChPYmplY3QocikgIT09IHIpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKHIgKyBcIiBpcyBub3QgYW4gb2JqZWN0LlwiKSk7XG4gICAgdmFyIG4gPSByLmRvbmU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyLnZhbHVlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgZG9uZTogblxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gQXN5bmNGcm9tU3luY0l0ZXJhdG9yKHIpIHtcbiAgICB0aGlzLnMgPSByLCB0aGlzLm4gPSByLm5leHQ7XG4gIH0sIEFzeW5jRnJvbVN5bmNJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgczogbnVsbCxcbiAgICBuOiBudWxsLFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICByZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKHRoaXMubi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgXCJyZXR1cm5cIjogZnVuY3Rpb24gX3JldHVybihyKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuc1tcInJldHVyblwiXTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IG4gPyBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgZG9uZTogITBcbiAgICAgIH0pIDogQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKG4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIFwidGhyb3dcIjogZnVuY3Rpb24gX3Rocm93KHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5zW1wicmV0dXJuXCJdO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbiA/IFByb21pc2UucmVqZWN0KHIpIDogQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKG4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gIH0sIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY0l0ZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHsgaXNBc3luY0l0ZXJhYmxlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcnVuIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXRlcmF0b3JSZXNvdXJjZSB9IGZyb20gJy4vdXRpbHMvYXN5bmNJdGVyYWJsZSc7XG5pbXBvcnQgdHlwZSB7IERlZmVycmVkIH0gZnJvbSAnLi91dGlscy9jcmVhdGVEZWZlcnJlZCc7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCB9IGZyb20gJy4vdXRpbHMvY3JlYXRlRGVmZXJyZWQnO1xuaW1wb3J0IHsgbWFrZVJlc291cmNlIH0gZnJvbSAnLi91dGlscy9kaXNwb3NhYmxlJztcbmltcG9ydCB7IG1lcmdlQXN5bmNJdGVyYWJsZXMgfSBmcm9tICcuL3V0aWxzL21lcmdlQXN5bmNJdGVyYWJsZXMnO1xuaW1wb3J0IHsgcmVhZGFibGVTdHJlYW1Gcm9tIH0gZnJvbSAnLi91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20nO1xuaW1wb3J0IHsgUElOR19TWU0sIHdpdGhQaW5nIH0gZnJvbSAnLi91dGlscy93aXRoUGluZyc7XG5cbi8qKlxuICogQSBzdWJzZXQgb2YgdGhlIHN0YW5kYXJkIFJlYWRhYmxlU3RyZWFtIHByb3BlcnRpZXMgbmVlZGVkIGJ5IHRSUEMgaW50ZXJuYWxseS5cbiAqIEBzZWUgUmVhZGFibGVTdHJlYW0gZnJvbSBsaWIuZG9tLmQudHNcbiAqL1xuZXhwb3J0IHR5cGUgV2ViUmVhZGFibGVTdHJlYW1Fc3F1ZSA9IHtcbiAgZ2V0UmVhZGVyOiAoKSA9PiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG59O1xuXG5leHBvcnQgdHlwZSBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlID0ge1xuICBvbihcbiAgICBldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCxcbiAgICBsaXN0ZW5lcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkLFxuICApOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlO1xufTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vLyAtLS0tLS0tLS0tIHR5cGVzXG5jb25zdCBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSAwO1xudHlwZSBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSB0eXBlb2YgQ0hVTktfVkFMVUVfVFlQRV9QUk9NSVNFO1xuY29uc3QgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRSA9IDE7XG50eXBlIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUgPSB0eXBlb2YgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRTtcblxuY29uc3QgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEID0gMDtcbnR5cGUgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEID0gdHlwZW9mIFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRDtcbmNvbnN0IFBST01JU0VfU1RBVFVTX1JFSkVDVEVEID0gMTtcbnR5cGUgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQgPSB0eXBlb2YgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQ7XG5cbmNvbnN0IEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4gPSAwO1xudHlwZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOID0gdHlwZW9mIEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk47XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSAxO1xudHlwZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSB0eXBlb2YgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gMjtcbnR5cGUgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gdHlwZW9mIEFTWU5DX0lURVJBQkxFX1NUQVRVU19FUlJPUjtcblxudHlwZSBDaHVua0RlZmluaXRpb25LZXkgPVxuICAvLyByb290IHNob3VsZCBiZSByZXBsYWNlZFxuICB8IG51bGxcbiAgLy8gYXQgYXJyYXkgcGF0aFxuICB8IG51bWJlclxuICAvLyBhdCBrZXkgcGF0aFxuICB8IHN0cmluZztcblxudHlwZSBDaHVua0luZGV4ID0gbnVtYmVyICYgeyBfX2NodW5rSW5kZXg6IHRydWUgfTtcbnR5cGUgQ2h1bmtWYWx1ZVR5cGUgPVxuICB8IENIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRVxuICB8IENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEU7XG50eXBlIENodW5rRGVmaW5pdGlvbiA9IFtcbiAga2V5OiBDaHVua0RlZmluaXRpb25LZXksXG4gIHR5cGU6IENodW5rVmFsdWVUeXBlLFxuICBjaHVua0lkOiBDaHVua0luZGV4LFxuXTtcbnR5cGUgRW5jb2RlZFZhbHVlID0gW1xuICAvLyBkYXRhXG4gIFt1bmtub3duXSB8IFtdLFxuICAvLyBjaHVuayBkZXNjcmlwdGlvbnNcbiAgLi4uQ2h1bmtEZWZpbml0aW9uW10sXG5dO1xuXG50eXBlIEhlYWQgPSBSZWNvcmQ8c3RyaW5nLCBFbmNvZGVkVmFsdWU+O1xudHlwZSBQcm9taXNlQ2h1bmsgPVxuICB8IFtcbiAgICAgIGNodW5rSW5kZXg6IENodW5rSW5kZXgsXG4gICAgICBzdGF0dXM6IFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRCxcbiAgICAgIHZhbHVlOiBFbmNvZGVkVmFsdWUsXG4gICAgXVxuICB8IFtjaHVua0luZGV4OiBDaHVua0luZGV4LCBzdGF0dXM6IFBST01JU0VfU1RBVFVTX1JFSkVDVEVELCBlcnJvcjogdW5rbm93bl07XG50eXBlIEl0ZXJhYmxlQ2h1bmsgPVxuICB8IFtcbiAgICAgIGNodW5rSW5kZXg6IENodW5rSW5kZXgsXG4gICAgICBzdGF0dXM6IEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4sXG4gICAgICB2YWx1ZTogRW5jb2RlZFZhbHVlLFxuICAgIF1cbiAgfCBbXG4gICAgICBjaHVua0luZGV4OiBDaHVua0luZGV4LFxuICAgICAgc3RhdHVzOiBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQsXG4gICAgICB2YWx1ZTogRW5jb2RlZFZhbHVlLFxuICAgIF1cbiAgfCBbXG4gICAgICBjaHVua0luZGV4OiBDaHVua0luZGV4LFxuICAgICAgc3RhdHVzOiBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfRVJST1IsXG4gICAgICBlcnJvcjogdW5rbm93bixcbiAgICBdO1xudHlwZSBDaHVua0RhdGEgPSBQcm9taXNlQ2h1bmsgfCBJdGVyYWJsZUNodW5rO1xudHlwZSBQbGFjZWhvbGRlclZhbHVlID0gMCAmIHsgX19wbGFjZWhvbGRlcjogdHJ1ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gKFxuICAgIChpc09iamVjdCh2YWx1ZSkgfHwgaXNGdW5jdGlvbih2YWx1ZSkpICYmXG4gICAgdHlwZW9mIHZhbHVlPy5bJ3RoZW4nXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZT8uWydjYXRjaCddID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbnR5cGUgU2VyaWFsaXplID0gKHZhbHVlOiBhbnkpID0+IGFueTtcbnR5cGUgRGVzZXJpYWxpemUgPSAodmFsdWU6IGFueSkgPT4gYW55O1xuXG50eXBlIFBhdGhBcnJheSA9IHJlYWRvbmx5IChzdHJpbmcgfCBudW1iZXIpW107XG5leHBvcnQgdHlwZSBQcm9kdWNlck9uRXJyb3IgPSAob3B0czoge1xuICBlcnJvcjogdW5rbm93bjtcbiAgcGF0aDogUGF0aEFycmF5O1xufSkgPT4gdm9pZDtcbmV4cG9ydCBpbnRlcmZhY2UgSlNPTkxQcm9kdWNlck9wdGlvbnMge1xuICBzZXJpYWxpemU/OiBTZXJpYWxpemU7XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5rbm93bltdO1xuICBvbkVycm9yPzogUHJvZHVjZXJPbkVycm9yO1xuICBmb3JtYXRFcnJvcj86IChvcHRzOiB7IGVycm9yOiB1bmtub3duOyBwYXRoOiBQYXRoQXJyYXkgfSkgPT4gdW5rbm93bjtcbiAgbWF4RGVwdGg/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgdG8gc2VuZCBhIHBpbmcgdG8gdGhlIGNsaWVudCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlXG4gICAqIFRoaXMgd2lsbCBiZSBzZW50IGFzIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXJcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBwaW5nTXM/OiBudW1iZXI7XG59XG5cbmNsYXNzIE1heERlcHRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdKSB7XG4gICAgc3VwZXIoJ01heCBkZXB0aCByZWFjaGVkIGF0IHBhdGg6ICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIoXG4gIG9wdHM6IEpTT05MUHJvZHVjZXJPcHRpb25zLFxuKTogQXN5bmNJdGVyYWJsZTxIZWFkIHwgQ2h1bmtEYXRhIHwgdHlwZW9mIFBJTkdfU1lNLCB2b2lkPiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gb3B0cztcbiAgbGV0IGNvdW50ZXIgPSAwIGFzIENodW5rSW5kZXg7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gMCBhcyBQbGFjZWhvbGRlclZhbHVlO1xuXG4gIGNvbnN0IG1lcmdlZEl0ZXJhYmxlcyA9IG1lcmdlQXN5bmNJdGVyYWJsZXM8Q2h1bmtEYXRhPigpO1xuICBmdW5jdGlvbiByZWdpc3RlckFzeW5jKFxuICAgIGNhbGxiYWNrOiAoaWR4OiBDaHVua0luZGV4KSA9PiBBc3luY0l0ZXJhYmxlPENodW5rRGF0YSwgdm9pZD4sXG4gICkge1xuICAgIGNvbnN0IGlkeCA9IGNvdW50ZXIrKyBhcyBDaHVua0luZGV4O1xuXG4gICAgY29uc3QgaXRlcmFibGUgPSBjYWxsYmFjayhpZHgpO1xuICAgIG1lcmdlZEl0ZXJhYmxlcy5hZGQoaXRlcmFibGUpO1xuXG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZVByb21pc2UocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPiwgcGF0aDogKHN0cmluZyB8IG51bWJlcilbXSkge1xuICAgIHJldHVybiByZWdpc3RlckFzeW5jKGFzeW5jIGZ1bmN0aW9uKiAoaWR4KSB7XG4gICAgICBjb25zdCBlcnJvciA9IGNoZWNrTWF4RGVwdGgocGF0aCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyBmcm9tIHRoZSBvcmlnaW5hbCBwcm9taXNlIHRvIGVuc3VyZSB0aGV5J3JlIHJlcG9ydGVkXG4gICAgICAgIHByb21pc2UuY2F0Y2goKGNhdXNlKSA9PiB7XG4gICAgICAgICAgb3B0cy5vbkVycm9yPy4oeyBlcnJvcjogY2F1c2UsIHBhdGggfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBwcm9taXNlIHdpdGggYSByZWplY3RlZCBvbmUgY29udGFpbmluZyB0aGUgbWF4IGRlcHRoIGVycm9yXG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXh0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgeWllbGQgW2lkeCwgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVELCBlbmNvZGUobmV4dCwgcGF0aCldO1xuICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgb3B0cy5vbkVycm9yPy4oeyBlcnJvcjogY2F1c2UsIHBhdGggfSk7XG4gICAgICAgIHlpZWxkIFtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQsXG4gICAgICAgICAgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGNhdXNlLCBwYXRoIH0pLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZUFzeW5jSXRlcmFibGUoXG4gICAgaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8dW5rbm93bj4sXG4gICAgcGF0aDogKHN0cmluZyB8IG51bWJlcilbXSxcbiAgKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyQXN5bmMoYXN5bmMgZnVuY3Rpb24qIChpZHgpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tNYXhEZXB0aChwYXRoKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHVzaW5nIGl0ZXJhdG9yID0gaXRlcmF0b3JSZXNvdXJjZShpdGVyYWJsZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICB5aWVsZCBbaWR4LCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOLCBlbmNvZGUobmV4dC52YWx1ZSwgcGF0aCldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIFtpZHgsIEFTWU5DX0lURVJBQkxFX1NUQVRVU19ZSUVMRCwgZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgb3B0cy5vbkVycm9yPy4oeyBlcnJvcjogY2F1c2UsIHBhdGggfSk7XG5cbiAgICAgICAgeWllbGQgW1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfRVJST1IsXG4gICAgICAgICAgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGNhdXNlLCBwYXRoIH0pLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrTWF4RGVwdGgocGF0aDogKHN0cmluZyB8IG51bWJlcilbXSkge1xuICAgIGlmIChvcHRzLm1heERlcHRoICYmIHBhdGgubGVuZ3RoID4gb3B0cy5tYXhEZXB0aCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXhEZXB0aEVycm9yKHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGVBc3luYyhcbiAgICB2YWx1ZTogdW5rbm93bixcbiAgICBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdLFxuICApOiBudWxsIHwgW3R5cGU6IENodW5rVmFsdWVUeXBlLCBjaHVua0lkOiBDaHVua0luZGV4XSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbQ0hVTktfVkFMVUVfVFlQRV9QUk9NSVNFLCBlbmNvZGVQcm9taXNlKHZhbHVlLCBwYXRoKV07XG4gICAgfVxuICAgIGlmIChpc0FzeW5jSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICBpZiAob3B0cy5tYXhEZXB0aCAmJiBwYXRoLmxlbmd0aCA+PSBvcHRzLm1heERlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IGRlcHRoIHJlYWNoZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUsXG4gICAgICAgIGVuY29kZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhdGgpLFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZW5jb2RlKHZhbHVlOiB1bmtub3duLCBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdKTogRW5jb2RlZFZhbHVlIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFtbXV07XG4gICAgfVxuICAgIGNvbnN0IHJlZyA9IGVuY29kZUFzeW5jKHZhbHVlLCBwYXRoKTtcbiAgICBpZiAocmVnKSB7XG4gICAgICByZXR1cm4gW1twbGFjZWhvbGRlcl0sIFtudWxsLCAuLi5yZWddXTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW1t2YWx1ZV1dO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld09iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBjb25zdCBhc3luY1ZhbHVlczogQ2h1bmtEZWZpbml0aW9uW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBlbmNvZGVBc3luYyhpdGVtLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgICAgIG5ld09ialtrZXldID0gaXRlbTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuZXdPYmpba2V5XSA9IHBsYWNlaG9sZGVyO1xuICAgICAgYXN5bmNWYWx1ZXMucHVzaChba2V5LCAuLi50cmFuc2Zvcm1lZF0pO1xuICAgIH1cbiAgICByZXR1cm4gW1tuZXdPYmpdLCAuLi5hc3luY1ZhbHVlc107XG4gIH1cblxuICBjb25zdCBuZXdIZWFkOiBIZWFkID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICBuZXdIZWFkW2tleV0gPSBlbmNvZGUoaXRlbSwgW2tleV0pO1xuICB9XG5cbiAgeWllbGQgbmV3SGVhZDtcblxuICBsZXQgaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8Q2h1bmtEYXRhIHwgdHlwZW9mIFBJTkdfU1lNLCB2b2lkPiA9XG4gICAgbWVyZ2VkSXRlcmFibGVzO1xuICBpZiAob3B0cy5waW5nTXMpIHtcbiAgICBpdGVyYWJsZSA9IHdpdGhQaW5nKG1lcmdlZEl0ZXJhYmxlcywgb3B0cy5waW5nTXMpO1xuICB9XG5cbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgIHlpZWxkIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIEpTT04gTGluZXMgc3RyZWFtIHByb2R1Y2VyXG4gKiBAc2VlIGh0dHBzOi8vanNvbmxpbmVzLm9yZy9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25sU3RyZWFtUHJvZHVjZXIob3B0czogSlNPTkxQcm9kdWNlck9wdGlvbnMpIHtcbiAgbGV0IHN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtRnJvbShjcmVhdGVCYXRjaFN0cmVhbVByb2R1Y2VyKG9wdHMpKTtcblxuICBjb25zdCB7IHNlcmlhbGl6ZSB9ID0gb3B0cztcbiAgaWYgKHNlcmlhbGl6ZSkge1xuICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsgPT09IFBJTkdfU1lNKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoUElOR19TWU0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoc2VyaWFsaXplKGNodW5rKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbiAgICAucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rID09PSBQSU5HX1NZTSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShKU09OLnN0cmluZ2lmeShjaHVuaykgKyAnXFxuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKVxuICAgIC5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG59XG5cbmNsYXNzIEFzeW5jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkYXRhOiB1bmtub3duKSB7XG4gICAgc3VwZXIoJ1JlY2VpdmVkIGVycm9yIGZyb20gc2VydmVyJyk7XG4gIH1cbn1cbmV4cG9ydCB0eXBlIENvbnN1bWVyT25FcnJvciA9IChvcHRzOiB7IGVycm9yOiB1bmtub3duIH0pID0+IHZvaWQ7XG5cbmNvbnN0IG5vZGVKc1N0cmVhbVRvUmVhZGVyRXNxdWUgPSAoc291cmNlOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZ2V0UmVhZGVyKCkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIHNvdXJjZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb3VyY2Uub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb3VyY2Uub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICB9LFxuICB9O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTGluZUFjY3VtdWxhdG9yKFxuICBmcm9tOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlIHwgV2ViUmVhZGFibGVTdHJlYW1Fc3F1ZSxcbikge1xuICBjb25zdCByZWFkZXIgPVxuICAgICdnZXRSZWFkZXInIGluIGZyb21cbiAgICAgID8gZnJvbS5nZXRSZWFkZXIoKVxuICAgICAgOiBub2RlSnNTdHJlYW1Ub1JlYWRlckVzcXVlKGZyb20pLmdldFJlYWRlcigpO1xuXG4gIGxldCBsaW5lQWdncmVnYXRlID0gJyc7XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmV0dXJuIHJlYWRlci5jYW5jZWwoKTtcbiAgICB9LFxuICB9KVxuICAgIC5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSlcbiAgICAucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtPHN0cmluZywgc3RyaW5nPih7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGxpbmVBZ2dyZWdhdGUgKz0gY2h1bms7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lQWdncmVnYXRlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBsaW5lQWdncmVnYXRlID0gcGFydHMucG9wKCkgPz8gJyc7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN1bWVyU3RyZWFtPFRIZWFkPihcbiAgZnJvbTogTm9kZUpTUmVhZGFibGVTdHJlYW1Fc3F1ZSB8IFdlYlJlYWRhYmxlU3RyZWFtRXNxdWUsXG4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlTGluZUFjY3VtdWxhdG9yKGZyb20pO1xuXG4gIGxldCBzZW50SGVhZCA9IGZhbHNlO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW08c3RyaW5nLCBDaHVua0RhdGEgfCBUSGVhZD4oe1xuICAgICAgdHJhbnNmb3JtKGxpbmUsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKCFzZW50SGVhZCkge1xuICAgICAgICAgIGNvbnN0IGhlYWQgPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShoZWFkIGFzIFRIZWFkKTtcbiAgICAgICAgICBzZW50SGVhZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY2h1bms6IENodW5rRGF0YSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFuZGxlciBmb3IgbWFuYWdpbmcgc3RyZWFtIGNvbnRyb2xsZXJzIGFuZCB0aGVpciBsaWZlY3ljbGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtc01hbmFnZXIoYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpIHtcbiAgY29uc3QgY29udHJvbGxlck1hcCA9IG5ldyBNYXA8XG4gICAgQ2h1bmtJbmRleCxcbiAgICBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1Db250cm9sbGVyPlxuICA+KCk7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBjb250cm9sbGVycyBvciBkZWZlcnJlZCBwcm9taXNlc1xuICAgKi9cbiAgZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShjb250cm9sbGVyTWFwLnZhbHVlcygpKS5ldmVyeSgoYykgPT4gYy5jbG9zZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdHJlYW0gY29udHJvbGxlclxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtQ29udHJvbGxlcigpIHtcbiAgICBsZXQgb3JpZ2luYWxDb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPENodW5rRGF0YT47XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtPENodW5rRGF0YT4oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBvcmlnaW5hbENvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB7XG4gICAgICBlbnF1ZXVlOiAodjogQ2h1bmtEYXRhKSA9PiBvcmlnaW5hbENvbnRyb2xsZXIuZW5xdWV1ZSh2KSxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIG9yaWdpbmFsQ29udHJvbGxlci5jbG9zZSgpO1xuXG4gICAgICAgIGNsZWFyKCk7XG5cbiAgICAgICAgaWYgKGlzRW1wdHkoKSkge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xvc2VkOiBmYWxzZSxcbiAgICAgIGdldFJlYWRlclJlc291cmNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgICByZXR1cm4gbWFrZVJlc291cmNlKHJlYWRlciwgKCkgPT4ge1xuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IChyZWFzb246IHVua25vd24pID0+IHtcbiAgICAgICAgb3JpZ2luYWxDb250cm9sbGVyLmVycm9yKHJlYXNvbik7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICB9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0cmVhbUNvbnRyb2xsZXIsIHtcbiAgICAgICAgY2xvc2VkOiB0cnVlLFxuICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZTogKCkgPT4ge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmVhZGVyUmVzb3VyY2U6IG51bGwsXG4gICAgICAgIGVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBjcmVhdGVzIGEgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICovXG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlKGNodW5rSWQ6IENodW5rSW5kZXgpIHtcbiAgICBsZXQgYyA9IGNvbnRyb2xsZXJNYXAuZ2V0KGNodW5rSWQpO1xuICAgIGlmICghYykge1xuICAgICAgYyA9IGNyZWF0ZVN0cmVhbUNvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnRyb2xsZXJNYXAuc2V0KGNodW5rSWQsIGMpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFsbCBwZW5kaW5nIGNvbnRyb2xsZXJzIGFuZCByZWplY3RzIGRlZmVycmVkIHByb21pc2VzXG4gICAqL1xuICBmdW5jdGlvbiBjYW5jZWxBbGwocmVhc29uOiB1bmtub3duKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIGNvbnRyb2xsZXJNYXAudmFsdWVzKCkpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IocmVhc29uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldE9yQ3JlYXRlLFxuICAgIGlzRW1wdHksXG4gICAgY2FuY2VsQWxsLFxuICB9O1xufVxuXG4vKipcbiAqIEpTT04gTGluZXMgc3RyZWFtIGNvbnN1bWVyXG4gKiBAc2VlIGh0dHBzOi8vanNvbmxpbmVzLm9yZy9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGpzb25sU3RyZWFtQ29uc3VtZXI8VEhlYWQ+KG9wdHM6IHtcbiAgZnJvbTogTm9kZUpTUmVhZGFibGVTdHJlYW1Fc3F1ZSB8IFdlYlJlYWRhYmxlU3RyZWFtRXNxdWU7XG4gIGRlc2VyaWFsaXplPzogRGVzZXJpYWxpemU7XG4gIG9uRXJyb3I/OiBDb25zdW1lck9uRXJyb3I7XG4gIGZvcm1hdEVycm9yPzogKG9wdHM6IHsgZXJyb3I6IHVua25vd24gfSkgPT4gRXJyb3I7XG4gIC8qKlxuICAgKiBUaGlzIGBBYm9ydENvbnRyb2xsZXJgIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbn0pIHtcbiAgY29uc3QgeyBkZXNlcmlhbGl6ZSA9ICh2KSA9PiB2IH0gPSBvcHRzO1xuXG4gIGxldCBzb3VyY2UgPSBjcmVhdGVDb25zdW1lclN0cmVhbTxIZWFkPihvcHRzLmZyb20pO1xuICBpZiAoZGVzZXJpYWxpemUpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRlc2VyaWFsaXplKGNodW5rKSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG4gIGxldCBoZWFkRGVmZXJyZWQ6IG51bGwgfCBEZWZlcnJlZDxUSGVhZD4gPSBjcmVhdGVEZWZlcnJlZCgpO1xuXG4gIGNvbnN0IHN0cmVhbU1hbmFnZXIgPSBjcmVhdGVTdHJlYW1zTWFuYWdlcihvcHRzLmFib3J0Q29udHJvbGxlcik7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ2h1bmtEZWZpbml0aW9uKHZhbHVlOiBDaHVua0RlZmluaXRpb24pIHtcbiAgICBjb25zdCBbX3BhdGgsIHR5cGUsIGNodW5rSWRdID0gdmFsdWU7XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtTWFuYWdlci5nZXRPckNyZWF0ZShjaHVua0lkKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBDSFVOS19WQUxVRV9UWVBFX1BST01JU0U6IHtcbiAgICAgICAgcmV0dXJuIHJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdXNpbmcgcmVhZGVyID0gY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpO1xuXG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBjb25zdCBbX2NodW5rSWQsIHN0YXR1cywgZGF0YV0gPSB2YWx1ZSBhcyBQcm9taXNlQ2h1bms7XG4gICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEOlxuICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSBQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRDpcbiAgICAgICAgICAgICAgdGhyb3cgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGRhdGEgfSkgPz8gbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRToge1xuICAgICAgICByZXR1cm4gcnVuKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdXNpbmcgcmVhZGVyID0gY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpO1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IFtfY2h1bmtJZCwgc3RhdHVzLCBkYXRhXSA9IHZhbHVlIGFzIEl0ZXJhYmxlQ2h1bms7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEOlxuICAgICAgICAgICAgICAgIHlpZWxkIGRlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICAgIGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SOlxuICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgIG9wdHMuZm9ybWF0RXJyb3I/Lih7IGVycm9yOiBkYXRhIH0pID8/IG5ldyBBc3luY0Vycm9yKGRhdGEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSh2YWx1ZTogRW5jb2RlZFZhbHVlKTogdW5rbm93biB7XG4gICAgY29uc3QgW1tkYXRhXSwgLi4uYXN5bmNQcm9wc10gPSB2YWx1ZTtcblxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXN5bmNQcm9wcykge1xuICAgICAgY29uc3QgW2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUpO1xuXG4gICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgfVxuXG4gICAgICAoZGF0YSBhcyBhbnkpW2tleV0gPSBkZWNvZGVkO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IGNsb3NlT3JBYm9ydCA9IChyZWFzb246IHVua25vd24pID0+IHtcbiAgICBoZWFkRGVmZXJyZWQ/LnJlamVjdChyZWFzb24pO1xuICAgIHN0cmVhbU1hbmFnZXIuY2FuY2VsQWxsKHJlYXNvbik7XG4gIH07XG4gIHNvdXJjZVxuICAgIC5waXBlVG8oXG4gICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICB3cml0ZShjaHVua09ySGVhZCkge1xuICAgICAgICAgIGlmIChoZWFkRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBjaHVua09ySGVhZCBhcyBSZWNvcmQ8bnVtYmVyIHwgc3RyaW5nLCB1bmtub3duPjtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2h1bmtPckhlYWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGRlY29kZSh2YWx1ZSBhcyBhbnkpO1xuICAgICAgICAgICAgICBoZWFkW2tleV0gPSBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkRGVmZXJyZWQucmVzb2x2ZShoZWFkIGFzIFRIZWFkKTtcbiAgICAgICAgICAgIGhlYWREZWZlcnJlZCA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua09ySGVhZCBhcyBDaHVua0RhdGE7XG4gICAgICAgICAgY29uc3QgW2lkeF0gPSBjaHVuaztcblxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW1NYW5hZ2VyLmdldE9yQ3JlYXRlKGlkeCk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6ICgpID0+IGNsb3NlT3JBYm9ydChuZXcgRXJyb3IoJ1N0cmVhbSBjbG9zZWQnKSksXG4gICAgICAgIGFib3J0OiBjbG9zZU9yQWJvcnQsXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsOiBvcHRzLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICB9LFxuICAgIClcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBvcHRzLm9uRXJyb3I/Lih7IGVycm9yIH0pO1xuICAgICAgY2xvc2VPckFib3J0KGVycm9yKTtcbiAgICB9KTtcblxuICByZXR1cm4gW2F3YWl0IGhlYWREZWZlcnJlZC5wcm9taXNlLCBzdHJlYW1NYW5hZ2VyXSBhcyBjb25zdDtcbn1cbiIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbmZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlKHQpIHtcbiAgdmFyIGUgPSB7fSxcbiAgICBuID0gITE7XG4gIGZ1bmN0aW9uIHB1bXAoZSwgcikge1xuICAgIHJldHVybiBuID0gITAsIHIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAobikge1xuICAgICAgbih0W2VdKHIpKTtcbiAgICB9KSwge1xuICAgICAgZG9uZTogITEsXG4gICAgICB2YWx1ZTogbmV3IE92ZXJsb2FkWWllbGQociwgMSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBlW1widW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LCBlLm5leHQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBuID8gKG4gPSAhMSwgdCkgOiBwdW1wKFwibmV4dFwiLCB0KTtcbiAgfSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0W1widGhyb3dcIl0gJiYgKGVbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKG4pIHRocm93IG4gPSAhMSwgdDtcbiAgICByZXR1cm4gcHVtcChcInRocm93XCIsIHQpO1xuICB9KSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0W1wicmV0dXJuXCJdICYmIChlW1wicmV0dXJuXCJdID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gbiA/IChuID0gITEsIHQpIDogcHVtcChcInJldHVyblwiLCB0KTtcbiAgfSksIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY0dlbmVyYXRvckRlbGVnYXRlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHsgVW5wcm9taXNlIH0gZnJvbSAnLi4vLi4vdmVuZG9yL3VucHJvbWlzZSc7XG5pbXBvcnQgeyBnZXRUUlBDRXJyb3JGcm9tVW5rbm93biB9IGZyb20gJy4uL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgeyBpc0Fib3J0RXJyb3IgfSBmcm9tICcuLi9odHRwL2Fib3J0RXJyb3InO1xuaW1wb3J0IHR5cGUgeyBNYXliZVByb21pc2UgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpZGVudGl0eSwgcnVuIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBFdmVudFNvdXJjZUxpa2UgfSBmcm9tICcuL3NzZS50eXBlcyc7XG5pbXBvcnQgdHlwZSB7IGluZmVyVHJhY2tlZE91dHB1dCB9IGZyb20gJy4vdHJhY2tlZCc7XG5pbXBvcnQgeyBpc1RyYWNrZWRFbnZlbG9wZSB9IGZyb20gJy4vdHJhY2tlZCc7XG5pbXBvcnQgeyB0YWtlV2l0aEdyYWNlLCB3aXRoTWF4RHVyYXRpb24gfSBmcm9tICcuL3V0aWxzL2FzeW5jSXRlcmFibGUnO1xuaW1wb3J0IHsgbWFrZUFzeW5jUmVzb3VyY2UgfSBmcm9tICcuL3V0aWxzL2Rpc3Bvc2FibGUnO1xuaW1wb3J0IHsgcmVhZGFibGVTdHJlYW1Gcm9tIH0gZnJvbSAnLi91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20nO1xuaW1wb3J0IHtcbiAgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCxcbiAgdGltZXJSZXNvdXJjZSxcbn0gZnJvbSAnLi91dGlscy90aW1lclJlc291cmNlJztcbmltcG9ydCB7IFBJTkdfU1lNLCB3aXRoUGluZyB9IGZyb20gJy4vdXRpbHMvd2l0aFBpbmcnO1xuXG50eXBlIFNlcmlhbGl6ZSA9ICh2YWx1ZTogYW55KSA9PiBhbnk7XG50eXBlIERlc2VyaWFsaXplID0gKHZhbHVlOiBhbnkpID0+IGFueTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTU0VQaW5nT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBFbmFibGUgcGluZyBjb21tZW50cyBzZW50IGZyb20gdGhlIHNlcnZlclxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAZGVmYXVsdCAxMDAwXG4gICAqL1xuICBpbnRlcnZhbE1zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNTRUNsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogVGltZW91dCBhbmQgcmVjb25uZWN0IGFmdGVyIGluYWN0aXZpdHkgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU1NFU3RyZWFtUHJvZHVjZXJPcHRpb25zPFRWYWx1ZSA9IHVua25vd24+IHtcbiAgc2VyaWFsaXplPzogU2VyaWFsaXplO1xuICBkYXRhOiBBc3luY0l0ZXJhYmxlPFRWYWx1ZT47XG5cbiAgbWF4RGVwdGg/OiBudW1iZXI7XG4gIHBpbmc/OiBTU0VQaW5nT3B0aW9ucztcbiAgLyoqXG4gICAqIE1heGltdW0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgcmVxdWVzdCBiZWZvcmUgZW5kaW5nIHRoZSBzdHJlYW1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBtYXhEdXJhdGlvbk1zPzogbnVtYmVyO1xuICAvKipcbiAgICogRW5kIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5IGFmdGVyIGRhdGEgaXMgc2VudFxuICAgKiBPbmx5IHVzZWZ1bCBmb3Igc2VydmVybGVzcyBydW50aW1lcyB0aGF0IGRvIG5vdCBzdXBwb3J0IHN0cmVhbWluZyByZXNwb25zZXNcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVtaXRBbmRFbmRJbW1lZGlhdGVseT86IGJvb2xlYW47XG4gIGZvcm1hdEVycm9yPzogKG9wdHM6IHsgZXJyb3I6IHVua25vd24gfSkgPT4gdW5rbm93bjtcbiAgLyoqXG4gICAqIENsaWVudC1zcGVjaWZpYyBvcHRpb25zIC0gdGhlc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBjbGllbnQgYXMgcGFydCBvZiB0aGUgZmlyc3QgbWVzc2FnZVxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY2xpZW50PzogU1NFQ2xpZW50T3B0aW9ucztcbn1cblxuY29uc3QgUElOR19FVkVOVCA9ICdwaW5nJztcbmNvbnN0IFNFUklBTElaRURfRVJST1JfRVZFTlQgPSAnc2VyaWFsaXplZC1lcnJvcic7XG5jb25zdCBDT05ORUNURURfRVZFTlQgPSAnY29ubmVjdGVkJztcbmNvbnN0IFJFVFVSTl9FVkVOVCA9ICdyZXR1cm4nO1xuXG5pbnRlcmZhY2UgU1NFdmVudCB7XG4gIGlkPzogc3RyaW5nO1xuICBkYXRhOiB1bmtub3duO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBldmVudD86IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNzZVN0cmVhbVByb2R1Y2VyPFRWYWx1ZSA9IHVua25vd24+KFxuICBvcHRzOiBTU0VTdHJlYW1Qcm9kdWNlck9wdGlvbnM8VFZhbHVlPixcbikge1xuICBjb25zdCB7IHNlcmlhbGl6ZSA9IGlkZW50aXR5IH0gPSBvcHRzO1xuXG4gIGNvbnN0IHBpbmc6IFJlcXVpcmVkPFNTRVBpbmdPcHRpb25zPiA9IHtcbiAgICBlbmFibGVkOiBvcHRzLnBpbmc/LmVuYWJsZWQgPz8gZmFsc2UsXG4gICAgaW50ZXJ2YWxNczogb3B0cy5waW5nPy5pbnRlcnZhbE1zID8/IDEwMDAsXG4gIH07XG4gIGNvbnN0IGNsaWVudDogU1NFQ2xpZW50T3B0aW9ucyA9IG9wdHMuY2xpZW50ID8/IHt9O1xuXG4gIGlmIChcbiAgICBwaW5nLmVuYWJsZWQgJiZcbiAgICBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXMgJiZcbiAgICBwaW5nLmludGVydmFsTXMgPiBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXNcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFBpbmcgaW50ZXJ2YWwgbXVzdCBiZSBsZXNzIHRoYW4gY2xpZW50IHJlY29ubmVjdCBpbnRlcnZhbCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlY29ubmVjdGlvbiAtIHBpbmcuaW50ZXJ2YWxNczogJHtwaW5nLmludGVydmFsTXN9IGNsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNczogJHtjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXN9YCxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpOiBBc3luY0l0ZXJhYmxlPFNTRXZlbnQsIHZvaWQ+IHtcbiAgICB5aWVsZCB7XG4gICAgICBldmVudDogQ09OTkVDVEVEX0VWRU5ULFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoY2xpZW50KSxcbiAgICB9O1xuXG4gICAgdHlwZSBUSXRlcmF0b3JWYWx1ZSA9IEF3YWl0ZWQ8VFZhbHVlPiB8IHR5cGVvZiBQSU5HX1NZTTtcblxuICAgIGxldCBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUVmFsdWUgfCB0eXBlb2YgUElOR19TWU0+ID0gb3B0cy5kYXRhO1xuXG4gICAgaWYgKG9wdHMuZW1pdEFuZEVuZEltbWVkaWF0ZWx5KSB7XG4gICAgICBpdGVyYWJsZSA9IHRha2VXaXRoR3JhY2UoaXRlcmFibGUsIHtcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIGdyYWNlUGVyaW9kTXM6IDEsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvcHRzLm1heER1cmF0aW9uTXMgJiZcbiAgICAgIG9wdHMubWF4RHVyYXRpb25NcyA+IDAgJiZcbiAgICAgIG9wdHMubWF4RHVyYXRpb25NcyAhPT0gSW5maW5pdHlcbiAgICApIHtcbiAgICAgIGl0ZXJhYmxlID0gd2l0aE1heER1cmF0aW9uKGl0ZXJhYmxlLCB7XG4gICAgICAgIG1heER1cmF0aW9uTXM6IG9wdHMubWF4RHVyYXRpb25NcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwaW5nLmVuYWJsZWQgJiYgcGluZy5pbnRlcnZhbE1zICE9PSBJbmZpbml0eSAmJiBwaW5nLmludGVydmFsTXMgPiAwKSB7XG4gICAgICBpdGVyYWJsZSA9IHdpdGhQaW5nKGl0ZXJhYmxlLCBwaW5nLmludGVydmFsTXMpO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdGhvc2UgZGVjbGFyYXRpb25zIG91dHNpZGUgdGhlIGxvb3AgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiByZWFzb25zLiBJZiB0aGV5IHdlcmVcbiAgICAvLyBkZWNsYXJlZCBpbnNpZGUsIHRoZXkgd291bGQgbm90IGJlIGZyZWVkIHVudGlsIHRoZSBuZXh0IHZhbHVlIGlzIHByZXNlbnQuXG4gICAgbGV0IHZhbHVlOiBudWxsIHwgVEl0ZXJhdG9yVmFsdWU7XG4gICAgbGV0IGNodW5rOiBudWxsIHwgU1NFdmVudDtcblxuICAgIGZvciBhd2FpdCAodmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gUElOR19TWU0pIHtcbiAgICAgICAgeWllbGQgeyBldmVudDogUElOR19FVkVOVCwgZGF0YTogJycgfTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNodW5rID0gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpXG4gICAgICAgID8geyBpZDogdmFsdWVbMF0sIGRhdGE6IHZhbHVlWzFdIH1cbiAgICAgICAgOiB7IGRhdGE6IHZhbHVlIH07XG5cbiAgICAgIGNodW5rLmRhdGEgPSBKU09OLnN0cmluZ2lmeShzZXJpYWxpemUoY2h1bmsuZGF0YSkpO1xuXG4gICAgICB5aWVsZCBjaHVuaztcblxuICAgICAgLy8gZnJlZSB1cCByZWZlcmVuY2VzIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgIGNodW5rID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yV2l0aEVycm9ySGFuZGxpbmcoKTogQXN5bmNJdGVyYWJsZTxTU0V2ZW50LCB2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkKiBnZW5lcmF0b3IoKTtcblxuICAgICAgeWllbGQge1xuICAgICAgICBldmVudDogUkVUVVJOX0VWRU5ULFxuICAgICAgICBkYXRhOiAnJyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgIGlmIChpc0Fib3J0RXJyb3IoY2F1c2UpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBhYm9ydCBlcnJvcnMsIHNlbmQgYW55IG90aGVyIGVycm9yc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBgZXJyYCBtdXN0IGJlIGNhdXNlZCBieSBgb3B0cy5kYXRhYCwgYEpTT04uc3RyaW5naWZ5YCBvciBgc2VyaWFsaXplYC5cbiAgICAgIC8vIFNvLCBhIHVzZXIgZXJyb3IgaW4gYW55IGNhc2UuXG4gICAgICBjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBvcHRzLmZvcm1hdEVycm9yPy4oeyBlcnJvciB9KSA/PyBudWxsO1xuICAgICAgeWllbGQge1xuICAgICAgICBldmVudDogU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCxcbiAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplKGRhdGEpKSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkpO1xuXG4gIHJldHVybiBzdHJlYW1cbiAgICAucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxzdHJpbmc+KSB7XG4gICAgICAgICAgaWYgKCdldmVudCcgaW4gY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZXZlbnQ6ICR7Y2h1bmsuZXZlbnR9XFxuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnZGF0YScgaW4gY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZGF0YTogJHtjaHVuay5kYXRhfVxcbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2lkJyBpbiBjaHVuaykge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGBpZDogJHtjaHVuay5pZH1cXG5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjb21tZW50JyBpbiBjaHVuaykge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGA6ICR7Y2h1bmsuY29tbWVudH1cXG5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKCdcXG5cXG4nKTtcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIClcbiAgICAucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xufVxuXG5pbnRlcmZhY2UgQ29uc3VtZXJTdHJlYW1SZXN1bHRCYXNlPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz4ge1xuICBldmVudFNvdXJjZTogSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyU3RyZWFtUmVzdWx0RGF0YTxUQ29uZmlnIGV4dGVuZHMgQ29uc3VtZXJDb25maWc+XG4gIGV4dGVuZHMgQ29uc3VtZXJTdHJlYW1SZXN1bHRCYXNlPFRDb25maWc+IHtcbiAgdHlwZTogJ2RhdGEnO1xuICBkYXRhOiBpbmZlclRyYWNrZWRPdXRwdXQ8VENvbmZpZ1snZGF0YSddPjtcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyU3RyZWFtUmVzdWx0RXJyb3I8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICdzZXJpYWxpemVkLWVycm9yJztcbiAgZXJyb3I6IFRDb25maWdbJ2Vycm9yJ107XG59XG5cbmludGVyZmFjZSBDb25zdW1lclN0cmVhbVJlc3VsdENvbm5lY3Rpbmc8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICdjb25uZWN0aW5nJztcbiAgZXZlbnQ6IEV2ZW50U291cmNlTGlrZS5FdmVudE9mPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbDtcbn1cbmludGVyZmFjZSBDb25zdW1lclN0cmVhbVJlc3VsdFRpbWVvdXQ8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICd0aW1lb3V0JztcbiAgbXM6IG51bWJlcjtcbn1cbmludGVyZmFjZSBDb25zdW1lclN0cmVhbVJlc3VsdFBpbmc8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICdwaW5nJztcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyU3RyZWFtUmVzdWx0Q29ubmVjdGVkPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz5cbiAgZXh0ZW5kcyBDb25zdW1lclN0cmVhbVJlc3VsdEJhc2U8VENvbmZpZz4ge1xuICB0eXBlOiAnY29ubmVjdGVkJztcbiAgb3B0aW9uczogU1NFQ2xpZW50T3B0aW9ucztcbn1cblxudHlwZSBDb25zdW1lclN0cmVhbVJlc3VsdDxUQ29uZmlnIGV4dGVuZHMgQ29uc3VtZXJDb25maWc+ID1cbiAgfCBDb25zdW1lclN0cmVhbVJlc3VsdERhdGE8VENvbmZpZz5cbiAgfCBDb25zdW1lclN0cmVhbVJlc3VsdEVycm9yPFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRDb25uZWN0aW5nPFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRUaW1lb3V0PFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRQaW5nPFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRDb25uZWN0ZWQ8VENvbmZpZz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU1NFU3RyZWFtQ29uc3VtZXJPcHRpb25zPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz4ge1xuICB1cmw6ICgpID0+IE1heWJlUHJvbWlzZTxzdHJpbmc+O1xuICBpbml0OiAoKSA9PlxuICAgIHwgTWF5YmVQcm9taXNlPEV2ZW50U291cmNlTGlrZS5Jbml0RGljdE9mPFRDb25maWdbJ0V2ZW50U291cmNlJ10+PlxuICAgIHwgdW5kZWZpbmVkO1xuICBzaWduYWw6IEFib3J0U2lnbmFsO1xuICBkZXNlcmlhbGl6ZT86IERlc2VyaWFsaXplO1xuICBFdmVudFNvdXJjZTogVENvbmZpZ1snRXZlbnRTb3VyY2UnXTtcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyQ29uZmlnIHtcbiAgZGF0YTogdW5rbm93bjtcbiAgZXJyb3I6IHVua25vd247XG4gIEV2ZW50U291cmNlOiBFdmVudFNvdXJjZUxpa2UuQW55Q29uc3RydWN0b3I7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0PFQ+KG9wdHM6IHtcbiAgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgdGltZW91dE1zOiBudW1iZXI7XG4gIG9uVGltZW91dDogKCkgPT4gUHJvbWlzZTxOb0luZmVyPFQ+Pjtcbn0pOiBQcm9taXNlPFQ+IHtcbiAgdXNpbmcgdGltZW91dFByb21pc2UgPSB0aW1lclJlc291cmNlKG9wdHMudGltZW91dE1zKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW29wdHMucHJvbWlzZSwgdGltZW91dFByb21pc2Uuc3RhcnQoKV0pO1xuXG4gIGlmIChyZXMgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHtcbiAgICByZXR1cm4gYXdhaXQgb3B0cy5vblRpbWVvdXQoKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNzZVN0cmVhbUNvbnN1bWVyPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz4oXG4gIG9wdHM6IFNTRVN0cmVhbUNvbnN1bWVyT3B0aW9uczxUQ29uZmlnPixcbik6IEFzeW5jSXRlcmFibGU8Q29uc3VtZXJTdHJlYW1SZXN1bHQ8VENvbmZpZz4+IHtcbiAgY29uc3QgeyBkZXNlcmlhbGl6ZSA9ICh2KSA9PiB2IH0gPSBvcHRzO1xuXG4gIGxldCBjbGllbnRPcHRpb25zOiBTU0VDbGllbnRPcHRpb25zID0ge307XG5cbiAgY29uc3Qgc2lnbmFsID0gb3B0cy5zaWduYWw7XG5cbiAgbGV0IF9lczogSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT5cbiAgICBuZXcgUmVhZGFibGVTdHJlYW08Q29uc3VtZXJTdHJlYW1SZXN1bHQ8VENvbmZpZz4+KHtcbiAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgW3VybCwgaW5pdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbb3B0cy51cmwoKSwgb3B0cy5pbml0KCldKTtcbiAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSAoX2VzID0gbmV3IG9wdHMuRXZlbnRTb3VyY2UoXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGluaXQsXG4gICAgICAgICkgYXMgSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+KTtcblxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW5nJyxcbiAgICAgICAgICBldmVudFNvdXJjZTogX2VzLFxuICAgICAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKENPTk5FQ1RFRF9FVkVOVCwgKF9tc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBfbXNnIGFzIEV2ZW50U291cmNlTGlrZS5NZXNzYWdlRXZlbnQ7XG5cbiAgICAgICAgICBjb25zdCBvcHRpb25zOiBTU0VDbGllbnRPcHRpb25zID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cbiAgICAgICAgICBjbGllbnRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCwgKF9tc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBfbXNnIGFzIEV2ZW50U291cmNlTGlrZS5NZXNzYWdlRXZlbnQ7XG5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogJ3NlcmlhbGl6ZWQtZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGRlc2VyaWFsaXplKEpTT04ucGFyc2UobXNnLmRhdGEpKSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihQSU5HX0VWRU5ULCAoKSA9PiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6ICdwaW5nJyxcbiAgICAgICAgICAgIGV2ZW50U291cmNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihSRVRVUk5fRVZFTlQsICgpID0+IHtcbiAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICBfZXMgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSA9PT0gZXZlbnRTb3VyY2UuQ0xPU0VEKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Nvbm5lY3RpbmcnLFxuICAgICAgICAgICAgICBldmVudFNvdXJjZSxcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKF9tc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBfbXNnIGFzIEV2ZW50U291cmNlTGlrZS5NZXNzYWdlRXZlbnQ7XG5cbiAgICAgICAgICBjb25zdCBjaHVuayA9IGRlc2VyaWFsaXplKEpTT04ucGFyc2UobXNnLmRhdGEpKTtcblxuICAgICAgICAgIGNvbnN0IGRlZjogU1NFdmVudCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG1zZy5sYXN0RXZlbnRJZCkge1xuICAgICAgICAgICAgZGVmLmlkID0gbXNnLmxhc3RFdmVudElkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgZGF0YTogZGVmIGFzIGluZmVyVHJhY2tlZE91dHB1dDxUQ29uZmlnWydkYXRhJ10+LFxuICAgICAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIGNhc2UgdGhlIGNvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIG9uQWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgX2VzPy5jbG9zZSgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICBjb25zdCBnZXRTdHJlYW1SZXNvdXJjZSA9ICgpID0+IHtcbiAgICBsZXQgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG4gICAgbGV0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICBfZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlQXN5bmNSZXNvdXJjZShcbiAgICAgIHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcmVjcmVhdGUoKSB7XG4gICAgICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuXG4gICAgICAgICAgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG4gICAgICAgICAgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRpc3Bvc2UsXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gcnVuKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgYXdhaXQgdXNpbmcgc3RyZWFtID0gZ2V0U3RyZWFtUmVzb3VyY2UoKTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IHN0cmVhbS5yZWFkKCk7XG5cbiAgICAgIGNvbnN0IHRpbWVvdXRNcyA9IGNsaWVudE9wdGlvbnMucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXM7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIHByb21pc2UgPSB3aXRoVGltZW91dCh7XG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICB0aW1lb3V0TXMsXG4gICAgICAgICAgb25UaW1lb3V0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXM6IEF3YWl0ZWQ8dHlwZW9mIHByb21pc2U+ID0ge1xuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0aW1lb3V0JyxcbiAgICAgICAgICAgICAgICBtczogdGltZW91dE1zLFxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiBfZXMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENsb3NlIGFuZCByZWxlYXNlIG9sZCByZWFkZXJcbiAgICAgICAgICAgIGF3YWl0IHN0cmVhbS5yZWNyZWF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuXG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3Qgc3NlSGVhZGVycyA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2V2ZW50LXN0cmVhbScsXG4gICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby10cmFuc2Zvcm0nLFxuICAnWC1BY2NlbC1CdWZmZXJpbmcnOiAnbm8nLFxuICBDb25uZWN0aW9uOiAna2VlcC1hbGl2ZScsXG59IGFzIGNvbnN0O1xuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqL1xuaW1wb3J0IHtcbiAgaXNPYnNlcnZhYmxlLFxuICBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlLFxufSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL29ic2VydmFibGUnO1xuaW1wb3J0IHsgZ2V0RXJyb3JTaGFwZSB9IGZyb20gJy4uL2Vycm9yL2dldEVycm9yU2hhcGUnO1xuaW1wb3J0IHsgZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24sIFRSUENFcnJvciB9IGZyb20gJy4uL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgdHlwZSB7IFByb2NlZHVyZVR5cGUgfSBmcm9tICcuLi9wcm9jZWR1cmUnO1xuaW1wb3J0IHtcbiAgdHlwZSBBbnlSb3V0ZXIsXG4gIHR5cGUgaW5mZXJSb3V0ZXJDb250ZXh0LFxuICB0eXBlIGluZmVyUm91dGVyRXJyb3IsXG59IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgdHlwZSB7IFRSUENSZXNwb25zZSB9IGZyb20gJy4uL3JwYyc7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGpzb25sU3RyZWFtUHJvZHVjZXIgfSBmcm9tICcuLi9zdHJlYW0vanNvbmwnO1xuaW1wb3J0IHsgc3NlSGVhZGVycywgc3NlU3RyZWFtUHJvZHVjZXIgfSBmcm9tICcuLi9zdHJlYW0vc3NlJztcbmltcG9ydCB7IHRyYW5zZm9ybVRSUENSZXNwb25zZSB9IGZyb20gJy4uL3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IGlzQXN5bmNJdGVyYWJsZSwgaXNPYmplY3QsIHJ1biB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJlcXVlc3RJbmZvIH0gZnJvbSAnLi9jb250ZW50VHlwZSc7XG5pbXBvcnQgeyBnZXRIVFRQU3RhdHVzQ29kZSB9IGZyb20gJy4vZ2V0SFRUUFN0YXR1c0NvZGUnO1xuaW1wb3J0IHR5cGUge1xuICBIVFRQQmFzZUhhbmRsZXJPcHRpb25zLFxuICBSZXNvbHZlSFRUUFJlcXVlc3RPcHRpb25zQ29udGV4dEZuLFxuICBUUlBDUmVxdWVzdEluZm8sXG59IGZyb20gJy4vdHlwZXMnO1xuXG5mdW5jdGlvbiBlcnJvclRvQXN5bmNJdGVyYWJsZShlcnI6IFRSUENFcnJvcik6IEFzeW5jSXRlcmFibGU8bmV2ZXI+IHtcbiAgcmV0dXJuIHJ1bihhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG50eXBlIEhUVFBNZXRob2RzID1cbiAgfCAnR0VUJ1xuICB8ICdQT1NUJ1xuICB8ICdIRUFEJ1xuICB8ICdPUFRJT05TJ1xuICB8ICdQVVQnXG4gIHwgJ0RFTEVURSdcbiAgfCAnUEFUQ0gnO1xuXG5jb25zdCBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA6IFJlY29yZDxQcm9jZWR1cmVUeXBlLCBIVFRQTWV0aG9kc1tdPiA9IHtcbiAgbXV0YXRpb246IFsnUE9TVCddLFxuICBxdWVyeTogWydHRVQnXSxcbiAgc3Vic2NyaXB0aW9uOiBbJ0dFVCddLFxufTtcbmNvbnN0IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERTogUmVjb3JkPFxuICBQcm9jZWR1cmVUeXBlLFxuICBIVFRQTWV0aG9kc1tdXG4+ID0ge1xuICAvLyBuZXZlciBhbGxvdyBHRVQgdG8gZG8gYSBtdXRhdGlvblxuICBtdXRhdGlvbjogWydQT1NUJ10sXG4gIHF1ZXJ5OiBbJ0dFVCcsICdQT1NUJ10sXG4gIHN1YnNjcmlwdGlvbjogWydHRVQnLCAnUE9TVCddLFxufTtcblxuaW50ZXJmYWNlIFJlc29sdmVIVFRQUmVxdWVzdE9wdGlvbnM8VFJvdXRlciBleHRlbmRzIEFueVJvdXRlcj5cbiAgZXh0ZW5kcyBIVFRQQmFzZUhhbmRsZXJPcHRpb25zPFRSb3V0ZXIsIFJlcXVlc3Q+IHtcbiAgY3JlYXRlQ29udGV4dDogUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uc0NvbnRleHRGbjxUUm91dGVyPjtcbiAgcmVxOiBSZXF1ZXN0O1xuICBwYXRoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBoYWQgYW4gaXNzdWUgYmVmb3JlIHJlYWNoaW5nIHRoZSBoYW5kbGVyXG4gICAqL1xuICBlcnJvcjogVFJQQ0Vycm9yIHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdFJlc3BvbnNlPFRSb3V0ZXIgZXh0ZW5kcyBBbnlSb3V0ZXIsIFRSZXF1ZXN0Pihpbml0T3B0czoge1xuICBjdHg6IGluZmVyUm91dGVyQ29udGV4dDxUUm91dGVyPiB8IHVuZGVmaW5lZDtcbiAgaW5mbzogVFJQQ1JlcXVlc3RJbmZvIHwgdW5kZWZpbmVkO1xuICByZXNwb25zZU1ldGE/OiBIVFRQQmFzZUhhbmRsZXJPcHRpb25zPFRSb3V0ZXIsIFRSZXF1ZXN0PlsncmVzcG9uc2VNZXRhJ107XG4gIHVudHJhbnNmb3JtZWRKU09OOlxuICAgIHwgVFJQQ1Jlc3BvbnNlPHVua25vd24sIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+XG4gICAgfCBUUlBDUmVzcG9uc2U8dW5rbm93biwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj5bXVxuICAgIHwgbnVsbDtcbiAgZXJyb3JzOiBUUlBDRXJyb3JbXTtcbiAgaGVhZGVyczogSGVhZGVycztcbn0pIHtcbiAgY29uc3Qge1xuICAgIGN0eCxcbiAgICBpbmZvLFxuICAgIHJlc3BvbnNlTWV0YSxcbiAgICB1bnRyYW5zZm9ybWVkSlNPTixcbiAgICBlcnJvcnMgPSBbXSxcbiAgICBoZWFkZXJzLFxuICB9ID0gaW5pdE9wdHM7XG5cbiAgbGV0IHN0YXR1cyA9IHVudHJhbnNmb3JtZWRKU09OID8gZ2V0SFRUUFN0YXR1c0NvZGUodW50cmFuc2Zvcm1lZEpTT04pIDogMjAwO1xuXG4gIGNvbnN0IGVhZ2VyR2VuZXJhdGlvbiA9ICF1bnRyYW5zZm9ybWVkSlNPTjtcbiAgY29uc3QgZGF0YSA9IGVhZ2VyR2VuZXJhdGlvblxuICAgID8gW11cbiAgICA6IEFycmF5LmlzQXJyYXkodW50cmFuc2Zvcm1lZEpTT04pXG4gICAgICA/IHVudHJhbnNmb3JtZWRKU09OXG4gICAgICA6IFt1bnRyYW5zZm9ybWVkSlNPTl07XG5cbiAgY29uc3QgbWV0YSA9XG4gICAgcmVzcG9uc2VNZXRhPy4oe1xuICAgICAgY3R4LFxuICAgICAgaW5mbyxcbiAgICAgIHBhdGhzOiBpbmZvPy5jYWxscy5tYXAoKGNhbGwpID0+IGNhbGwucGF0aCksXG4gICAgICBkYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgZWFnZXJHZW5lcmF0aW9uLFxuICAgICAgdHlwZTpcbiAgICAgICAgaW5mbz8uY2FsbHMuZmluZCgoY2FsbCkgPT4gY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSk/LnByb2NlZHVyZT8uX2RlZlxuICAgICAgICAgIC50eXBlID8/ICd1bmtub3duJyxcbiAgICB9KSA/PyB7fTtcblxuICBpZiAobWV0YS5oZWFkZXJzKSB7XG4gICAgaWYgKG1ldGEuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1ldGEuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQsIGRlbGV0ZSBpbiB2MTJcbiAgICAgICAqL1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YS5oZWFkZXJzKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobWV0YS5zdGF0dXMpIHtcbiAgICBzdGF0dXMgPSBtZXRhLnN0YXR1cztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjYXVnaHRFcnJvclRvRGF0YTxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPihcbiAgY2F1c2U6IHVua25vd24sXG4gIGVycm9yT3B0czoge1xuICAgIG9wdHM6IFBpY2s8XG4gICAgICBSZXNvbHZlSFRUUFJlcXVlc3RPcHRpb25zPFRSb3V0ZXI+LFxuICAgICAgJ29uRXJyb3InIHwgJ3JlcScgfCAncm91dGVyJ1xuICAgID47XG4gICAgY3R4OiBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlcj4gfCB1bmRlZmluZWQ7XG4gICAgdHlwZTogUHJvY2VkdXJlVHlwZSB8ICd1bmtub3duJztcbiAgICBwYXRoPzogc3RyaW5nO1xuICAgIGlucHV0PzogdW5rbm93bjtcbiAgfSxcbikge1xuICBjb25zdCB7IHJvdXRlciwgcmVxLCBvbkVycm9yIH0gPSBlcnJvck9wdHMub3B0cztcbiAgY29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSk7XG4gIG9uRXJyb3I/Lih7XG4gICAgZXJyb3IsXG4gICAgcGF0aDogZXJyb3JPcHRzLnBhdGgsXG4gICAgaW5wdXQ6IGVycm9yT3B0cy5pbnB1dCxcbiAgICBjdHg6IGVycm9yT3B0cy5jdHgsXG4gICAgdHlwZTogZXJyb3JPcHRzLnR5cGUsXG4gICAgcmVxLFxuICB9KTtcbiAgY29uc3QgdW50cmFuc2Zvcm1lZEpTT04gPSB7XG4gICAgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuICAgICAgY29uZmlnOiByb3V0ZXIuX2RlZi5fY29uZmlnLFxuICAgICAgZXJyb3IsXG4gICAgICB0eXBlOiBlcnJvck9wdHMudHlwZSxcbiAgICAgIHBhdGg6IGVycm9yT3B0cy5wYXRoLFxuICAgICAgaW5wdXQ6IGVycm9yT3B0cy5pbnB1dCxcbiAgICAgIGN0eDogZXJyb3JPcHRzLmN0eCxcbiAgICB9KSxcbiAgfTtcbiAgY29uc3QgdHJhbnNmb3JtZWRKU09OID0gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKFxuICAgIHJvdXRlci5fZGVmLl9jb25maWcsXG4gICAgdW50cmFuc2Zvcm1lZEpTT04sXG4gICk7XG4gIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEpTT04pO1xuICByZXR1cm4ge1xuICAgIGVycm9yLFxuICAgIHVudHJhbnNmb3JtZWRKU09OLFxuICAgIGJvZHksXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHN0cmVhbS1saWtlIG9iamVjdFxuICogLSBpZiBpdCdzIGFuIGFzeW5jIGl0ZXJhYmxlXG4gKiAtIGlmIGl0J3MgYW4gb2JqZWN0IHdpdGggYXN5bmMgaXRlcmFibGVzIG9yIHByb21pc2VzXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cmVhbSh2OiB1bmtub3duKSB7XG4gIGlmICghaXNPYmplY3QodikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHYpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIE9iamVjdC52YWx1ZXModikuc29tZShpc1Byb21pc2UpIHx8IE9iamVjdC52YWx1ZXModikuc29tZShpc0FzeW5jSXRlcmFibGUpXG4gICk7XG59XG5cbnR5cGUgUmVzdWx0VHVwbGU8VD4gPSBbdW5kZWZpbmVkLCBUXSB8IFtUUlBDRXJyb3IsIHVuZGVmaW5lZF07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUmVzcG9uc2U8VFJvdXRlciBleHRlbmRzIEFueVJvdXRlcj4oXG4gIG9wdHM6IFJlc29sdmVIVFRQUmVxdWVzdE9wdGlvbnM8VFJvdXRlcj4sXG4pOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gIGNvbnN0IHsgcm91dGVyLCByZXEgfSA9IG9wdHM7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhbWyd2YXJ5JywgJ3RycGMtYWNjZXB0J11dKTtcbiAgY29uc3QgY29uZmlnID0gcm91dGVyLl9kZWYuX2NvbmZpZztcblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuXG4gIGlmIChyZXEubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAvLyBjYW4gYmUgdXNlZCBmb3IgbGFtYmRhIHdhcm11cFxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgc3RhdHVzOiAyMDQsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBhbGxvd0JhdGNoaW5nID0gb3B0cy5hbGxvd0JhdGNoaW5nID8/IG9wdHMuYmF0Y2hpbmc/LmVuYWJsZWQgPz8gdHJ1ZTtcbiAgY29uc3QgYWxsb3dNZXRob2RPdmVycmlkZSA9XG4gICAgKG9wdHMuYWxsb3dNZXRob2RPdmVycmlkZSA/PyBmYWxzZSkgJiYgcmVxLm1ldGhvZCA9PT0gJ1BPU1QnO1xuXG4gIHR5cGUgJENvbnRleHQgPSBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlcj47XG5cbiAgY29uc3QgaW5mb1R1cGxlOiBSZXN1bHRUdXBsZTxUUlBDUmVxdWVzdEluZm8+ID0gYXdhaXQgcnVuKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBhd2FpdCBnZXRSZXF1ZXN0SW5mbyh7XG4gICAgICAgICAgcmVxLFxuICAgICAgICAgIHBhdGg6IGRlY29kZVVSSUNvbXBvbmVudChvcHRzLnBhdGgpLFxuICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgaGVhZGVyczogb3B0cy5yZXEuaGVhZGVycyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgIH0pLFxuICAgICAgXTtcbiAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgcmV0dXJuIFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHVuZGVmaW5lZF07XG4gICAgfVxuICB9KTtcblxuICBpbnRlcmZhY2UgQ29udGV4dE1hbmFnZXIge1xuICAgIHZhbHVlT3JVbmRlZmluZWQ6ICgpID0+ICRDb250ZXh0IHwgdW5kZWZpbmVkO1xuICAgIHZhbHVlOiAoKSA9PiAkQ29udGV4dDtcbiAgICBjcmVhdGU6IChpbmZvOiBUUlBDUmVxdWVzdEluZm8pID0+IFByb21pc2U8dm9pZD47XG4gIH1cbiAgY29uc3QgY3R4TWFuYWdlcjogQ29udGV4dE1hbmFnZXIgPSBydW4oKCkgPT4ge1xuICAgIGxldCByZXN1bHQ6IFJlc3VsdFR1cGxlPCRDb250ZXh0PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVPclVuZGVmaW5lZDogKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBbZXJyLCBjdHhdID0gcmVzdWx0ITtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZTogYXN5bmMgKGluZm8pID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIC0gcmVwb3J0IGEgYnVnIGluIHRSUEMnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdHggPSBhd2FpdCBvcHRzLmNyZWF0ZUNvbnRleHQoe1xuICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHQgPSBbdW5kZWZpbmVkLCBjdHhdO1xuICAgICAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHVuZGVmaW5lZF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0aG9kTWFwcGVyID0gYWxsb3dNZXRob2RPdmVycmlkZVxuICAgID8gVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQX1dJVEhfTUVUSE9EX09WRVJSSURFXG4gICAgOiBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBjb25zdCBpc1N0cmVhbUNhbGwgPSByZXEuaGVhZGVycy5nZXQoJ3RycGMtYWNjZXB0JykgPT09ICdhcHBsaWNhdGlvbi9qc29ubCc7XG5cbiAgY29uc3QgZXhwZXJpbWVudGFsU1NFID0gY29uZmlnLnNzZT8uZW5hYmxlZCA/PyB0cnVlO1xuICB0cnkge1xuICAgIGNvbnN0IFtpbmZvRXJyb3IsIGluZm9dID0gaW5mb1R1cGxlO1xuICAgIGlmIChpbmZvRXJyb3IpIHtcbiAgICAgIHRocm93IGluZm9FcnJvcjtcbiAgICB9XG4gICAgaWYgKGluZm8uaXNCYXRjaENhbGwgJiYgIWFsbG93QmF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBjb2RlOiAnQkFEX1JFUVVFU1QnLFxuICAgICAgICBtZXNzYWdlOiBgQmF0Y2hpbmcgaXMgbm90IGVuYWJsZWQgb24gdGhlIHNlcnZlcmAsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuICAgIGlmIChpc1N0cmVhbUNhbGwgJiYgIWluZm8uaXNCYXRjaENhbGwpIHtcbiAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgU3RyZWFtaW5nIHJlcXVlc3RzIG11c3QgYmUgYmF0Y2hlZCAoeW91IGNhbiBkbyBhIGJhdGNoIG9mIDEpYCxcbiAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBjdHhNYW5hZ2VyLmNyZWF0ZShpbmZvKTtcblxuICAgIGludGVyZmFjZSBSUENSZXN1bHRPayB7XG4gICAgICBkYXRhOiB1bmtub3duO1xuICAgIH1cbiAgICB0eXBlIFJQQ1Jlc3VsdCA9IFJlc3VsdFR1cGxlPFJQQ1Jlc3VsdE9rPjtcbiAgICBjb25zdCBycGNDYWxscyA9IGluZm8uY2FsbHMubWFwKGFzeW5jIChjYWxsKTogUHJvbWlzZTxSUENSZXN1bHQ+ID0+IHtcbiAgICAgIGNvbnN0IHByb2MgPSBjYWxsLnByb2NlZHVyZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRzLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgb3B0cy5lcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvYykge1xuICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTm8gcHJvY2VkdXJlIGZvdW5kIG9uIHBhdGggXCIke2NhbGwucGF0aH1cImAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1ldGhvZE1hcHBlcltwcm9jLl9kZWYudHlwZV0uaW5jbHVkZXMocmVxLm1ldGhvZCBhcyBIVFRQTWV0aG9kcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgJHtyZXEubWV0aG9kfS1yZXF1ZXN0IHRvICR7cHJvYy5fZGVmLnR5cGV9IHByb2NlZHVyZSBhdCBwYXRoIFwiJHtjYWxsLnBhdGh9XCJgLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2MuX2RlZi50eXBlID09PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cbiAgICAgICAgICBpZiAoaW5mby5pc0JhdGNoQ2FsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6ICdCQURfUkVRVUVTVCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgYmF0Y2ggc3Vic2NyaXB0aW9uIGNhbGxzYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhOiB1bmtub3duID0gYXdhaXQgcHJvYyh7XG4gICAgICAgICAgcGF0aDogY2FsbC5wYXRoLFxuICAgICAgICAgIGdldFJhd0lucHV0OiBjYWxsLmdldFJhd0lucHV0LFxuICAgICAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZSgpLFxuICAgICAgICAgIHR5cGU6IHByb2MuX2RlZi50eXBlLFxuICAgICAgICAgIHNpZ25hbDogb3B0cy5yZXEuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHsgZGF0YSB9XTtcbiAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IGNhbGwucmVzdWx0KCk7XG5cbiAgICAgICAgb3B0cy5vbkVycm9yPy4oe1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHBhdGg6IGNhbGwucGF0aCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgICAgIHR5cGU6IGNhbGwucHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gJ3Vua25vd24nLFxuICAgICAgICAgIHJlcTogb3B0cy5yZXEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLSByZXNwb25zZSBoYW5kbGVycyAtLS0tLS0tLS0tLVxuICAgIGlmICghaW5mby5pc0JhdGNoQ2FsbCkge1xuICAgICAgY29uc3QgW2NhbGxdID0gaW5mby5jYWxscztcbiAgICAgIGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJwY0NhbGxzWzBdITtcblxuICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5rbm93bic6XG4gICAgICAgIGNhc2UgJ211dGF0aW9uJzpcbiAgICAgICAgY2FzZSAncXVlcnknOiB7XG4gICAgICAgICAgLy8gaHR0cExpbmtcbiAgICAgICAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblxuICAgICAgICAgIGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0Py5kYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6ICdVTlNVUFBPUlRFRF9NRURJQV9UWVBFJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAnQ2Fubm90IHVzZSBzdHJlYW0tbGlrZSByZXNwb25zZSBpbiBub24tc3RyZWFtaW5nIHJlcXVlc3QgLSB1c2UgaHR0cEJhdGNoU3RyZWFtTGluaycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzOiBUUlBDUmVzcG9uc2U8dW5rbm93biwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4gPSBlcnJvclxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNhbGwhLnJlc3VsdCgpLFxuICAgICAgICAgICAgICAgICAgcGF0aDogY2FsbCEucGF0aCxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IGluZm8udHlwZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7IHJlc3VsdDogeyBkYXRhOiByZXN1bHQuZGF0YSB9IH07XG5cbiAgICAgICAgICBjb25zdCBoZWFkUmVzcG9uc2UgPSBpbml0UmVzcG9uc2Uoe1xuICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICByZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuICAgICAgICAgICAgZXJyb3JzOiBlcnJvciA/IFtlcnJvcl0gOiBbXSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB1bnRyYW5zZm9ybWVkSlNPTjogW3Jlc10sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybVRSUENSZXNwb25zZShjb25maWcsIHJlcykpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3Vic2NyaXB0aW9uJzoge1xuICAgICAgICAgIC8vIGh0dHBTdWJzY3JpcHRpb25MaW5rXG5cbiAgICAgICAgICBjb25zdCBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTx1bmtub3duPiA9IHJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yVG9Bc3luY0l0ZXJhYmxlKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXhwZXJpbWVudGFsU1NFKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvclRvQXN5bmNJdGVyYWJsZShcbiAgICAgICAgICAgICAgICBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlcmltZW50YWwgZmxhZyBcInNzZVN1YnNjcmlwdGlvbnNcIicsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNPYnNlcnZhYmxlKHJlc3VsdC5kYXRhKSAmJiAhaXNBc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyb3JUb0FzeW5jSXRlcmFibGUoXG4gICAgICAgICAgICAgICAgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU3Vic2NyaXB0aW9uICR7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwhLnBhdGhcbiAgICAgICAgICAgICAgICAgIH0gZGlkIG5vdCByZXR1cm4gYW4gb2JzZXJ2YWJsZSBvciBhIEFzeW5jR2VuZXJhdG9yYCxcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUFzSXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpXG4gICAgICAgICAgICAgID8gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSwgb3B0cy5yZXEuc2lnbmFsKVxuICAgICAgICAgICAgICA6IHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFBc0l0ZXJhYmxlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gc3NlU3RyZWFtUHJvZHVjZXIoe1xuICAgICAgICAgICAgLi4uY29uZmlnLnNzZSxcbiAgICAgICAgICAgIGRhdGE6IGl0ZXJhYmxlLFxuICAgICAgICAgICAgc2VyaWFsaXplOiAodikgPT4gY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUodiksXG4gICAgICAgICAgICBmb3JtYXRFcnJvcihlcnJvck9wdHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihlcnJvck9wdHMuZXJyb3IpO1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNhbGw/LnJlc3VsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBwYXRoID0gY2FsbD8ucGF0aDtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNhbGw/LnByb2NlZHVyZT8uX2RlZi50eXBlID8/ICd1bmtub3duJztcblxuICAgICAgICAgICAgICBvcHRzLm9uRXJyb3I/Lih7XG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgICAgICAgICAgIHJlcTogb3B0cy5yZXEsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBnZXRFcnJvclNoYXBlKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3NlSGVhZGVycykpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG4gICAgICAgICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgIHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG4gICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHVudHJhbnNmb3JtZWRKU09OOiBudWxsLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiYXRjaCByZXNwb25zZSBoYW5kbGVyc1xuICAgIGlmIChpbmZvLmFjY2VwdCA9PT0gJ2FwcGxpY2F0aW9uL2pzb25sJykge1xuICAgICAgLy8gaHR0cEJhdGNoU3RyZWFtTGlua1xuICAgICAgaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICBoZWFkZXJzLnNldCgndHJhbnNmZXItZW5jb2RpbmcnLCAnY2h1bmtlZCcpO1xuICAgICAgY29uc3QgaGVhZFJlc3BvbnNlID0gaW5pdFJlc3BvbnNlKHtcbiAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgcmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgdW50cmFuc2Zvcm1lZEpTT046IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGpzb25sU3RyZWFtUHJvZHVjZXIoe1xuICAgICAgICAuLi5jb25maWcuanNvbmwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGFtcGxlIHN0cnVjdHVyZSBmb3IgYG1heERlcHRoOiA0YDpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgIC8vIDFcbiAgICAgICAgICogICAwOiB7XG4gICAgICAgICAqICAgICAvLyAyXG4gICAgICAgICAqICAgICByZXN1bHQ6IHtcbiAgICAgICAgICogICAgICAgLy8gM1xuICAgICAgICAgKiAgICAgICBkYXRhOiAvLyA0XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBtYXhEZXB0aDogSW5maW5pdHksXG4gICAgICAgIGRhdGE6IHJwY0NhbGxzLm1hcChhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgW2Vycm9yLCByZXN1bHRdID0gYXdhaXQgcmVzO1xuXG4gICAgICAgICAgY29uc3QgY2FsbCA9IGluZm8uY2FsbHNbMF07XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvclNoYXBlKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBpbnB1dDogY2FsbCEucmVzdWx0KCksXG4gICAgICAgICAgICAgICAgcGF0aDogY2FsbCEucGF0aCxcbiAgICAgICAgICAgICAgICB0eXBlOiBjYWxsIS5wcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyAndW5rbm93bicsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBOb3QgdmVyeSBwcmV0dHksIGJ1dCB3ZSBuZWVkIHRvIHdyYXAgbmVzdGVkIGRhdGEgaW4gcHJvbWlzZXNcbiAgICAgICAgICAgKiBPdXIgc3RyZWFtIHByb2R1Y2VyIHdpbGwgb25seSByZXNvbHZlIHRvcC1sZXZlbCBhc3luYyB2YWx1ZXMgb3IgYXN5bmMgdmFsdWVzIHRoYXQgYXJlIGRpcmVjdGx5IG5lc3RlZCBpbiBhbm90aGVyIGFzeW5jIHZhbHVlXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgaXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpXG4gICAgICAgICAgICA/IG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUocmVzdWx0LmRhdGEsIG9wdHMucmVxLnNpZ25hbClcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhOiBpdGVyYWJsZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBzZXJpYWxpemU6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplLFxuICAgICAgICBvbkVycm9yOiAoY2F1c2UpID0+IHtcbiAgICAgICAgICBvcHRzLm9uRXJyb3I/Lih7XG4gICAgICAgICAgICBlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuICAgICAgICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG4gICAgICAgICAgICByZXE6IG9wdHMucmVxLFxuICAgICAgICAgICAgdHlwZTogaW5mbz8udHlwZSA/PyAndW5rbm93bicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0RXJyb3IoZXJyb3JPcHRzKSB7XG4gICAgICAgICAgY29uc3QgY2FsbCA9IGluZm8/LmNhbGxzW2Vycm9yT3B0cy5wYXRoWzBdIGFzIGFueV07XG5cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGVycm9yT3B0cy5lcnJvcik7XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBjYWxsPy5yZXN1bHQoKTtcbiAgICAgICAgICBjb25zdCBwYXRoID0gY2FsbD8ucGF0aDtcbiAgICAgICAgICBjb25zdCB0eXBlID0gY2FsbD8ucHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gJ3Vua25vd24nO1xuXG4gICAgICAgICAgLy8gbm8gbmVlZCB0byBjYWxsIGBvbkVycm9yYCBoZXJlIGFzIGl0IHdpbGwgYmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBzdHJlYW0gaXRzZWxmXG5cbiAgICAgICAgICBjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBodHRwQmF0Y2hMaW5rXG4gICAgLyoqXG4gICAgICogTm9uLXN0cmVhbWluZyByZXNwb25zZTpcbiAgICAgKiAtIGF3YWl0IGFsbCByZXNwb25zZXMgaW4gcGFyYWxsZWwsIGJsb2NraW5nIG9uIHRoZSBzbG93ZXN0IG9uZVxuICAgICAqIC0gY3JlYXRlIGhlYWRlcnMgd2l0aCBrbm93biByZXNwb25zZSBib2R5XG4gICAgICogLSByZXR1cm4gYSBjb21wbGV0ZSBIVFRQUmVzcG9uc2VcbiAgICAgKi9cbiAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBjb25zdCByZXN1bHRzOiBSUENSZXN1bHRbXSA9IChhd2FpdCBQcm9taXNlLmFsbChycGNDYWxscykpLm1hcChcbiAgICAgIChyZXMpOiBSUENSZXN1bHQgPT4ge1xuICAgICAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSByZXM7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEYXRhU3RyZWFtKHJlc3VsdC5kYXRhKSkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgY29kZTogJ1VOU1VQUE9SVEVEX01FRElBX1RZUEUnLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdDYW5ub3QgdXNlIHN0cmVhbS1saWtlIHJlc3BvbnNlIGluIG5vbi1zdHJlYW1pbmcgcmVxdWVzdCAtIHVzZSBodHRwQmF0Y2hTdHJlYW1MaW5rJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHRBc1JQQ1Jlc3BvbnNlID0gcmVzdWx0cy5tYXAoXG4gICAgICAoXG4gICAgICAgIFtlcnJvciwgcmVzdWx0XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICApOiBUUlBDUmVzcG9uc2U8dW5rbm93biwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4gPT4ge1xuICAgICAgICBjb25zdCBjYWxsID0gaW5mby5jYWxsc1tpbmRleF0hO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBpbnB1dDogY2FsbC5yZXN1bHQoKSxcbiAgICAgICAgICAgICAgcGF0aDogY2FsbC5wYXRoLFxuICAgICAgICAgICAgICB0eXBlOiBjYWxsLnByb2NlZHVyZT8uX2RlZi50eXBlID8/ICd1bmtub3duJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHsgZGF0YTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGVycm9ycyA9IHJlc3VsdHNcbiAgICAgIC5tYXAoKFtlcnJvcl0pID0+IGVycm9yKVxuICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBUUlBDRXJyb3JbXTtcblxuICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG4gICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgaW5mbyxcbiAgICAgIHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG4gICAgICB1bnRyYW5zZm9ybWVkSlNPTjogcmVzdWx0QXNSUENSZXNwb25zZSxcbiAgICAgIGVycm9ycyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgcmVzdWx0QXNSUENSZXNwb25zZSkpLFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9LFxuICAgICk7XG4gIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgY29uc3QgW19pbmZvRXJyb3IsIGluZm9dID0gaW5mb1R1cGxlO1xuICAgIGNvbnN0IGN0eCA9IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpO1xuICAgIC8vIHdlIGdldCBoZXJlIGlmXG4gICAgLy8gLSBiYXRjaGluZyBpcyBjYWxsZWQgd2hlbiBpdCdzIG5vdCBlbmFibGVkXG4gICAgLy8gLSBgY3JlYXRlQ29udGV4dCgpYCB0aHJvd3NcbiAgICAvLyAtIGByb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoKWAgdGhyb3dzXG4gICAgLy8gLSBwb3N0IGJvZHkgaXMgdG9vIGxhcmdlXG4gICAgLy8gLSBpbnB1dCBkZXNlcmlhbGl6YXRpb24gZmFpbHNcbiAgICAvLyAtIGBlcnJvckZvcm1hdHRlcmAgcmV0dXJuIHZhbHVlIGlzIG1hbGZvcm1lZFxuICAgIGNvbnN0IHsgZXJyb3IsIHVudHJhbnNmb3JtZWRKU09OLCBib2R5IH0gPSBjYXVnaHRFcnJvclRvRGF0YShjYXVzZSwge1xuICAgICAgb3B0cyxcbiAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG4gICAgICB0eXBlOiBpbmZvPy50eXBlID8/ICd1bmtub3duJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG4gICAgICBjdHgsXG4gICAgICBpbmZvLFxuICAgICAgcmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcbiAgICAgIHVudHJhbnNmb3JtZWRKU09OLFxuICAgICAgZXJyb3JzOiBbZXJyb3JdLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuICAgICAgc3RhdHVzOiBoZWFkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInBhcnNlZDogdW5rbm93biIsInN0cjogc3RyaW5nIiwiZm46ICgpID0+IFByb21pc2U8VFJldHVybj4iLCJwcm9taXNlOiBQcm9taXNlPFRSZXR1cm4+IHwgbnVsbCIsInZhbHVlOiBUUmV0dXJuIHwgdHlwZW9mIHN5bSIsImpzb25Db250ZW50VHlwZUhhbmRsZXI6IENvbnRlbnRUeXBlSGFuZGxlciIsImlucHV0czogdW5rbm93biIsImFjYzogSW5wdXRSZWNvcmQiLCJ0eXBlOiBQcm9jZWR1cmVUeXBlIHwgJ3Vua25vd24nIiwiaW5mbzogVFJQQ1JlcXVlc3RJbmZvIiwiZm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXI6IENvbnRlbnRUeXBlSGFuZGxlciIsIm9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyOiBDb250ZW50VHlwZUhhbmRsZXIiLCJyZXE6IFJlcXVlc3QiLCJoYW5kbGVyIiwib3B0czogR2V0UmVxdWVzdEluZm9PcHRpb25zIiwiZXJyb3I6IHVua25vd24iLCJhcmc6IFByb21pc2U8VD4gfCBQcm9taXNlTGlrZTxUPiB8IFByb21pc2VFeGVjdXRvcjxUPiIsInByb21pc2U6IFByb21pc2U8VD4iLCJ1bnN1YnNjcmliZTogKCkgPT4gdm9pZCIsIm9uZnVsZmlsbGVkPzpcbiAgICAgIHwgKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pXG4gICAgICB8IG51bGwiLCJvbnJlamVjdGVkPzpcbiAgICAgIHwgKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pXG4gICAgICB8IG51bGwiLCJvbnJlamVjdGVkPzpcbiAgICAgIHwgKChyZWFzb246IGFueSkgPT4gVFJlc3VsdCB8IFByb21pc2VMaWtlPFRSZXN1bHQ+KVxuICAgICAgfCBudWxsIiwib25maW5hbGx5PzogKCgpID0+IHZvaWQpIHwgbnVsbCIsInByb21pc2U6IFByb21pc2VMaWtlPFQ+IiwidmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPiIsInZhbHVlczogSXRlcmFibGU8VCB8IFByb21pc2VMaWtlPFQ+PiIsInByb21pc2VzOiByZWFkb25seSBUUHJvbWlzZVtdIiwicHJvbWlzZTogVFByb21pc2UiLCJyZXNvbHZlITogUHJvbWlzZVdpdGhSZXNvbHZlcnM8VD5bXCJyZXNvbHZlXCJdIiwicmVqZWN0ITogUHJvbWlzZVdpdGhSZXNvbHZlcnM8VD5bXCJyZWplY3RcIl0iLCJhcnI6IHJlYWRvbmx5IFRbXSIsIm1lbWJlcjogVCIsImluZGV4OiBudW1iZXIiLCJtZW1iZXI6IHVua25vd24iLCJ0aGluZzogVCIsImRpc3Bvc2U6ICgpID0+IHZvaWQiLCJkaXNwb3NlOiAoKSA9PiBQcm9taXNlPHZvaWQ+IiwibXM6IG51bWJlciIsInRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGwiLCJyIiwiZSIsIm4iLCJvIiwiT3ZlcmxvYWRZaWVsZCIsIl9hd2FpdEFzeW5jR2VuZXJhdG9yIiwiX3dyYXBBc3luY0dlbmVyYXRvciIsInQiLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIFRSZXR1cm4sIFROZXh0PiIsIml0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFQ+Iiwib3B0czogeyBtYXhEdXJhdGlvbk1zOiBudW1iZXIgfSIsInJlc3VsdDogbnVsbCB8IEl0ZXJhdG9yUmVzdWx0PFQ+IHwgdHlwZW9mIGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQiLCJvcHRzOiB7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICBncmFjZVBlcmlvZE1zOiBudW1iZXI7XG4gIH0iLCJyZXNvbHZlOiAodmFsdWU6IFRWYWx1ZSkgPT4gdm9pZCIsInJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkIiwiaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCBUUmV0dXJuPiIsIm9uUmVzdWx0OiAocmVzdWx0OiBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCBUUmV0dXJuPikgPT4gdm9pZCIsInN0YXRlOiAnaWRsZScgfCAncGVuZGluZycgfCAnZG9uZSciLCJpdGVyYWJsZXM6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCB2b2lkLCB1bmtub3duPltdIiwiYnVmZmVyOiBBcnJheTxcbiAgICBbXG4gICAgICBpdGVyYXRvcjogTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgdm9pZD4sXG4gICAgICByZXN1bHQ6IEV4Y2x1ZGU8XG4gICAgICAgIE1hbmFnZWRJdGVyYXRvclJlc3VsdDxUWWllbGQsIHZvaWQ+LFxuICAgICAgICB7IHN0YXR1czogJ3JldHVybicgfVxuICAgICAgPixcbiAgICBdXG4gID4iLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQsIHVua25vd24+IiwiZXJyb3JzOiB1bmtub3duW10iLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQ+IiwiaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFZhbHVlPiIsInBpbmdJbnRlcnZhbE1zOiBudW1iZXIiLCJyZXN1bHQ6XG4gICAgfCBudWxsXG4gICAgfCBJdGVyYXRvclJlc3VsdDxUVmFsdWU+XG4gICAgfCB0eXBlb2YgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCIsIl9hc3luY0l0ZXJhdG9yIiwiQXN5bmNGcm9tU3luY0l0ZXJhdG9yIiwidmFsdWU6IHVua25vd24iLCJwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdIiwib3B0czogSlNPTkxQcm9kdWNlck9wdGlvbnMiLCJjYWxsYmFjazogKGlkeDogQ2h1bmtJbmRleCkgPT4gQXN5bmNJdGVyYWJsZTxDaHVua0RhdGEsIHZvaWQ+IiwiaXRlcmFibGUiLCJwcm9taXNlOiBQcm9taXNlPHVua25vd24+IiwiaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8dW5rbm93bj4iLCJuZXdPYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IiwiYXN5bmNWYWx1ZXM6IENodW5rRGVmaW5pdGlvbltdIiwibmV3SGVhZDogSGVhZCIsIml0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPENodW5rRGF0YSB8IHR5cGVvZiBQSU5HX1NZTSwgdm9pZD4iLCJkYXRhOiB1bmtub3duIiwic291cmNlOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlIiwiZnJvbTogTm9kZUpTUmVhZGFibGVTdHJlYW1Fc3F1ZSB8IFdlYlJlYWRhYmxlU3RyZWFtRXNxdWUiLCJjaHVuazogQ2h1bmtEYXRhIiwiYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIiLCJvcmlnaW5hbENvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Q2h1bmtEYXRhPiIsInY6IENodW5rRGF0YSIsInJlYXNvbjogdW5rbm93biIsImNodW5rSWQ6IENodW5rSW5kZXgiLCJvcHRzOiB7XG4gIGZyb206IE5vZGVKU1JlYWRhYmxlU3RyZWFtRXNxdWUgfCBXZWJSZWFkYWJsZVN0cmVhbUVzcXVlO1xuICBkZXNlcmlhbGl6ZT86IERlc2VyaWFsaXplO1xuICBvbkVycm9yPzogQ29uc3VtZXJPbkVycm9yO1xuICBmb3JtYXRFcnJvcj86IChvcHRzOiB7IGVycm9yOiB1bmtub3duIH0pID0+IEVycm9yO1xuICAvKipcbiAgICogVGhpcyBgQWJvcnRDb250cm9sbGVyYCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG59IiwiaGVhZERlZmVycmVkOiBudWxsIHwgRGVmZXJyZWQ8VEhlYWQ+IiwidmFsdWU6IENodW5rRGVmaW5pdGlvbiIsInZhbHVlIiwidmFsdWU6IEVuY29kZWRWYWx1ZSIsIl9hc3luY0dlbmVyYXRvckRlbGVnYXRlIiwib3B0czogU1NFU3RyZWFtUHJvZHVjZXJPcHRpb25zPFRWYWx1ZT4iLCJwaW5nOiBSZXF1aXJlZDxTU0VQaW5nT3B0aW9ucz4iLCJjbGllbnQ6IFNTRUNsaWVudE9wdGlvbnMiLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUVmFsdWUgfCB0eXBlb2YgUElOR19TWU0+IiwidmFsdWU6IG51bGwgfCBUSXRlcmF0b3JWYWx1ZSIsImNodW5rOiBudWxsIHwgU1NFdmVudCIsImNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPHN0cmluZz4iLCJvcHRzOiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG4gIHRpbWVvdXRNczogbnVtYmVyO1xuICBvblRpbWVvdXQ6ICgpID0+IFByb21pc2U8Tm9JbmZlcjxUPj47XG59Iiwib3B0czogU1NFU3RyZWFtQ29uc3VtZXJPcHRpb25zPFRDb25maWc+IiwiY2xpZW50T3B0aW9uczogU1NFQ2xpZW50T3B0aW9ucyIsIl9lczogSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbCIsIm9wdGlvbnM6IFNTRUNsaWVudE9wdGlvbnMiLCJkZWY6IFNTRXZlbnQiLCJyZXM6IEF3YWl0ZWQ8dHlwZW9mIHByb21pc2U+IiwiZXJyOiBUUlBDRXJyb3IiLCJUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA6IFJlY29yZDxQcm9jZWR1cmVUeXBlLCBIVFRQTWV0aG9kc1tdPiIsIlRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERTogUmVjb3JkPFxuICBQcm9jZWR1cmVUeXBlLFxuICBIVFRQTWV0aG9kc1tdXG4+IiwiaW5pdE9wdHM6IHtcbiAgY3R4OiBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlcj4gfCB1bmRlZmluZWQ7XG4gIGluZm86IFRSUENSZXF1ZXN0SW5mbyB8IHVuZGVmaW5lZDtcbiAgcmVzcG9uc2VNZXRhPzogSFRUUEJhc2VIYW5kbGVyT3B0aW9uczxUUm91dGVyLCBUUmVxdWVzdD5bJ3Jlc3BvbnNlTWV0YSddO1xuICB1bnRyYW5zZm9ybWVkSlNPTjpcbiAgICB8IFRSUENSZXNwb25zZTx1bmtub3duLCBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXI+PlxuICAgIHwgVFJQQ1Jlc3BvbnNlPHVua25vd24sIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+W11cbiAgICB8IG51bGw7XG4gIGVycm9yczogVFJQQ0Vycm9yW107XG4gIGhlYWRlcnM6IEhlYWRlcnM7XG59IiwiY2F1c2U6IHVua25vd24iLCJlcnJvck9wdHM6IHtcbiAgICBvcHRzOiBQaWNrPFxuICAgICAgUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uczxUUm91dGVyPixcbiAgICAgICdvbkVycm9yJyB8ICdyZXEnIHwgJ3JvdXRlcidcbiAgICA+O1xuICAgIGN0eDogaW5mZXJSb3V0ZXJDb250ZXh0PFRSb3V0ZXI+IHwgdW5kZWZpbmVkO1xuICAgIHR5cGU6IFByb2NlZHVyZVR5cGUgfCAndW5rbm93bic7XG4gICAgcGF0aD86IHN0cmluZztcbiAgICBpbnB1dD86IHVua25vd247XG4gIH0iLCJ2OiB1bmtub3duIiwib3B0czogUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uczxUUm91dGVyPiIsImluZm9UdXBsZTogUmVzdWx0VHVwbGU8VFJQQ1JlcXVlc3RJbmZvPiIsImN0eE1hbmFnZXI6IENvbnRleHRNYW5hZ2VyIiwicmVzdWx0OiBSZXN1bHRUdXBsZTwkQ29udGV4dD4gfCB1bmRlZmluZWQiLCJyZXM6IFRSUENSZXNwb25zZTx1bmtub3duLCBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXI+PiIsImhlYWRSZXNwb25zZSIsImVycm9yIiwicmVzdWx0czogUlBDUmVzdWx0W10iXSwiaWdub3JlTGlzdCI6WzYsNyw4LDksMTUsMTddLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPCError: () => (/* binding */ TRPCError),\n/* harmony export */   callProcedure: () => (/* binding */ callProcedure),\n/* harmony export */   createCallerFactory: () => (/* binding */ createCallerFactory),\n/* harmony export */   createRouterFactory: () => (/* binding */ createRouterFactory),\n/* harmony export */   defaultFormatter: () => (/* binding */ defaultFormatter),\n/* harmony export */   defaultTransformer: () => (/* binding */ defaultTransformer),\n/* harmony export */   getCauseFromUnknown: () => (/* binding */ getCauseFromUnknown),\n/* harmony export */   getDataTransformer: () => (/* binding */ getDataTransformer),\n/* harmony export */   getProcedureAtPath: () => (/* binding */ getProcedureAtPath),\n/* harmony export */   getTRPCErrorFromUnknown: () => (/* binding */ getTRPCErrorFromUnknown),\n/* harmony export */   isTrackedEnvelope: () => (/* binding */ isTrackedEnvelope),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   mergeRouters: () => (/* binding */ mergeRouters),\n/* harmony export */   sse: () => (/* binding */ sse),\n/* harmony export */   tracked: () => (/* binding */ tracked),\n/* harmony export */   transformResult: () => (/* binding */ transformResult),\n/* harmony export */   transformTRPCResponse: () => (/* binding */ transformTRPCResponse)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n\n\n//#region src/unstable-core-do-not-import/error/formatter.ts\nconst defaultFormatter = ({ shape })=>{\n    return shape;\n};\n//#endregion\n//#region src/unstable-core-do-not-import/error/TRPCError.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_defineProperty)(), 1);\nvar UnknownCauseError = class extends Error {\n};\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) return cause;\n    const type = typeof cause;\n    if (type === \"undefined\" || type === \"function\" || cause === null) return void 0;\n    if (type !== \"object\") return new Error(String(cause));\n    if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(cause)) return Object.assign(new UnknownCauseError(), cause);\n    return void 0;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) return cause;\n    if (cause instanceof Error && cause.name === \"TRPCError\") return cause;\n    const trpcError = new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        cause\n    });\n    if (cause instanceof Error && cause.stack) trpcError.stack = cause.stack;\n    return trpcError;\n}\nvar TRPCError = class extends Error {\n    constructor(opts){\n        var _ref, _opts$message, _this$cause;\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = (_ref = (_opts$message = opts.message) !== null && _opts$message !== void 0 ? _opts$message : cause === null || cause === void 0 ? void 0 : cause.message) !== null && _ref !== void 0 ? _ref : opts.code;\n        super(message, {\n            cause\n        });\n        (0, import_defineProperty.default)(this, \"cause\", void 0);\n        (0, import_defineProperty.default)(this, \"code\", void 0);\n        this.code = opts.code;\n        this.name = \"TRPCError\";\n        (_this$cause = this.cause) !== null && _this$cause !== void 0 || (this.cause = cause);\n    }\n};\n//#endregion\n//#region src/unstable-core-do-not-import/transformer.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/**\n* @internal\n*/ function getDataTransformer(transformer) {\n    if (\"input\" in transformer) return transformer;\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n* @internal\n*/ const defaultTransformer = {\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\nfunction transformTRPCResponseItem(config, item) {\n    if (\"error\" in item) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, {\n        error: config.transformer.output.serialize(item.error)\n    });\n    if (\"data\" in item.result) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, {\n        result: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item.result), {}, {\n            data: config.transformer.output.serialize(item.result.data)\n        })\n    });\n    return item;\n}\n/**\n* Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n**/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n/** @internal */ function transformResultInner(response, transformer) {\n    if (\"error\" in response) {\n        const error = transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response), {}, {\n                error\n            })\n        };\n    }\n    const result = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response.result), (!response.result.type || response.result.type === \"data\") && {\n        type: \"data\",\n        data: transformer.deserialize(response.result.data)\n    });\n    return {\n        ok: true,\n        result\n    };\n}\nvar TransformResultError = class extends Error {\n    constructor(){\n        super(\"Unable to transform response from server\");\n    }\n};\n/**\n* Transforms and validates that the result is a valid TRPCResponse\n* @internal\n*/ function transformResult(response, transformer) {\n    let result;\n    try {\n        result = transformResultInner(response, transformer);\n    } catch (_unused) {\n        throw new TransformResultError();\n    }\n    if (!result.ok && (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.error.error) || typeof result.error.error[\"code\"] !== \"number\")) throw new TransformResultError();\n    if (result.ok && !(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.result)) throw new TransformResultError();\n    return result;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/router.ts\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\nconst lazySymbol = Symbol(\"lazy\");\nfunction once(fn) {\n    const uncalled = Symbol();\n    let result = uncalled;\n    return ()=>{\n        if (result === uncalled) result = fn();\n        return result;\n    };\n}\n/**\n* Lazy load a router\n* @see https://trpc.io/docs/server/merging-routers#lazy-load\n*/ function lazy(importRouter) {\n    async function resolve() {\n        const mod = await importRouter();\n        if (isRouter(mod)) return mod;\n        const routers = Object.values(mod);\n        if (routers.length !== 1 || !isRouter(routers[0])) throw new Error(\"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\");\n        return routers[0];\n    }\n    resolve[lazySymbol] = true;\n    return resolve;\n}\nfunction isLazy(input) {\n    return typeof input === \"function\" && lazySymbol in input;\n}\nfunction isRouter(value) {\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value[\"_def\"]) && \"router\" in value[\"_def\"];\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n* Reserved words that can't be used as router or procedure names\n*/ const reservedWords = [\n    \"then\",\n    \"call\",\n    \"apply\"\n];\n/**\n* @internal\n*/ function createRouterFactory(config) {\n    function createRouterInner(input) {\n        const reservedWordsUsed = new Set(Object.keys(input).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) throw new Error(\"Reserved words used in `router({})` call: \" + Array.from(reservedWordsUsed).join(\", \"));\n        const procedures = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n        const lazy$1 = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n        function createLazyLoader(opts) {\n            return {\n                ref: opts.ref,\n                load: once(async ()=>{\n                    const router$1 = await opts.ref();\n                    const lazyPath = [\n                        ...opts.path,\n                        opts.key\n                    ];\n                    const lazyKey = lazyPath.join(\".\");\n                    opts.aggregate[opts.key] = step(router$1._def.record, lazyPath);\n                    delete lazy$1[lazyKey];\n                    for (const [nestedKey, nestedItem] of Object.entries(router$1._def.lazy)){\n                        const nestedRouterKey = [\n                            ...lazyPath,\n                            nestedKey\n                        ].join(\".\");\n                        lazy$1[nestedRouterKey] = createLazyLoader({\n                            ref: nestedItem.ref,\n                            path: lazyPath,\n                            key: nestedKey,\n                            aggregate: opts.aggregate[opts.key]\n                        });\n                    }\n                })\n            };\n        }\n        function step(from, path = []) {\n            const aggregate = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n            for (const [key, item] of Object.entries(from !== null && from !== void 0 ? from : {})){\n                if (isLazy(item)) {\n                    lazy$1[[\n                        ...path,\n                        key\n                    ].join(\".\")] = createLazyLoader({\n                        path,\n                        ref: item,\n                        key,\n                        aggregate\n                    });\n                    continue;\n                }\n                if (isRouter(item)) {\n                    aggregate[key] = step(item._def.record, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                if (!isProcedure(item)) {\n                    aggregate[key] = step(item, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                const newPath = [\n                    ...path,\n                    key\n                ].join(\".\");\n                if (procedures[newPath]) throw new Error(`Duplicate key: ${newPath}`);\n                procedures[newPath] = item;\n                aggregate[key] = item;\n            }\n            return aggregate;\n        }\n        const record = step(input);\n        const _def = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({\n            _config: config,\n            router: true,\n            procedures,\n            lazy: lazy$1\n        }, emptyRouter), {}, {\n            record\n        });\n        const router = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, record), {}, {\n            _def,\n            createCaller: createCallerFactory()({\n                _def\n            })\n        });\n        return router;\n    }\n    return createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n    return typeof procedureOrRouter === \"function\";\n}\n/**\n* @internal\n*/ async function getProcedureAtPath(router, path) {\n    const { _def } = router;\n    let procedure = _def.procedures[path];\n    while(!procedure){\n        const key = Object.keys(_def.lazy).find((key$1)=>path.startsWith(key$1));\n        if (!key) return null;\n        const lazyRouter = _def.lazy[key];\n        await lazyRouter.load();\n        procedure = _def.procedures[path];\n    }\n    return procedure;\n}\n/**\n* @internal\n*/ async function callProcedure(opts) {\n    const { type, path } = opts;\n    const proc = await getProcedureAtPath(opts.router, path);\n    if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: `No \"${type}\"-procedure on path \"${path}\"`\n    });\n    /* istanbul ignore if -- @preserve */ if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === \"subscription\") throw new TRPCError({\n        code: \"METHOD_NOT_SUPPORTED\",\n        message: `Method override is not supported for subscriptions`\n    });\n    return proc(opts);\n}\nfunction createCallerFactory() {\n    return function createCallerInner(router) {\n        const { _def } = router;\n        return function createCaller(ctxOrCallback, opts) {\n            return (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.createRecursiveProxy)(async ({ path, args })=>{\n                const fullPath = path.join(\".\");\n                if (path.length === 1 && path[0] === \"_def\") return _def;\n                const procedure = await getProcedureAtPath(router, fullPath);\n                let ctx = void 0;\n                try {\n                    if (!procedure) throw new TRPCError({\n                        code: \"NOT_FOUND\",\n                        message: `No procedure found on path \"${path}\"`\n                    });\n                    ctx = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n                    return await procedure({\n                        path: fullPath,\n                        getRawInput: async ()=>args[0],\n                        ctx,\n                        type: procedure._def.type,\n                        signal: opts === null || opts === void 0 ? void 0 : opts.signal\n                    });\n                } catch (cause) {\n                    var _opts$onError, _procedure$_def$type;\n                    opts === null || opts === void 0 || (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n                        ctx,\n                        error: getTRPCErrorFromUnknown(cause),\n                        input: args[0],\n                        path: fullPath,\n                        type: (_procedure$_def$type = procedure === null || procedure === void 0 ? void 0 : procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n                    });\n                    throw cause;\n                }\n            });\n        };\n    };\n}\nfunction mergeRouters(...routerList) {\n    var _routerList$;\n    const record = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.mergeWithoutOverrides)({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) throw new Error(\"You seem to have several error formatters\");\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) throw new Error(\"You seem to have several transformers\");\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.every((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.every((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.every((r)=>r._def._config.isServer),\n        $types: (_routerList$ = routerList[0]) === null || _routerList$ === void 0 ? void 0 : _routerList$._def._config.$types\n    })(record);\n    return router;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/tracked.ts\nconst trackedSymbol = Symbol();\n/**\n* Produce a typed server-sent event message\n* @deprecated use `tracked(id, data)` instead\n*/ function sse(event) {\n    return tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n    return Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n* Automatically track an event so that it can be resumed from a given id if the connection is lost\n*/ function tracked(id, data) {\n    if (id === \"\") throw new Error(\"`id` must not be an empty string as empty string is the same as not setting the id at all\");\n    return [\n        id,\n        data,\n        trackedSymbol\n    ];\n}\n//#endregion\n //# sourceMappingURL=tracked-gU3ttYjg.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvdHJhY2tlZC1nVTN0dFlqZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDQSxNQUFhQSxtQkFBNkMsQ0FBQyxFQUFFLE9BQU87SUFDbEUsT0FBTztBQUNSOzs7O0FDM0NELElBQU0sb0JBQU4sY0FBZ0MsTUFBTTtBQUVyQztBQUNELFNBQWdCLG9CQUFvQkMsS0FBQUEsRUFBbUM7SUFDckUsSUFBSSxpQkFBaUIsTUFDbkIsUUFBTztJQUdULE1BQU0sY0FBYztJQUNwQixJQUFJLFNBQVMsZUFBZSxTQUFTLGNBQWMsVUFBVSxLQUMzRDtJQUlGLElBQUksU0FBUyxTQUVYLFFBQU8sSUFBSSxNQUFNLE9BQU8sTUFBTTtJQUloQyxJQUFJLDZEQUFRLENBQUMsTUFBTSxDQUNqQixRQUFPLE9BQU8sT0FBTyxJQUFJLHFCQUFxQixNQUFNO0lBR3REO0FBQ0Q7QUFFRCxTQUFnQix3QkFBd0JBLEtBQUFBLEVBQTJCO0lBQ2pFLElBQUksaUJBQWlCLFVBQ25CLFFBQU87SUFFVCxJQUFJLGlCQUFpQixTQUFTLE1BQU0sU0FBUyxZQUUzQyxRQUFPO0lBR1QsTUFBTSxZQUFZLElBQUksVUFBVTtRQUM5QixNQUFNO1FBQ047SUFDRDtJQUdELElBQUksaUJBQWlCLFNBQVMsTUFBTSxNQUNsQyxXQUFVLFFBQVEsTUFBTTtJQUcxQixPQUFPO0FBQ1I7QUFFRCxJQUFhLFlBQWIsY0FBK0IsTUFBTTtJQU1uQyxZQUFZQyxJQUFBQSxDQUlUOztRQUNELE1BQU0sUUFBUSxvQkFBb0IsS0FBSyxNQUFNO1FBQzdDLE1BQU0sbUNBQVUsS0FBSyw4R0FBVyxNQUFPLDhDQUFXLEtBQUs7UUFJdkQsTUFBTSxTQUFTO1lBQUU7UUFBTyxFQUFDOzJDQU8zQixNQXBCeUI7MkNBb0J4QixNQW5C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SUFDakMsT0FBTyxNQUFNLFFBQVEsTUFBTSxJQUFJLE1BQU0sT0FBTztBQUM3Qzs7O0dBS0QsU0FBZ0IsUUFDZHFCLEVBQUFBLEVBQ0FDLElBQUFBLEVBQ3dCO0lBQ3hCLElBQUksT0FBTyxHQUVULE9BQU0sSUFBSSxNQUNSO0lBR0osT0FBTztRQUFDO1FBQWlCO1FBQU07S0FBYztBQUM5QyIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL2Zvcm1hdHRlci50cyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9lcnJvci9UUlBDRXJyb3IudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvdHJhbnNmb3JtZXIudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcm91dGVyLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS90cmFja2VkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUHJvY2VkdXJlVHlwZSB9IGZyb20gJy4uL3Byb2NlZHVyZSc7XG5pbXBvcnQgdHlwZSB7XG4gIFRSUENfRVJST1JfQ09ERV9LRVksXG4gIFRSUENfRVJST1JfQ09ERV9OVU1CRVIsXG4gIFRSUENFcnJvclNoYXBlLFxufSBmcm9tICcuLi9ycGMnO1xuaW1wb3J0IHR5cGUgeyBUUlBDRXJyb3IgfSBmcm9tICcuL1RSUENFcnJvcic7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIEVycm9yRm9ybWF0dGVyPFRDb250ZXh0LCBUU2hhcGUgZXh0ZW5kcyBUUlBDRXJyb3JTaGFwZT4gPSAob3B0czoge1xuICBlcnJvcjogVFJQQ0Vycm9yO1xuICB0eXBlOiBQcm9jZWR1cmVUeXBlIHwgJ3Vua25vd24nO1xuICBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGlucHV0OiB1bmtub3duO1xuICBjdHg6IFRDb250ZXh0IHwgdW5kZWZpbmVkO1xuICBzaGFwZTogRGVmYXVsdEVycm9yU2hhcGU7XG59KSA9PiBUU2hhcGU7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIERlZmF1bHRFcnJvckRhdGEgPSB7XG4gIGNvZGU6IFRSUENfRVJST1JfQ09ERV9LRVk7XG4gIGh0dHBTdGF0dXM6IG51bWJlcjtcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIHByb2NlZHVyZSB0aGF0IHRocmV3IHRoZSBlcnJvclxuICAgKi9cbiAgcGF0aD86IHN0cmluZztcbiAgLyoqXG4gICAqIFN0YWNrIHRyYWNlIG9mIHRoZSBlcnJvciAob25seSBpbiBkZXZlbG9wbWVudClcbiAgICovXG4gIHN0YWNrPzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0RXJyb3JTaGFwZSBleHRlbmRzIFRSUENFcnJvclNoYXBlPERlZmF1bHRFcnJvckRhdGE+IHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBjb2RlOiBUUlBDX0VSUk9SX0NPREVfTlVNQkVSO1xufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdEZvcm1hdHRlcjogRXJyb3JGb3JtYXR0ZXI8YW55LCBhbnk+ID0gKHsgc2hhcGUgfSkgPT4ge1xuICByZXR1cm4gc2hhcGU7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUUlBDX0VSUk9SX0NPREVfS0VZIH0gZnJvbSAnLi4vcnBjL2NvZGVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jbGFzcyBVbmtub3duQ2F1c2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXVzZUZyb21Vbmtub3duKGNhdXNlOiB1bmtub3duKTogRXJyb3IgfCB1bmRlZmluZWQge1xuICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBjYXVzZTtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgY2F1c2U7XG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnZnVuY3Rpb24nIHx8IGNhdXNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBqdXN0IGdldCB3cmFwcGVkIGluIGFuIGVycm9yXG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhjYXVzZSkpO1xuICB9XG5cbiAgLy8gSWYgaXQncyBhbiBvYmplY3QsIHdlJ2xsIGNyZWF0ZSBhIHN5bnRoZXRpYyBlcnJvclxuICBpZiAoaXNPYmplY3QoY2F1c2UpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVua25vd25DYXVzZUVycm9yKCksIGNhdXNlKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZTogdW5rbm93bik6IFRSUENFcnJvciB7XG4gIGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikge1xuICAgIHJldHVybiBjYXVzZTtcbiAgfVxuICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSAnVFJQQ0Vycm9yJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90cnBjL3RycGMvcHVsbC80ODQ4XG4gICAgcmV0dXJuIGNhdXNlIGFzIFRSUENFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IHRycGNFcnJvciA9IG5ldyBUUlBDRXJyb3Ioe1xuICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgIGNhdXNlLFxuICB9KTtcblxuICAvLyBJbmhlcml0IHN0YWNrIGZyb20gZXJyb3JcbiAgaWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgJiYgY2F1c2Uuc3RhY2spIHtcbiAgICB0cnBjRXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcbiAgfVxuXG4gIHJldHVybiB0cnBjRXJyb3I7XG59XG5cbmV4cG9ydCBjbGFzcyBUUlBDRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZSBvdmVycmlkZSBkb2Vzbid0IHdvcmsgaW4gYWxsIGVudmlyb25tZW50cyBkdWUgdG8gXCJUaGlzIG1lbWJlciBjYW5ub3QgaGF2ZSBhbiAnb3ZlcnJpZGUnIG1vZGlmaWVyIGJlY2F1c2UgaXQgaXMgbm90IGRlY2xhcmVkIGluIHRoZSBiYXNlIGNsYXNzICdFcnJvcidcIlxuICBwdWJsaWMgb3ZlcnJpZGUgcmVhZG9ubHkgY2F1c2U/OiBFcnJvcjtcbiAgcHVibGljIHJlYWRvbmx5IGNvZGU7XG5cbiAgY29uc3RydWN0b3Iob3B0czoge1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgY29kZTogVFJQQ19FUlJPUl9DT0RFX0tFWTtcbiAgICBjYXVzZT86IHVua25vd247XG4gIH0pIHtcbiAgICBjb25zdCBjYXVzZSA9IGdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSA/PyBjYXVzZT8ubWVzc2FnZSA/PyBvcHRzLmNvZGU7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1lcnJvci1jYXVzZVxuICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG5cbiAgICB0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG4gICAgdGhpcy5uYW1lID0gJ1RSUENFcnJvcic7XG4gICAgdGhpcy5jYXVzZSA/Pz0gY2F1c2U7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQW55Um9vdFR5cGVzLCBSb290Q29uZmlnIH0gZnJvbSAnLi9yb290Q29uZmlnJztcbmltcG9ydCB0eXBlIHsgQW55Um91dGVyLCBpbmZlclJvdXRlckVycm9yIH0gZnJvbSAnLi9yb3V0ZXInO1xuaW1wb3J0IHR5cGUge1xuICBUUlBDUmVzcG9uc2UsXG4gIFRSUENSZXNwb25zZU1lc3NhZ2UsXG4gIFRSUENSZXN1bHRNZXNzYWdlLFxufSBmcm9tICcuL3JwYyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhVHJhbnNmb3JtZXIge1xuICBzZXJpYWxpemU6IChvYmplY3Q6IGFueSkgPT4gYW55O1xuICBkZXNlcmlhbGl6ZTogKG9iamVjdDogYW55KSA9PiBhbnk7XG59XG5cbmludGVyZmFjZSBJbnB1dERhdGFUcmFuc2Zvcm1lciBleHRlbmRzIERhdGFUcmFuc2Zvcm1lciB7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgKipvbiB0aGUgY2xpZW50KiogYmVmb3JlIHNlbmRpbmcgdGhlIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIHNlcmlhbGl6ZTogKG9iamVjdDogYW55KSA9PiBhbnk7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgKipvbiB0aGUgc2VydmVyKiogdG8gdHJhbnNmb3JtIHRoZSBkYXRhIGJlZm9yZSBpdCBpcyBwYXNzZWQgdG8gdGhlIHJlc29sdmVyXG4gICAqL1xuICBkZXNlcmlhbGl6ZTogKG9iamVjdDogYW55KSA9PiBhbnk7XG59XG5cbmludGVyZmFjZSBPdXRwdXREYXRhVHJhbnNmb3JtZXIgZXh0ZW5kcyBEYXRhVHJhbnNmb3JtZXIge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBydW5zICoqb24gdGhlIHNlcnZlcioqIGJlZm9yZSBzZW5kaW5nIHRoZSBkYXRhIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBzZXJpYWxpemU6IChvYmplY3Q6IGFueSkgPT4gYW55O1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBydW5zICoqb25seSBvbiB0aGUgY2xpZW50KiogdG8gdHJhbnNmb3JtIHRoZSBkYXRhIHNlbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgZGVzZXJpYWxpemU6IChvYmplY3Q6IGFueSkgPT4gYW55O1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21iaW5lZERhdGFUcmFuc2Zvcm1lciB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGhvdyB0aGUgZGF0YSBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAgICovXG4gIGlucHV0OiBJbnB1dERhdGFUcmFuc2Zvcm1lcjtcbiAgLyoqXG4gICAqIFNwZWNpZnkgaG93IHRoZSBkYXRhIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICAgKi9cbiAgb3V0cHV0OiBPdXRwdXREYXRhVHJhbnNmb3JtZXI7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDb21iaW5lZERhdGFUcmFuc2Zvcm1lckNsaWVudCA9IHtcbiAgaW5wdXQ6IFBpY2s8Q29tYmluZWREYXRhVHJhbnNmb3JtZXJbJ2lucHV0J10sICdzZXJpYWxpemUnPjtcbiAgb3V0cHV0OiBQaWNrPENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyWydvdXRwdXQnXSwgJ2Rlc2VyaWFsaXplJz47XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVRyYW5zZm9ybWVyT3B0aW9ucyA9IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyIHwgRGF0YVRyYW5zZm9ybWVyO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVRyYW5zZm9ybWVyKFxuICB0cmFuc2Zvcm1lcjogRGF0YVRyYW5zZm9ybWVyT3B0aW9ucyxcbik6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyIHtcbiAgaWYgKCdpbnB1dCcgaW4gdHJhbnNmb3JtZXIpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gIH1cbiAgcmV0dXJuIHsgaW5wdXQ6IHRyYW5zZm9ybWVyLCBvdXRwdXQ6IHRyYW5zZm9ybWVyIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0VHJhbnNmb3JtZXI6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyID0ge1xuICBpbnB1dDogeyBzZXJpYWxpemU6IChvYmopID0+IG9iaiwgZGVzZXJpYWxpemU6IChvYmopID0+IG9iaiB9LFxuICBvdXRwdXQ6IHsgc2VyaWFsaXplOiAob2JqKSA9PiBvYmosIGRlc2VyaWFsaXplOiAob2JqKSA9PiBvYmogfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRSUENSZXNwb25zZUl0ZW08XG4gIFRSZXNwb25zZUl0ZW0gZXh0ZW5kcyBUUlBDUmVzcG9uc2UgfCBUUlBDUmVzcG9uc2VNZXNzYWdlLFxuPihjb25maWc6IFJvb3RDb25maWc8QW55Um9vdFR5cGVzPiwgaXRlbTogVFJlc3BvbnNlSXRlbSk6IFRSZXNwb25zZUl0ZW0ge1xuICBpZiAoJ2Vycm9yJyBpbiBpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLml0ZW0sXG4gICAgICBlcnJvcjogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5lcnJvciksXG4gICAgfTtcbiAgfVxuXG4gIGlmICgnZGF0YScgaW4gaXRlbS5yZXN1bHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaXRlbSxcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICAuLi5pdGVtLnJlc3VsdCxcbiAgICAgICAgZGF0YTogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5yZXN1bHQuZGF0YSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHVuc2VyaWFsaXplZCBgVFJQQ1Jlc3BvbnNlYCBhbmQgc2VyaWFsaXplcyBpdCB3aXRoIHRoZSByb3V0ZXIncyB0cmFuc2Zvcm1lcnNcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2U8XG4gIFRSZXNwb25zZSBleHRlbmRzXG4gICAgfCBUUlBDUmVzcG9uc2VcbiAgICB8IFRSUENSZXNwb25zZVtdXG4gICAgfCBUUlBDUmVzcG9uc2VNZXNzYWdlXG4gICAgfCBUUlBDUmVzcG9uc2VNZXNzYWdlW10sXG4+KGNvbmZpZzogUm9vdENvbmZpZzxBbnlSb290VHlwZXM+LCBpdGVtT3JJdGVtczogVFJlc3BvbnNlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW1Pckl0ZW1zKVxuICAgID8gaXRlbU9ySXRlbXMubWFwKChpdGVtKSA9PiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkpXG4gICAgOiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbU9ySXRlbXMpO1xufVxuXG4vLyBGSVhNRTpcbi8vIC0gdGhlIGdlbmVyaWNzIGhlcmUgYXJlIHByb2JhYmx5IHVubmVjZXNzYXJ5XG4vLyAtIHRoZSBSUEMtc3BlYyBjb3VsZCBwcm9iYWJseSBiZSBzaW1wbGlmaWVkIHRvIGNvbWJpbmUgSFRUUCArIFdTXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHRJbm5lcjxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyLCBUT3V0cHV0PihcbiAgcmVzcG9uc2U6XG4gICAgfCBUUlBDUmVzcG9uc2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj5cbiAgICB8IFRSUENSZXNwb25zZU1lc3NhZ2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4sXG4gIHRyYW5zZm9ybWVyOiBEYXRhVHJhbnNmb3JtZXIsXG4pIHtcbiAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICBjb25zdCBlcnJvciA9IHRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKFxuICAgICAgcmVzcG9uc2UuZXJyb3IsXG4gICAgKSBhcyBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXI+O1xuICAgIHJldHVybiB7XG4gICAgICBvazogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9LFxuICAgIH0gYXMgY29uc3Q7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4ucmVzcG9uc2UucmVzdWx0LFxuICAgIC4uLigoIXJlc3BvbnNlLnJlc3VsdC50eXBlIHx8IHJlc3BvbnNlLnJlc3VsdC50eXBlID09PSAnZGF0YScpICYmIHtcbiAgICAgIHR5cGU6ICdkYXRhJyxcbiAgICAgIGRhdGE6IHRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHJlc3BvbnNlLnJlc3VsdC5kYXRhKSxcbiAgICB9KSxcbiAgfSBhcyBUUlBDUmVzdWx0TWVzc2FnZTxUT3V0cHV0PlsncmVzdWx0J107XG4gIHJldHVybiB7IG9rOiB0cnVlLCByZXN1bHQgfSBhcyBjb25zdDtcbn1cblxuY2xhc3MgVHJhbnNmb3JtUmVzdWx0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdVbmFibGUgdG8gdHJhbnNmb3JtIHJlc3BvbnNlIGZyb20gc2VydmVyJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuZCB2YWxpZGF0ZXMgdGhhdCB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgVFJQQ1Jlc3BvbnNlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdDxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyLCBUT3V0cHV0PihcbiAgcmVzcG9uc2U6XG4gICAgfCBUUlBDUmVzcG9uc2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj5cbiAgICB8IFRSUENSZXNwb25zZU1lc3NhZ2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4sXG4gIHRyYW5zZm9ybWVyOiBEYXRhVHJhbnNmb3JtZXIsXG4pOiBSZXR1cm5UeXBlPHR5cGVvZiB0cmFuc2Zvcm1SZXN1bHRJbm5lcj4ge1xuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPHR5cGVvZiB0cmFuc2Zvcm1SZXN1bHRJbm5lcj47XG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBkYXRhIHRyYW5zZm9ybWVycyBvbiB0aGUgSlNPTi1yZXNwb25zZVxuICAgIHJlc3VsdCA9IHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcik7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuICB9XG5cbiAgLy8gY2hlY2sgdGhhdCBvdXRwdXQgb2YgdGhlIHRyYW5zZm9ybWVycyBpcyBhIHZhbGlkIFRSUENSZXNwb25zZVxuICBpZiAoXG4gICAgIXJlc3VsdC5vayAmJlxuICAgICghaXNPYmplY3QocmVzdWx0LmVycm9yLmVycm9yKSB8fFxuICAgICAgdHlwZW9mIHJlc3VsdC5lcnJvci5lcnJvclsnY29kZSddICE9PSAnbnVtYmVyJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG4gIH1cbiAgaWYgKHJlc3VsdC5vayAmJiAhaXNPYmplY3QocmVzdWx0LnJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVSZWN1cnNpdmVQcm94eSB9IGZyb20gJy4vY3JlYXRlUHJveHknO1xuaW1wb3J0IHsgZGVmYXVsdEZvcm1hdHRlciB9IGZyb20gJy4vZXJyb3IvZm9ybWF0dGVyJztcbmltcG9ydCB7IGdldFRSUENFcnJvckZyb21Vbmtub3duLCBUUlBDRXJyb3IgfSBmcm9tICcuL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgdHlwZSB7XG4gIEFueVByb2NlZHVyZSxcbiAgRXJyb3JIYW5kbGVyT3B0aW9ucyxcbiAgaW5mZXJQcm9jZWR1cmVJbnB1dCxcbiAgaW5mZXJQcm9jZWR1cmVPdXRwdXQsXG4gIExlZ2FjeU9ic2VydmFibGVTdWJzY3JpcHRpb25Qcm9jZWR1cmUsXG59IGZyb20gJy4vcHJvY2VkdXJlJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlQ2FsbE9wdGlvbnMgfSBmcm9tICcuL3Byb2NlZHVyZUJ1aWxkZXInO1xuaW1wb3J0IHR5cGUgeyBBbnlSb290VHlwZXMsIFJvb3RDb25maWcgfSBmcm9tICcuL3Jvb3RDb25maWcnO1xuaW1wb3J0IHsgZGVmYXVsdFRyYW5zZm9ybWVyIH0gZnJvbSAnLi90cmFuc2Zvcm1lcic7XG5pbXBvcnQgdHlwZSB7IE1heWJlUHJvbWlzZSwgVmFsdWVPZiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgaXNGdW5jdGlvbixcbiAgaXNPYmplY3QsXG4gIG1lcmdlV2l0aG91dE92ZXJyaWRlcyxcbiAgb21pdFByb3RvdHlwZSxcbn0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUmVjb3JkIHtcbiAgW2tleTogc3RyaW5nXTogQW55UHJvY2VkdXJlIHwgUm91dGVyUmVjb3JkO1xufVxuXG50eXBlIERlY29yYXRlUHJvY2VkdXJlPFRQcm9jZWR1cmUgZXh0ZW5kcyBBbnlQcm9jZWR1cmU+ID0gKFxuICBpbnB1dDogaW5mZXJQcm9jZWR1cmVJbnB1dDxUUHJvY2VkdXJlPixcbikgPT4gUHJvbWlzZTxcbiAgVFByb2NlZHVyZVsnX2RlZiddWyd0eXBlJ10gZXh0ZW5kcyAnc3Vic2NyaXB0aW9uJ1xuICAgID8gVFByb2NlZHVyZSBleHRlbmRzIExlZ2FjeU9ic2VydmFibGVTdWJzY3JpcHRpb25Qcm9jZWR1cmU8YW55PlxuICAgICAgPyBPYnNlcnZhYmxlPGluZmVyUHJvY2VkdXJlT3V0cHV0PFRQcm9jZWR1cmU+LCBUUlBDRXJyb3I+XG4gICAgICA6IGluZmVyUHJvY2VkdXJlT3V0cHV0PFRQcm9jZWR1cmU+XG4gICAgOiBpbmZlclByb2NlZHVyZU91dHB1dDxUUHJvY2VkdXJlPlxuPjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgRGVjb3JhdGVSb3V0ZXJSZWNvcmQ8VFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZD4gPSB7XG4gIFtUS2V5IGluIGtleW9mIFRSZWNvcmRdOiBUUmVjb3JkW1RLZXldIGV4dGVuZHMgaW5mZXIgJFZhbHVlXG4gICAgPyAkVmFsdWUgZXh0ZW5kcyBBbnlQcm9jZWR1cmVcbiAgICAgID8gRGVjb3JhdGVQcm9jZWR1cmU8JFZhbHVlPlxuICAgICAgOiAkVmFsdWUgZXh0ZW5kcyBSb3V0ZXJSZWNvcmRcbiAgICAgICAgPyBEZWNvcmF0ZVJvdXRlclJlY29yZDwkVmFsdWU+XG4gICAgICAgIDogbmV2ZXJcbiAgICA6IG5ldmVyO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgdHlwZSBSb3V0ZXJDYWxsZXJFcnJvckhhbmRsZXI8VENvbnRleHQ+ID0gKFxuICBvcHRzOiBFcnJvckhhbmRsZXJPcHRpb25zPFRDb250ZXh0PixcbikgPT4gdm9pZDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyQ2FsbGVyPFxuICBUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcyxcbiAgVFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZCxcbj4gPSAoXG4gIC8qKlxuICAgKiBAbm90ZVxuICAgKiBJZiBwYXNzaW5nIGEgZnVuY3Rpb24sIHdlIHJlY29tbWVuZCBpdCdzIGEgY2FjaGVkIGZ1bmN0aW9uXG4gICAqIGUuZy4gd3JhcHBlZCBpbiBgUmVhY3QuY2FjaGVgIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uc1xuICAgKi9cbiAgY3R4OiBUUm9vdFsnY3R4J10gfCAoKCkgPT4gTWF5YmVQcm9taXNlPFRSb290WydjdHgnXT4pLFxuICBvcHRpb25zPzoge1xuICAgIG9uRXJyb3I/OiBSb3V0ZXJDYWxsZXJFcnJvckhhbmRsZXI8VFJvb3RbJ2N0eCddPjtcbiAgICBzaWduYWw/OiBBYm9ydFNpZ25hbDtcbiAgfSxcbikgPT4gRGVjb3JhdGVSb3V0ZXJSZWNvcmQ8VFJlY29yZD47XG5cbmNvbnN0IGxhenlTeW1ib2wgPSBTeW1ib2woJ2xhenknKTtcbmV4cG9ydCB0eXBlIExhenk8VEFueT4gPSAoKCkgPT4gUHJvbWlzZTxUQW55PikgJiB7IFtsYXp5U3ltYm9sXTogdHJ1ZSB9O1xuXG50eXBlIExhenlMb2FkZXI8VEFueT4gPSB7XG4gIGxvYWQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJlZjogTGF6eTxUQW55Pjtcbn07XG5cbmZ1bmN0aW9uIG9uY2U8VD4oZm46ICgpID0+IFQpOiAoKSA9PiBUIHtcbiAgY29uc3QgdW5jYWxsZWQgPSBTeW1ib2woKTtcbiAgbGV0IHJlc3VsdDogVCB8IHR5cGVvZiB1bmNhbGxlZCA9IHVuY2FsbGVkO1xuICByZXR1cm4gKCk6IFQgPT4ge1xuICAgIGlmIChyZXN1bHQgPT09IHVuY2FsbGVkKSB7XG4gICAgICByZXN1bHQgPSBmbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIExhenkgbG9hZCBhIHJvdXRlclxuICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWVyZ2luZy1yb3V0ZXJzI2xhenktbG9hZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF6eTxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPihcbiAgaW1wb3J0Um91dGVyOiAoKSA9PiBQcm9taXNlPFxuICAgIHwgVFJvdXRlclxuICAgIHwge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBUUm91dGVyO1xuICAgICAgfVxuICA+LFxuKTogTGF6eTxOb0luZmVyPFRSb3V0ZXI+PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmUoKTogUHJvbWlzZTxUUm91dGVyPiB7XG4gICAgY29uc3QgbW9kID0gYXdhaXQgaW1wb3J0Um91dGVyKCk7XG5cbiAgICAvLyBpZiB0aGUgbW9kdWxlIGlzIGEgcm91dGVyLCByZXR1cm4gaXRcbiAgICBpZiAoaXNSb3V0ZXIobW9kKSkge1xuICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZXJzID0gT2JqZWN0LnZhbHVlcyhtb2QpO1xuXG4gICAgaWYgKHJvdXRlcnMubGVuZ3RoICE9PSAxIHx8ICFpc1JvdXRlcihyb3V0ZXJzWzBdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgcm91dGVyIG1vZHVsZSAtIGVpdGhlciBkZWZpbmUgZXhhY3RseSAxIGV4cG9ydCBvciByZXR1cm4gdGhlIHJvdXRlciBkaXJlY3RseS5cXG5FeGFtcGxlOiBgbGF6eSgoKSA9PiBpbXBvcnQoJy4vc2xvdy5qcycpLnRoZW4oKG0pID0+IG0uc2xvd1JvdXRlcikpYFwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVyc1swXTtcbiAgfVxuICByZXNvbHZlW2xhenlTeW1ib2xdID0gdHJ1ZSBhcyBjb25zdDtcblxuICByZXR1cm4gcmVzb2x2ZTtcbn1cblxuZnVuY3Rpb24gaXNMYXp5PFRBbnk+KGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgTGF6eTxUQW55PiB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgJiYgbGF6eVN5bWJvbCBpbiBpbnB1dDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJEZWY8XG4gIFRSb290IGV4dGVuZHMgQW55Um9vdFR5cGVzLFxuICBUUmVjb3JkIGV4dGVuZHMgUm91dGVyUmVjb3JkLFxuPiB7XG4gIF9jb25maWc6IFJvb3RDb25maWc8VFJvb3Q+O1xuICByb3V0ZXI6IHRydWU7XG4gIHByb2NlZHVyZT86IG5ldmVyO1xuICBwcm9jZWR1cmVzOiBUUmVjb3JkO1xuICByZWNvcmQ6IFRSZWNvcmQ7XG4gIGxhenk6IFJlY29yZDxzdHJpbmcsIExhenlMb2FkZXI8QW55Um91dGVyPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyPFxuICBUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcyxcbiAgVFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZCxcbj4ge1xuICBfZGVmOiBSb3V0ZXJEZWY8VFJvb3QsIFRSZWNvcmQ+O1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3NlcnZlci1zaWRlLWNhbGxzXG4gICAqL1xuICBjcmVhdGVDYWxsZXI6IFJvdXRlckNhbGxlcjxUUm9vdCwgVFJlY29yZD47XG59XG5cbmV4cG9ydCB0eXBlIEJ1aWx0Um91dGVyPFxuICBUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcyxcbiAgVFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZCxcbj4gPSBSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+ICYgVFJlY29yZDtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJCdWlsZGVyPFRSb290IGV4dGVuZHMgQW55Um9vdFR5cGVzPiB7XG4gIDxUSW4gZXh0ZW5kcyBDcmVhdGVSb3V0ZXJPcHRpb25zPihcbiAgICBfOiBUSW4sXG4gICk6IEJ1aWx0Um91dGVyPFRSb290LCBEZWNvcmF0ZUNyZWF0ZVJvdXRlck9wdGlvbnM8VEluPj47XG59XG5cbmV4cG9ydCB0eXBlIEFueVJvdXRlciA9IFJvdXRlcjxhbnksIGFueT47XG5cbmV4cG9ydCB0eXBlIGluZmVyUm91dGVyUm9vdFR5cGVzPFRSb3V0ZXIgZXh0ZW5kcyBBbnlSb3V0ZXI+ID1cbiAgVFJvdXRlclsnX2RlZiddWydfY29uZmlnJ11bJyR0eXBlcyddO1xuXG5leHBvcnQgdHlwZSBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlciBleHRlbmRzIEFueVJvdXRlcj4gPVxuICBpbmZlclJvdXRlclJvb3RUeXBlczxUUm91dGVyPlsnY3R4J107XG5leHBvcnQgdHlwZSBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXIgZXh0ZW5kcyBBbnlSb3V0ZXI+ID1cbiAgaW5mZXJSb3V0ZXJSb290VHlwZXM8VFJvdXRlcj5bJ2Vycm9yU2hhcGUnXTtcbmV4cG9ydCB0eXBlIGluZmVyUm91dGVyTWV0YTxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPiA9XG4gIGluZmVyUm91dGVyUm9vdFR5cGVzPFRSb3V0ZXI+WydtZXRhJ107XG5cbmZ1bmN0aW9uIGlzUm91dGVyKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQW55Um91dGVyIHtcbiAgcmV0dXJuIChcbiAgICBpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWVbJ19kZWYnXSkgJiYgJ3JvdXRlcicgaW4gdmFsdWVbJ19kZWYnXVxuICApO1xufVxuXG5jb25zdCBlbXB0eVJvdXRlciA9IHtcbiAgX2N0eDogbnVsbCBhcyBhbnksXG4gIF9lcnJvclNoYXBlOiBudWxsIGFzIGFueSxcbiAgX21ldGE6IG51bGwgYXMgYW55LFxuICBxdWVyaWVzOiB7fSxcbiAgbXV0YXRpb25zOiB7fSxcbiAgc3Vic2NyaXB0aW9uczoge30sXG4gIGVycm9yRm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuICB0cmFuc2Zvcm1lcjogZGVmYXVsdFRyYW5zZm9ybWVyLFxufTtcblxuLyoqXG4gKiBSZXNlcnZlZCB3b3JkcyB0aGF0IGNhbid0IGJlIHVzZWQgYXMgcm91dGVyIG9yIHByb2NlZHVyZSBuYW1lc1xuICovXG5jb25zdCByZXNlcnZlZFdvcmRzID0gW1xuICAvKipcbiAgICogVGhlbiBpcyBhIHJlc2VydmVkIHdvcmQgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2FuJ3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJldHVybnMgYSBQcm94eVxuICAgKiBzaW5jZSBKUyB3aWxsIHRoaW5rIHRoYXQgYC50aGVuYCBpcyBzb21ldGhpbmcgdGhhdCBleGlzdHNcbiAgICovXG4gICd0aGVuJyxcbiAgLyoqXG4gICAqIGBmbi5jYWxsKClgIGFuZCBgZm4uYXBwbHkoKWAgYXJlIHJlc2VydmVkIHdvcmRzIGJlY2F1c2Ugb3RoZXJ3aXNlIHdlIGNhbid0IGNhbGwgYSBmdW5jdGlvbiB1c2luZyBgLmNhbGxgIG9yIGAuYXBwbHlgXG4gICAqL1xuICAnY2FsbCcsXG4gICdhcHBseScsXG5dO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSBDcmVhdGVSb3V0ZXJPcHRpb25zID0ge1xuICBba2V5OiBzdHJpbmddOlxuICAgIHwgQW55UHJvY2VkdXJlXG4gICAgfCBBbnlSb3V0ZXJcbiAgICB8IENyZWF0ZVJvdXRlck9wdGlvbnNcbiAgICB8IExhenk8QW55Um91dGVyPjtcbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB0eXBlIERlY29yYXRlQ3JlYXRlUm91dGVyT3B0aW9uczxcbiAgVFJvdXRlck9wdGlvbnMgZXh0ZW5kcyBDcmVhdGVSb3V0ZXJPcHRpb25zLFxuPiA9IHtcbiAgW0sgaW4ga2V5b2YgVFJvdXRlck9wdGlvbnNdOiBUUm91dGVyT3B0aW9uc1tLXSBleHRlbmRzIGluZmVyICRWYWx1ZVxuICAgID8gJFZhbHVlIGV4dGVuZHMgQW55UHJvY2VkdXJlXG4gICAgICA/ICRWYWx1ZVxuICAgICAgOiAkVmFsdWUgZXh0ZW5kcyBSb3V0ZXI8YW55LCBpbmZlciBUUmVjb3JkPlxuICAgICAgICA/IFRSZWNvcmRcbiAgICAgICAgOiAkVmFsdWUgZXh0ZW5kcyBMYXp5PFJvdXRlcjxhbnksIGluZmVyIFRSZWNvcmQ+PlxuICAgICAgICAgID8gVFJlY29yZFxuICAgICAgICAgIDogJFZhbHVlIGV4dGVuZHMgQ3JlYXRlUm91dGVyT3B0aW9uc1xuICAgICAgICAgICAgPyBEZWNvcmF0ZUNyZWF0ZVJvdXRlck9wdGlvbnM8JFZhbHVlPlxuICAgICAgICAgICAgOiBuZXZlclxuICAgIDogbmV2ZXI7XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVyRmFjdG9yeTxUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcz4oXG4gIGNvbmZpZzogUm9vdENvbmZpZzxUUm9vdD4sXG4pIHtcbiAgZnVuY3Rpb24gY3JlYXRlUm91dGVySW5uZXI8VElucHV0IGV4dGVuZHMgQ3JlYXRlUm91dGVyT3B0aW9ucz4oXG4gICAgaW5wdXQ6IFRJbnB1dCxcbiAgKTogQnVpbHRSb3V0ZXI8VFJvb3QsIERlY29yYXRlQ3JlYXRlUm91dGVyT3B0aW9uczxUSW5wdXQ+PiB7XG4gICAgY29uc3QgcmVzZXJ2ZWRXb3Jkc1VzZWQgPSBuZXcgU2V0KFxuICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZpbHRlcigodikgPT4gcmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyh2KSksXG4gICAgKTtcbiAgICBpZiAocmVzZXJ2ZWRXb3Jkc1VzZWQuc2l6ZSA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1Jlc2VydmVkIHdvcmRzIHVzZWQgaW4gYHJvdXRlcih7fSlgIGNhbGw6ICcgK1xuICAgICAgICAgIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oJywgJyksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2NlZHVyZXM6IFJlY29yZDxzdHJpbmcsIEFueVByb2NlZHVyZT4gPSBvbWl0UHJvdG90eXBlKHt9KTtcbiAgICBjb25zdCBsYXp5OiBSZWNvcmQ8c3RyaW5nLCBMYXp5TG9hZGVyPEFueVJvdXRlcj4+ID0gb21pdFByb3RvdHlwZSh7fSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMYXp5TG9hZGVyKG9wdHM6IHtcbiAgICAgIHJlZjogTGF6eTxBbnlSb3V0ZXI+O1xuICAgICAgcGF0aDogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgICBrZXk6IHN0cmluZztcbiAgICAgIGFnZ3JlZ2F0ZTogUm91dGVyUmVjb3JkO1xuICAgIH0pOiBMYXp5TG9hZGVyPEFueVJvdXRlcj4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBvcHRzLnJlZixcbiAgICAgICAgbG9hZDogb25jZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm91dGVyID0gYXdhaXQgb3B0cy5yZWYoKTtcbiAgICAgICAgICBjb25zdCBsYXp5UGF0aCA9IFsuLi5vcHRzLnBhdGgsIG9wdHMua2V5XTtcbiAgICAgICAgICBjb25zdCBsYXp5S2V5ID0gbGF6eVBhdGguam9pbignLicpO1xuXG4gICAgICAgICAgb3B0cy5hZ2dyZWdhdGVbb3B0cy5rZXldID0gc3RlcChyb3V0ZXIuX2RlZi5yZWNvcmQsIGxhenlQYXRoKTtcblxuICAgICAgICAgIGRlbGV0ZSBsYXp5W2xhenlLZXldO1xuXG4gICAgICAgICAgLy8gYWRkIGxhenkgbG9hZGVycyBmb3IgbmVzdGVkIHJvdXRlcnNcbiAgICAgICAgICBmb3IgKGNvbnN0IFtuZXN0ZWRLZXksIG5lc3RlZEl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICAgICAgcm91dGVyLl9kZWYubGF6eSxcbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRSb3V0ZXJLZXkgPSBbLi4ubGF6eVBhdGgsIG5lc3RlZEtleV0uam9pbignLicpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWRkaW5nIGxhenknLCBuZXN0ZWRSb3V0ZXJLZXkpO1xuICAgICAgICAgICAgbGF6eVtuZXN0ZWRSb3V0ZXJLZXldID0gY3JlYXRlTGF6eUxvYWRlcih7XG4gICAgICAgICAgICAgIHJlZjogbmVzdGVkSXRlbS5yZWYsXG4gICAgICAgICAgICAgIHBhdGg6IGxhenlQYXRoLFxuICAgICAgICAgICAgICBrZXk6IG5lc3RlZEtleSxcbiAgICAgICAgICAgICAgYWdncmVnYXRlOiBvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV0gYXMgUm91dGVyUmVjb3JkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcChmcm9tOiBDcmVhdGVSb3V0ZXJPcHRpb25zLCBwYXRoOiByZWFkb25seSBzdHJpbmdbXSA9IFtdKSB7XG4gICAgICBjb25zdCBhZ2dyZWdhdGU6IFJvdXRlclJlY29yZCA9IG9taXRQcm90b3R5cGUoe30pO1xuICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhmcm9tID8/IHt9KSkge1xuICAgICAgICBpZiAoaXNMYXp5KGl0ZW0pKSB7XG4gICAgICAgICAgbGF6eVtbLi4ucGF0aCwga2V5XS5qb2luKCcuJyldID0gY3JlYXRlTGF6eUxvYWRlcih7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcmVmOiBpdGVtLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgYWdncmVnYXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JvdXRlcihpdGVtKSkge1xuICAgICAgICAgIGFnZ3JlZ2F0ZVtrZXldID0gc3RlcChpdGVtLl9kZWYucmVjb3JkLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Byb2NlZHVyZShpdGVtKSkge1xuICAgICAgICAgIC8vIFJvdXRlclJlY29yZFxuICAgICAgICAgIGFnZ3JlZ2F0ZVtrZXldID0gc3RlcChpdGVtLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdQYXRoID0gWy4uLnBhdGgsIGtleV0uam9pbignLicpO1xuXG4gICAgICAgIGlmIChwcm9jZWR1cmVzW25ld1BhdGhdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUga2V5OiAke25ld1BhdGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZWR1cmVzW25ld1BhdGhdID0gaXRlbTtcbiAgICAgICAgYWdncmVnYXRlW2tleV0gPSBpdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWdncmVnYXRlO1xuICAgIH1cbiAgICBjb25zdCByZWNvcmQgPSBzdGVwKGlucHV0KTtcblxuICAgIGNvbnN0IF9kZWY6IEFueVJvdXRlclsnX2RlZiddID0ge1xuICAgICAgX2NvbmZpZzogY29uZmlnLFxuICAgICAgcm91dGVyOiB0cnVlLFxuICAgICAgcHJvY2VkdXJlcyxcbiAgICAgIGxhenksXG4gICAgICAuLi5lbXB0eVJvdXRlcixcbiAgICAgIHJlY29yZCxcbiAgICB9O1xuXG4gICAgY29uc3Qgcm91dGVyOiBCdWlsdFJvdXRlcjxUUm9vdCwge30+ID0ge1xuICAgICAgLi4uKHJlY29yZCBhcyB7fSksXG4gICAgICBfZGVmLFxuICAgICAgY3JlYXRlQ2FsbGVyOiBjcmVhdGVDYWxsZXJGYWN0b3J5PFRSb290PigpKHtcbiAgICAgICAgX2RlZixcbiAgICAgIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIHJvdXRlciBhcyBCdWlsdFJvdXRlcjxUUm9vdCwgRGVjb3JhdGVDcmVhdGVSb3V0ZXJPcHRpb25zPFRJbnB1dD4+O1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcklubmVyO1xufVxuXG5mdW5jdGlvbiBpc1Byb2NlZHVyZShcbiAgcHJvY2VkdXJlT3JSb3V0ZXI6IFZhbHVlT2Y8Q3JlYXRlUm91dGVyT3B0aW9ucz4sXG4pOiBwcm9jZWR1cmVPclJvdXRlciBpcyBBbnlQcm9jZWR1cmUge1xuICByZXR1cm4gdHlwZW9mIHByb2NlZHVyZU9yUm91dGVyID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvY2VkdXJlQXRQYXRoKFxuICByb3V0ZXI6IFBpY2s8Um91dGVyPGFueSwgYW55PiwgJ19kZWYnPixcbiAgcGF0aDogc3RyaW5nLFxuKTogUHJvbWlzZTxBbnlQcm9jZWR1cmUgfCBudWxsPiB7XG4gIGNvbnN0IHsgX2RlZiB9ID0gcm91dGVyO1xuICBsZXQgcHJvY2VkdXJlID0gX2RlZi5wcm9jZWR1cmVzW3BhdGhdO1xuXG4gIHdoaWxlICghcHJvY2VkdXJlKSB7XG4gICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMoX2RlZi5sYXp5KS5maW5kKChrZXkpID0+IHBhdGguc3RhcnRzV2l0aChrZXkpKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgZm91bmQgbGF6eTogJHtrZXkgPz8gJ05PUEUnfSAoZnVsbFBhdGg6ICR7ZnVsbFBhdGh9KWApO1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnbG9hZGluZycsIGtleSwgJy4uLi4uLi4nKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IGxhenlSb3V0ZXIgPSBfZGVmLmxhenlba2V5XSE7XG4gICAgYXdhaXQgbGF6eVJvdXRlci5sb2FkKCk7XG5cbiAgICBwcm9jZWR1cmUgPSBfZGVmLnByb2NlZHVyZXNbcGF0aF07XG4gIH1cblxuICByZXR1cm4gcHJvY2VkdXJlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbFByb2NlZHVyZShcbiAgb3B0czogUHJvY2VkdXJlQ2FsbE9wdGlvbnM8dW5rbm93bj4gJiB7XG4gICAgcm91dGVyOiBBbnlSb3V0ZXI7XG4gICAgYWxsb3dNZXRob2RPdmVycmlkZT86IGJvb2xlYW47XG4gIH0sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBwYXRoIH0gPSBvcHRzO1xuICBjb25zdCBwcm9jID0gYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBwYXRoKTtcbiAgaWYgKFxuICAgICFwcm9jIHx8XG4gICAgIWlzUHJvY2VkdXJlKHByb2MpIHx8XG4gICAgKHByb2MuX2RlZi50eXBlICE9PSB0eXBlICYmICFvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUpXG4gICkge1xuICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICBtZXNzYWdlOiBgTm8gXCIke3R5cGV9XCItcHJvY2VkdXJlIG9uIHBhdGggXCIke3BhdGh9XCJgLFxuICAgIH0pO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuICBpZiAoXG4gICAgcHJvYy5fZGVmLnR5cGUgIT09IHR5cGUgJiZcbiAgICBvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUgJiZcbiAgICBwcm9jLl9kZWYudHlwZSA9PT0gJ3N1YnNjcmlwdGlvbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICBjb2RlOiAnTUVUSE9EX05PVF9TVVBQT1JURUQnLFxuICAgICAgbWVzc2FnZTogYE1ldGhvZCBvdmVycmlkZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdWJzY3JpcHRpb25zYCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwcm9jKG9wdHMpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNhbGxlckZhY3Rvcnk8VFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXM+IHtcbiAgPFRSZWNvcmQgZXh0ZW5kcyBSb3V0ZXJSZWNvcmQ+KFxuICAgIHJvdXRlcjogUGljazxSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+LCAnX2RlZic+LFxuICApOiBSb3V0ZXJDYWxsZXI8VFJvb3QsIFRSZWNvcmQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FsbGVyRmFjdG9yeTxcbiAgVFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXMsXG4+KCk6IFJvdXRlckNhbGxlckZhY3Rvcnk8VFJvb3Q+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcklubmVyPFRSZWNvcmQgZXh0ZW5kcyBSb3V0ZXJSZWNvcmQ+KFxuICAgIHJvdXRlcjogUGljazxSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+LCAnX2RlZic+LFxuICApOiBSb3V0ZXJDYWxsZXI8VFJvb3QsIFRSZWNvcmQ+IHtcbiAgICBjb25zdCB7IF9kZWYgfSA9IHJvdXRlcjtcbiAgICB0eXBlIENvbnRleHQgPSBUUm9vdFsnY3R4J107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVyKGN0eE9yQ2FsbGJhY2ssIG9wdHMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWN1cnNpdmVQcm94eTxSZXR1cm5UeXBlPFJvdXRlckNhbGxlcjxhbnksIGFueT4+PihcbiAgICAgICAgYXN5bmMgKHsgcGF0aCwgYXJncyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oJy4nKTtcblxuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiBwYXRoWzBdID09PSAnX2RlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGVmO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChyb3V0ZXIsIGZ1bGxQYXRoKTtcblxuICAgICAgICAgIGxldCBjdHg6IENvbnRleHQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcHJvY2VkdXJlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6ICdOT1RfRk9VTkQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBObyBwcm9jZWR1cmUgZm91bmQgb24gcGF0aCBcIiR7cGF0aH1cImAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4ID0gaXNGdW5jdGlvbihjdHhPckNhbGxiYWNrKVxuICAgICAgICAgICAgICA/IGF3YWl0IFByb21pc2UucmVzb2x2ZShjdHhPckNhbGxiYWNrKCkpXG4gICAgICAgICAgICAgIDogY3R4T3JDYWxsYmFjaztcblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2NlZHVyZSh7XG4gICAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgICBnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4gYXJnc1swXSxcbiAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICB0eXBlOiBwcm9jZWR1cmUuX2RlZi50eXBlLFxuICAgICAgICAgICAgICBzaWduYWw6IG9wdHM/LnNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICBvcHRzPy5vbkVycm9yPy4oe1xuICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgIGVycm9yOiBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksXG4gICAgICAgICAgICAgIGlucHV0OiBhcmdzWzBdLFxuICAgICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgICAgdHlwZTogcHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gJ3Vua25vd24nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBjYXVzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH07XG4gIH07XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB0eXBlIE1lcmdlUm91dGVyczxcbiAgVFJvdXRlcnMgZXh0ZW5kcyBBbnlSb3V0ZXJbXSxcbiAgVFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXMgPSBUUm91dGVyc1swXVsnX2RlZiddWydfY29uZmlnJ11bJyR0eXBlcyddLFxuICBUUmVjb3JkIGV4dGVuZHMgUm91dGVyUmVjb3JkID0ge30sXG4+ID0gVFJvdXRlcnMgZXh0ZW5kcyBbXG4gIGluZmVyIEhlYWQgZXh0ZW5kcyBBbnlSb3V0ZXIsXG4gIC4uLmluZmVyIFRhaWwgZXh0ZW5kcyBBbnlSb3V0ZXJbXSxcbl1cbiAgPyBNZXJnZVJvdXRlcnM8VGFpbCwgVFJvb3QsIEhlYWRbJ19kZWYnXVsncmVjb3JkJ10gJiBUUmVjb3JkPlxuICA6IEJ1aWx0Um91dGVyPFRSb290LCBUUmVjb3JkPjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUm91dGVyczxUUm91dGVycyBleHRlbmRzIEFueVJvdXRlcltdPihcbiAgLi4ucm91dGVyTGlzdDogWy4uLlRSb3V0ZXJzXVxuKTogTWVyZ2VSb3V0ZXJzPFRSb3V0ZXJzPiB7XG4gIGNvbnN0IHJlY29yZCA9IG1lcmdlV2l0aG91dE92ZXJyaWRlcyhcbiAgICB7fSxcbiAgICAuLi5yb3V0ZXJMaXN0Lm1hcCgocikgPT4gci5fZGVmLnJlY29yZCksXG4gICk7XG4gIGNvbnN0IGVycm9yRm9ybWF0dGVyID0gcm91dGVyTGlzdC5yZWR1Y2UoXG4gICAgKGN1cnJlbnRFcnJvckZvcm1hdHRlciwgbmV4dFJvdXRlcikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAmJlxuICAgICAgICBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlclxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IGRlZmF1bHRGb3JtYXR0ZXIgJiZcbiAgICAgICAgICBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNlZW0gdG8gaGF2ZSBzZXZlcmFsIGVycm9yIGZvcm1hdHRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudEVycm9yRm9ybWF0dGVyO1xuICAgIH0sXG4gICAgZGVmYXVsdEZvcm1hdHRlcixcbiAgKTtcblxuICBjb25zdCB0cmFuc2Zvcm1lciA9IHJvdXRlckxpc3QucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgJiZcbiAgICAgIGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICE9PSBkZWZhdWx0VHJhbnNmb3JtZXJcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJldiAhPT0gZGVmYXVsdFRyYW5zZm9ybWVyICYmXG4gICAgICAgIHByZXYgIT09IGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIHNldmVyYWwgdHJhbnNmb3JtZXJzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHJldHVybiBwcmV2O1xuICB9LCBkZWZhdWx0VHJhbnNmb3JtZXIpO1xuXG4gIGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdXRlckZhY3Rvcnkoe1xuICAgIGVycm9yRm9ybWF0dGVyLFxuICAgIHRyYW5zZm9ybWVyLFxuICAgIGlzRGV2OiByb3V0ZXJMaXN0LmV2ZXJ5KChyKSA9PiByLl9kZWYuX2NvbmZpZy5pc0RldiksXG4gICAgYWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHJvdXRlckxpc3QuZXZlcnkoXG4gICAgICAocikgPT4gci5fZGVmLl9jb25maWcuYWxsb3dPdXRzaWRlT2ZTZXJ2ZXIsXG4gICAgKSxcbiAgICBpc1NlcnZlcjogcm91dGVyTGlzdC5ldmVyeSgocikgPT4gci5fZGVmLl9jb25maWcuaXNTZXJ2ZXIpLFxuICAgICR0eXBlczogcm91dGVyTGlzdFswXT8uX2RlZi5fY29uZmlnLiR0eXBlcyxcbiAgfSkocmVjb3JkKTtcblxuICByZXR1cm4gcm91dGVyIGFzIE1lcmdlUm91dGVyczxUUm91dGVycz47XG59XG4iLCJjb25zdCB0cmFja2VkU3ltYm9sID0gU3ltYm9sKCk7XG5cbnR5cGUgVHJhY2tlZElkID0gc3RyaW5nICYge1xuICBfX2JyYW5kOiAnVHJhY2tlZElkJztcbn07XG5leHBvcnQgdHlwZSBUcmFja2VkRW52ZWxvcGU8VERhdGE+ID0gW1RyYWNrZWRJZCwgVERhdGEsIHR5cGVvZiB0cmFja2VkU3ltYm9sXTtcblxudHlwZSBUcmFja2VkRGF0YTxURGF0YT4gPSB7XG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIG1lc3NhZ2UgdG8ga2VlcCB0cmFjayBvZiBpbiBjYXNlIHRoZSBjb25uZWN0aW9uIGdldHMgbG9zdFxuICAgKi9cbiAgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkYXRhIGZpZWxkIG9mIHRoZSBtZXNzYWdlIC0gdGhpcyBjYW4gYmUgYW55dGhpbmdcbiAgICovXG4gIGRhdGE6IFREYXRhO1xufTtcbi8qKlxuICogUHJvZHVjZSBhIHR5cGVkIHNlcnZlci1zZW50IGV2ZW50IG1lc3NhZ2VcbiAqIEBkZXByZWNhdGVkIHVzZSBgdHJhY2tlZChpZCwgZGF0YSlgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNzZTxURGF0YT4oZXZlbnQ6IHsgaWQ6IHN0cmluZzsgZGF0YTogVERhdGEgfSkge1xuICByZXR1cm4gdHJhY2tlZChldmVudC5pZCwgZXZlbnQuZGF0YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RyYWNrZWRFbnZlbG9wZTxURGF0YT4oXG4gIHZhbHVlOiB1bmtub3duLFxuKTogdmFsdWUgaXMgVHJhY2tlZEVudmVsb3BlPFREYXRhPiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZVsyXSA9PT0gdHJhY2tlZFN5bWJvbDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHRyYWNrIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgZnJvbSBhIGdpdmVuIGlkIGlmIHRoZSBjb25uZWN0aW9uIGlzIGxvc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrZWQ8VERhdGE+KFxuICBpZDogc3RyaW5nLFxuICBkYXRhOiBURGF0YSxcbik6IFRyYWNrZWRFbnZlbG9wZTxURGF0YT4ge1xuICBpZiAoaWQgPT09ICcnKSB7XG4gICAgLy8gVGhpcyBsaW1pdGF0aW9uIGNvdWxkIGJlIHJlbW92ZWQgYnkgdXNpbmcgZGlmZmVyZW50IFNTRSBldmVudCBuYW1lcyAvIGNoYW5uZWxzIGZvciB0cmFja2VkIGV2ZW50IGFuZCBub24tdHJhY2tlZCBldmVudFxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaWRgIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBhcyBlbXB0eSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgbm90IHNldHRpbmcgdGhlIGlkIGF0IGFsbCcsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gW2lkIGFzIFRyYWNrZWRJZCwgZGF0YSwgdHJhY2tlZFN5bWJvbF07XG59XG5cbmV4cG9ydCB0eXBlIGluZmVyVHJhY2tlZE91dHB1dDxURGF0YT4gPVxuICBURGF0YSBleHRlbmRzIFRyYWNrZWRFbnZlbG9wZTxpbmZlciAkRGF0YT4gPyBUcmFja2VkRGF0YTwkRGF0YT4gOiBURGF0YTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0Rm9ybWF0dGVyOiBFcnJvckZvcm1hdHRlcjxhbnksIGFueT4iLCJjYXVzZTogdW5rbm93biIsIm9wdHM6IHtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIGNvZGU6IFRSUENfRVJST1JfQ09ERV9LRVk7XG4gICAgY2F1c2U/OiB1bmtub3duO1xuICB9IiwidHJhbnNmb3JtZXI6IERhdGFUcmFuc2Zvcm1lck9wdGlvbnMiLCJkZWZhdWx0VHJhbnNmb3JtZXI6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyIiwiY29uZmlnOiBSb290Q29uZmlnPEFueVJvb3RUeXBlcz4iLCJpdGVtOiBUUmVzcG9uc2VJdGVtIiwiaXRlbU9ySXRlbXM6IFRSZXNwb25zZSIsInJlc3BvbnNlOlxuICAgIHwgVFJQQ1Jlc3BvbnNlPFRPdXRwdXQsIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+XG4gICAgfCBUUlBDUmVzcG9uc2VNZXNzYWdlPFRPdXRwdXQsIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+IiwidHJhbnNmb3JtZXI6IERhdGFUcmFuc2Zvcm1lciIsInJlc3VsdDogUmV0dXJuVHlwZTx0eXBlb2YgdHJhbnNmb3JtUmVzdWx0SW5uZXI+IiwiZm46ICgpID0+IFQiLCJyZXN1bHQ6IFQgfCB0eXBlb2YgdW5jYWxsZWQiLCJpbXBvcnRSb3V0ZXI6ICgpID0+IFByb21pc2U8XG4gICAgfCBUUm91dGVyXG4gICAgfCB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IFRSb3V0ZXI7XG4gICAgICB9XG4gID4iLCJpbnB1dDogdW5rbm93biIsInZhbHVlOiB1bmtub3duIiwiY29uZmlnOiBSb290Q29uZmlnPFRSb290PiIsImlucHV0OiBUSW5wdXQiLCJwcm9jZWR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBBbnlQcm9jZWR1cmU+IiwibGF6eTogUmVjb3JkPHN0cmluZywgTGF6eUxvYWRlcjxBbnlSb3V0ZXI+PiIsIm9wdHM6IHtcbiAgICAgIHJlZjogTGF6eTxBbnlSb3V0ZXI+O1xuICAgICAgcGF0aDogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgICBrZXk6IHN0cmluZztcbiAgICAgIGFnZ3JlZ2F0ZTogUm91dGVyUmVjb3JkO1xuICAgIH0iLCJyb3V0ZXIiLCJsYXp5IiwiZnJvbTogQ3JlYXRlUm91dGVyT3B0aW9ucyIsInBhdGg6IHJlYWRvbmx5IHN0cmluZ1tdIiwiYWdncmVnYXRlOiBSb3V0ZXJSZWNvcmQiLCJfZGVmOiBBbnlSb3V0ZXJbJ19kZWYnXSIsInJvdXRlcjogQnVpbHRSb3V0ZXI8VFJvb3QsIHt9PiIsInByb2NlZHVyZU9yUm91dGVyOiBWYWx1ZU9mPENyZWF0ZVJvdXRlck9wdGlvbnM+Iiwicm91dGVyOiBQaWNrPFJvdXRlcjxhbnksIGFueT4sICdfZGVmJz4iLCJwYXRoOiBzdHJpbmciLCJrZXkiLCJvcHRzOiBQcm9jZWR1cmVDYWxsT3B0aW9uczx1bmtub3duPiAmIHtcbiAgICByb3V0ZXI6IEFueVJvdXRlcjtcbiAgICBhbGxvd01ldGhvZE92ZXJyaWRlPzogYm9vbGVhbjtcbiAgfSIsInJvdXRlcjogUGljazxSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+LCAnX2RlZic+IiwiY3R4OiBDb250ZXh0IHwgdW5kZWZpbmVkIiwiZXZlbnQ6IHsgaWQ6IHN0cmluZzsgZGF0YTogVERhdGEgfSIsImlkOiBzdHJpbmciLCJkYXRhOiBURGF0YSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPC_ERROR_CODES_BY_KEY: () => (/* binding */ TRPC_ERROR_CODES_BY_KEY),\n/* harmony export */   TRPC_ERROR_CODES_BY_NUMBER: () => (/* binding */ TRPC_ERROR_CODES_BY_NUMBER),\n/* harmony export */   abortSignalsAnyPonyfill: () => (/* binding */ abortSignalsAnyPonyfill),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeWithoutOverrides: () => (/* binding */ mergeWithoutOverrides),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omitPrototype: () => (/* binding */ omitPrototype),\n/* harmony export */   retryableRpcCodes: () => (/* binding */ retryableRpcCodes),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we're copying the last digits of HTTP 4XX errors.\n*/ const TRPC_ERROR_CODES_BY_KEY = {\n    PARSE_ERROR: -32700,\n    BAD_REQUEST: -32600,\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    BAD_GATEWAY: -32603,\n    SERVICE_UNAVAILABLE: -32603,\n    GATEWAY_TIMEOUT: -32603,\n    UNAUTHORIZED: -32001,\n    PAYMENT_REQUIRED: -32002,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNSUPPORTED_MEDIA_TYPE: -32015,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n    [-32700]: \"PARSE_ERROR\",\n    [-32600]: \"BAD_REQUEST\",\n    [-32603]: \"INTERNAL_SERVER_ERROR\",\n    [-32001]: \"UNAUTHORIZED\",\n    [-32002]: \"PAYMENT_REQUIRED\",\n    [-32003]: \"FORBIDDEN\",\n    [-32004]: \"NOT_FOUND\",\n    [-32005]: \"METHOD_NOT_SUPPORTED\",\n    [-32008]: \"TIMEOUT\",\n    [-32009]: \"CONFLICT\",\n    [-32012]: \"PRECONDITION_FAILED\",\n    [-32013]: \"PAYLOAD_TOO_LARGE\",\n    [-32015]: \"UNSUPPORTED_MEDIA_TYPE\",\n    [-32022]: \"UNPROCESSABLE_CONTENT\",\n    [-32029]: \"TOO_MANY_REQUESTS\",\n    [-32099]: \"CLIENT_CLOSED_REQUEST\"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/ const retryableRpcCodes = [\n    TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n    TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n    TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n    TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n//#endregion\n//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs)for(const key in overrides){\n        if (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n        newObj[key] = overrides[key];\n    }\n    return newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/ function isObject(value) {\n    return !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === \"function\" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n    return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/ const run = (fn)=>fn();\nfunction noop() {}\nfunction identity(it) {\n    return it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/ function assert(condition, msg = \"no additional info\") {\n    if (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/ function abortSignalsAnyPonyfill(signals) {\n    if (typeof AbortSignal.any === \"function\") return AbortSignal.any(signals);\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal.aborted) {\n            trigger();\n            break;\n        }\n        signal.addEventListener(\"abort\", trigger, {\n            once: true\n        });\n    }\n    return ac.signal;\n    function trigger() {\n        ac.abort();\n        for (const signal of signals)signal.removeEventListener(\"abort\", trigger);\n    }\n}\n//#endregion\n //# sourceMappingURL=utils-DdbbrDku.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvdXRpbHMtRGRiYnJEa3UubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBVUEsTUFBYSwwQkFBMEI7SUFLckMsYUFBYTtJQUliLGFBQWE7SUFHYix1QkFBdUI7SUFDdkIsaUJBQWlCO0lBQ2pCLGFBQWE7SUFDYixxQkFBcUI7SUFDckIsaUJBQWlCO0lBR2pCLGNBQWM7SUFDZCxrQkFBa0I7SUFDbEIsV0FBVztJQUNYLFdBQVc7SUFDWCxzQkFBc0I7SUFDdEIsU0FBUztJQUNULFVBQVU7SUFDVixxQkFBcUI7SUFDckIsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4Qix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLHVCQUF1QjtBQUN4QjtBQUdELE1BQWFBLDZCQUVUO0tBQ0QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztBQUNYOzs7O0dBU0QsTUFBYUMsb0JBQThDO0lBQ3pELHdCQUF3QjtJQUN4Qix3QkFBd0I7SUFDeEIsd0JBQXdCO0lBQ3hCLHdCQUF3QjtDQUN6Qjs7Ozs7O0dDckVELFNBQWdCLHNCQUNkQyxJQUFBQSxFQUNBLEdBQUcsTUFDSTtJQUNQLE1BQU1DLFNBQWdCLE9BQU8sT0FBTyxPQUFPLE9BQU8sS0FBSyxFQUFFLEtBQUs7SUFFOUQsS0FBSyxNQUFNLGFBQWEsS0FDdEIsSUFBSyxNQUFNLE9BQU8sVUFBVztRQUMzQixJQUFJLE9BQU8sVUFBVSxPQUFPLFNBQVMsVUFBVSxLQUM3QyxPQUFNLElBQUksT0FBTyxnQkFBZ0IsSUFBSTtRQUV2QyxPQUFPLE9BQXNCLFVBQVU7SUFDeEM7SUFFSCxPQUFPO0FBQ1I7Ozs7R0FNRCxTQUFnQixTQUFTQyxLQUFBQSxFQUFrRDtJQUN6RSxTQUFTLFVBQVUsTUFBTSxRQUFRLE1BQU0sV0FBVyxVQUFVO0FBQzdEO0FBR0QsU0FBZ0IsV0FBV0MsRUFBQUEsRUFBMEI7SUFDbkQsY0FBYyxPQUFPO0FBQ3RCOzs7O0dBTUQsU0FBZ0IsY0FDZEMsR0FBQUEsRUFDTTtJQUNOLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLEVBQUUsSUFBSTtBQUMvQztBQUVELE1BQU0saUNBQ0csV0FBVyxnQkFBZ0IsT0FBTztBQUUzQyxTQUFnQixnQkFDZEYsS0FBQUEsRUFDZ0M7SUFDaEMsT0FDRSwyQkFBMkIsU0FBUyxNQUFNLElBQUksT0FBTyxpQkFBaUI7QUFFekU7OztHQUtELE1BQWEsTUFBTSxDQUFTRyxLQUE2QixJQUFJO0FBRzdELFNBQWdCLE9BQWEsQ0FBRTtBQUUvQixTQUFnQixTQUFZQyxFQUFBQSxFQUFVO0lBQ3BDLE9BQU87QUFDUjs7Ozs7O0dBUUQsU0FBZ0IsT0FDZEMsU0FBQUEsRUFDQSxNQUFNLHNCQUNhO0lBQ25CLEtBQUssVUFDSCxPQUFNLElBQUksT0FBTyxrQkFBa0IsSUFBSTtBQUUxQztBQUVELFNBQWdCLE1BQU0sS0FBSyxHQUFrQjtJQUMzQyxPQUFPLElBQUksUUFBYyxDQUFDLE1BQVEsV0FBVyxLQUFLLEdBQUc7QUFDdEQ7Ozs7R0FNRCxTQUFnQix3QkFBd0JDLE9BQUFBLEVBQXFDO0lBQzNFLFdBQVcsWUFBWSxRQUFRLFdBQzdCLFFBQU8sWUFBWSxJQUFJLFFBQVE7SUFHakMsTUFBTSxLQUFLLElBQUk7SUFFZixLQUFLLE1BQU0sVUFBVSxRQUFTO1FBQzVCLElBQUksT0FBTyxTQUFTO1lBQ2xCLFNBQVM7WUFDVDtRQUNEO1FBQ0QsT0FBTyxpQkFBaUIsU0FBUyxTQUFTO1lBQUUsTUFBTTtRQUFNLEVBQUM7SUFDMUQ7SUFFRCxPQUFPLEdBQUc7SUFFVixTQUFTLFVBQVU7UUFDakIsR0FBRyxPQUFPO1FBQ1YsS0FBSyxNQUFNLFVBQVUsUUFDbkIsT0FBTyxvQkFBb0IsU0FBUyxRQUFRO0lBRS9DO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9ycGMvY29kZXMudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbnZlcnRLZXlWYWx1ZSwgVmFsdWVPZiB9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gcmVmZXJlbmNlOiBodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uXG5cbi8qKlxuICogSlNPTi1SUEMgMi4wIEVycm9yIGNvZGVzXG4gKlxuICogYC0zMjAwMGAgdG8gYC0zMjA5OWAgYXJlIHJlc2VydmVkIGZvciBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHNlcnZlci1lcnJvcnMuXG4gKiBGb3IgdFJQQyB3ZSdyZSBjb3B5aW5nIHRoZSBsYXN0IGRpZ2l0cyBvZiBIVFRQIDRYWCBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSA9IHtcbiAgLyoqXG4gICAqIEludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci5cbiAgICogQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuXG4gICAqL1xuICBQQVJTRV9FUlJPUjogLTMyNzAwLFxuICAvKipcbiAgICogVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIEJBRF9SRVFVRVNUOiAtMzI2MDAsIC8vIDQwMFxuXG4gIC8vIEludGVybmFsIEpTT04tUlBDIGVycm9yXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogLTMyNjAzLCAvLyA1MDBcbiAgTk9UX0lNUExFTUVOVEVEOiAtMzI2MDMsIC8vIDUwMVxuICBCQURfR0FURVdBWTogLTMyNjAzLCAvLyA1MDJcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogLTMyNjAzLCAvLyA1MDNcbiAgR0FURVdBWV9USU1FT1VUOiAtMzI2MDMsIC8vIDUwNFxuXG4gIC8vIEltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yc1xuICBVTkFVVEhPUklaRUQ6IC0zMjAwMSwgLy8gNDAxXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IC0zMjAwMiwgLy8gNDAyXG4gIEZPUkJJRERFTjogLTMyMDAzLCAvLyA0MDNcbiAgTk9UX0ZPVU5EOiAtMzIwMDQsIC8vIDQwNFxuICBNRVRIT0RfTk9UX1NVUFBPUlRFRDogLTMyMDA1LCAvLyA0MDVcbiAgVElNRU9VVDogLTMyMDA4LCAvLyA0MDhcbiAgQ09ORkxJQ1Q6IC0zMjAwOSwgLy8gNDA5XG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IC0zMjAxMiwgLy8gNDEyXG4gIFBBWUxPQURfVE9PX0xBUkdFOiAtMzIwMTMsIC8vIDQxM1xuICBVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiAtMzIwMTUsIC8vIDQxNVxuICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IC0zMjAyMiwgLy8gNDIyXG4gIFRPT19NQU5ZX1JFUVVFU1RTOiAtMzIwMjksIC8vIDQyOVxuICBDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IC0zMjA5OSwgLy8gNDk5XG59IGFzIGNvbnN0O1xuXG4vLyBwdXJlXG5leHBvcnQgY29uc3QgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVI6IEludmVydEtleVZhbHVlPFxuICB0eXBlb2YgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVlcbj4gPSB7XG4gIFstMzI3MDBdOiAnUEFSU0VfRVJST1InLFxuICBbLTMyNjAwXTogJ0JBRF9SRVFVRVNUJyxcbiAgWy0zMjYwM106ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICBbLTMyMDAxXTogJ1VOQVVUSE9SSVpFRCcsXG4gIFstMzIwMDJdOiAnUEFZTUVOVF9SRVFVSVJFRCcsXG4gIFstMzIwMDNdOiAnRk9SQklEREVOJyxcbiAgWy0zMjAwNF06ICdOT1RfRk9VTkQnLFxuICBbLTMyMDA1XTogJ01FVEhPRF9OT1RfU1VQUE9SVEVEJyxcbiAgWy0zMjAwOF06ICdUSU1FT1VUJyxcbiAgWy0zMjAwOV06ICdDT05GTElDVCcsXG4gIFstMzIwMTJdOiAnUFJFQ09ORElUSU9OX0ZBSUxFRCcsXG4gIFstMzIwMTNdOiAnUEFZTE9BRF9UT09fTEFSR0UnLFxuICBbLTMyMDE1XTogJ1VOU1VQUE9SVEVEX01FRElBX1RZUEUnLFxuICBbLTMyMDIyXTogJ1VOUFJPQ0VTU0FCTEVfQ09OVEVOVCcsXG4gIFstMzIwMjldOiAnVE9PX01BTllfUkVRVUVTVFMnLFxuICBbLTMyMDk5XTogJ0NMSUVOVF9DTE9TRURfUkVRVUVTVCcsXG59O1xuXG5leHBvcnQgdHlwZSBUUlBDX0VSUk9SX0NPREVfTlVNQkVSID0gVmFsdWVPZjx0eXBlb2YgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVk+O1xuZXhwb3J0IHR5cGUgVFJQQ19FUlJPUl9DT0RFX0tFWSA9IGtleW9mIHR5cGVvZiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWTtcblxuLyoqXG4gKiB0UlBDIGVycm9yIGNvZGVzIHRoYXQgYXJlIGNvbnNpZGVyZWQgcmV0cnlhYmxlXG4gKiBXaXRoIG91dCBvZiB0aGUgYm94IFNTRSwgdGhlIGNsaWVudCB3aWxsIHJlY29ubmVjdCB3aGVuIHRoZXNlIGVycm9ycyBhcmUgZW5jb3VudGVyZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHJldHJ5YWJsZVJwY0NvZGVzOiBUUlBDX0VSUk9SX0NPREVfTlVNQkVSW10gPSBbXG4gIFRSUENfRVJST1JfQ09ERVNfQllfS0VZLkJBRF9HQVRFV0FZLFxuICBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5TRVJWSUNFX1VOQVZBSUxBQkxFLFxuICBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5HQVRFV0FZX1RJTUVPVVQsXG4gIFRSUENfRVJST1JfQ09ERVNfQllfS0VZLklOVEVSTkFMX1NFUlZFUl9FUlJPUixcbl07XG4iLCIvKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSBVbnNldE1hcmtlciA9ICd1bnNldE1hcmtlcicgJiB7XG4gIF9fYnJhbmQ6ICd1bnNldE1hcmtlcic7XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZSBrZXlzIHdoZW4gYnVpbGRpbmcgYSBwcm9jZWR1cmUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlV2l0aG91dE92ZXJyaWRlczxUVHlwZSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb2JqMTogVFR5cGUsXG4gIC4uLm9ianM6IFBhcnRpYWw8VFR5cGU+W11cbik6IFRUeXBlIHtcbiAgY29uc3QgbmV3T2JqOiBUVHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqMSk7XG5cbiAgZm9yIChjb25zdCBvdmVycmlkZXMgb2Ygb2Jqcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlcykge1xuICAgICAgaWYgKGtleSBpbiBuZXdPYmogJiYgbmV3T2JqW2tleV0gIT09IG92ZXJyaWRlc1trZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGtleSAke2tleX1gKTtcbiAgICAgIH1cbiAgICAgIG5ld09ialtrZXkgYXMga2V5b2YgVFR5cGVdID0gb3ZlcnJpZGVzW2tleV0gYXMgVFR5cGVba2V5b2YgVFR5cGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG4vKipcbiAqIENoZWNrIHRoYXQgdmFsdWUgaXMgb2JqZWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxudHlwZSBBbnlGbiA9ICgoLi4uYXJnczogYW55W10pID0+IHVua25vd24pICYgUmVjb3JkPGtleW9mIGFueSwgdW5rbm93bj47XG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihmbjogdW5rbm93bik6IGZuIGlzIEFueUZuIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IHdpdGhvdXQgaW5oZXJpdGluZyBhbnl0aGluZyBmcm9tIGBPYmplY3QucHJvdG90eXBlYFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0UHJvdG90eXBlPFRPYmogZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIG9iajogVE9iaixcbik6IFRPYmoge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmopO1xufVxuXG5jb25zdCBhc3luY0l0ZXJhdG9yc1N1cHBvcnRlZCA9XG4gIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wuYXN5bmNJdGVyYXRvcjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZTxUVmFsdWU+KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIEFzeW5jSXRlcmFibGU8VFZhbHVlPiB7XG4gIHJldHVybiAoXG4gICAgYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQgJiYgaXNPYmplY3QodmFsdWUpICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICk7XG59XG5cbi8qKlxuICogUnVuIGFuIElJRkVcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1biA9IDxUVmFsdWU+KGZuOiAoKSA9PiBUVmFsdWUpOiBUVmFsdWUgPT4gZm4oKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKTogdm9pZCB7fVxuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHk8VD4oaXQ6IFQpOiBUIHtcbiAgcmV0dXJuIGl0O1xufVxuXG4vKipcbiAqIEdlbmVyaWMgcnVudGltZSBhc3NlcnRpb24gZnVuY3Rpb24uIFRocm93cywgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgYHRydWVgLlxuICpcbiAqIENhbiBiZSB1c2VkIGFzIGEgc2xpZ2h0bHkgbGVzcyBkYW5nZXJvdXMgdmFyaWFudCBvZiB0eXBlIGFzc2VydGlvbnMuIENvZGVcbiAqIG1pc3Rha2VzIHdvdWxkIGJlIHJldmVhbGVkIGF0IHJ1bnRpbWUgdGhlbiAoaG9wZWZ1bGx5IGR1cmluZyB0ZXN0aW5nKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChcbiAgY29uZGl0aW9uOiBib29sZWFuLFxuICBtc2cgPSAnbm8gYWRkaXRpb25hbCBpbmZvJyxcbik6IGFzc2VydHMgY29uZGl0aW9uIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2VydGlvbkVycm9yOiAke21zZ31gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAobXMgPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbXMpKTtcbn1cblxuLyoqXG4gKiBQb255ZmlsbCBmb3JcbiAqIFtgQWJvcnRTaWduYWwuYW55YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsL2FueV9zdGF0aWMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRTaWduYWxzQW55UG9ueWZpbGwoc2lnbmFsczogQWJvcnRTaWduYWxbXSk6IEFib3J0U2lnbmFsIHtcbiAgaWYgKHR5cGVvZiBBYm9ydFNpZ25hbC5hbnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYW55KHNpZ25hbHMpO1xuICB9XG5cbiAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdHJpZ2dlcigpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRyaWdnZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJldHVybiBhYy5zaWduYWw7XG5cbiAgZnVuY3Rpb24gdHJpZ2dlcigpIHtcbiAgICBhYy5hYm9ydCgpO1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHMpIHtcbiAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRyaWdnZXIpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSOiBJbnZlcnRLZXlWYWx1ZTxcbiAgdHlwZW9mIFRSUENfRVJST1JfQ09ERVNfQllfS0VZXG4+IiwicmV0cnlhYmxlUnBjQ29kZXM6IFRSUENfRVJST1JfQ09ERV9OVU1CRVJbXSIsIm9iajE6IFRUeXBlIiwibmV3T2JqOiBUVHlwZSIsInZhbHVlOiB1bmtub3duIiwiZm46IHVua25vd24iLCJvYmo6IFRPYmoiLCJmbjogKCkgPT4gVFZhbHVlIiwiaXQ6IFQiLCJjb25kaXRpb246IGJvb2xlYW4iLCJzaWduYWxzOiBBYm9ydFNpZ25hbFtdIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTP_CODE_TO_JSONRPC2: () => (/* binding */ HTTP_CODE_TO_JSONRPC2),\n/* harmony export */   JSONRPC2_TO_HTTP_CODE: () => (/* binding */ JSONRPC2_TO_HTTP_CODE),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM),\n/* harmony export */   createFlatProxy: () => (/* binding */ createFlatProxy),\n/* harmony export */   createRecursiveProxy: () => (/* binding */ createRecursiveProxy),\n/* harmony export */   getErrorShape: () => (/* binding */ getErrorShape),\n/* harmony export */   getHTTPStatusCode: () => (/* binding */ getHTTPStatusCode),\n/* harmony export */   getHTTPStatusCodeFromError: () => (/* binding */ getHTTPStatusCodeFromError),\n/* harmony export */   getStatusCodeFromKey: () => (/* binding */ getStatusCodeFromKey),\n/* harmony export */   getStatusKeyFromCode: () => (/* binding */ getStatusKeyFromCode),\n/* harmony export */   require_defineProperty: () => (/* binding */ require_defineProperty),\n/* harmony export */   require_objectSpread2: () => (/* binding */ require_objectSpread2)\n/* harmony export */ });\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") for(var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++){\n        key = keys[i];\n        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ((k)=>from[k]).bind(null, key),\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n//#endregion\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = ()=>{};\nconst freezeIfAvailable = (obj)=>{\n    if (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n    var _memo$cacheKey;\n    const cacheKey = path.join(\".\");\n    (_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== \"string\" || key === \"then\") return void 0;\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ], memo);\n        },\n        apply (_1, _2, args) {\n            const lastOfPath = path[path.length - 1];\n            let opts = {\n                args,\n                path\n            };\n            if (lastOfPath === \"call\") opts = {\n                args: args.length >= 2 ? [\n                    args[1]\n                ] : [],\n                path: path.slice(0, -1)\n            };\n            else if (lastOfPath === \"apply\") opts = {\n                args: args.length >= 2 ? args[1] : [],\n                path: path.slice(0, -1)\n            };\n            freezeIfAvailable(opts.args);\n            freezeIfAvailable(opts.path);\n            return callback(opts);\n        }\n    }));\n    return memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/ const createRecursiveProxy = (callback)=>createInnerProxy(callback, [], Object.create(null));\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (name === \"then\") return void 0;\n            return callback(name);\n        }\n    });\n};\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    UNAUTHORIZED: 401,\n    PAYMENT_REQUIRED: 402,\n    FORBIDDEN: 403,\n    NOT_FOUND: 404,\n    METHOD_NOT_SUPPORTED: 405,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    UNSUPPORTED_MEDIA_TYPE: 415,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429,\n    CLIENT_CLOSED_REQUEST: 499,\n    INTERNAL_SERVER_ERROR: 500,\n    NOT_IMPLEMENTED: 501,\n    BAD_GATEWAY: 502,\n    SERVICE_UNAVAILABLE: 503,\n    GATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n    400: \"BAD_REQUEST\",\n    401: \"UNAUTHORIZED\",\n    402: \"PAYMENT_REQUIRED\",\n    403: \"FORBIDDEN\",\n    404: \"NOT_FOUND\",\n    405: \"METHOD_NOT_SUPPORTED\",\n    408: \"TIMEOUT\",\n    409: \"CONFLICT\",\n    412: \"PRECONDITION_FAILED\",\n    413: \"PAYLOAD_TOO_LARGE\",\n    415: \"UNSUPPORTED_MEDIA_TYPE\",\n    422: \"UNPROCESSABLE_CONTENT\",\n    429: \"TOO_MANY_REQUESTS\",\n    499: \"CLIENT_CLOSED_REQUEST\",\n    500: \"INTERNAL_SERVER_ERROR\",\n    501: \"NOT_IMPLEMENTED\",\n    502: \"BAD_GATEWAY\",\n    503: \"SERVICE_UNAVAILABLE\",\n    504: \"GATEWAY_TIMEOUT\"\n};\nfunction getStatusCodeFromKey(code) {\n    var _JSONRPC2_TO_HTTP_COD;\n    return (_JSONRPC2_TO_HTTP_COD = JSONRPC2_TO_HTTP_CODE[code]) !== null && _JSONRPC2_TO_HTTP_COD !== void 0 ? _JSONRPC2_TO_HTTP_COD : 500;\n}\nfunction getStatusKeyFromCode(code) {\n    var _HTTP_CODE_TO_JSONRPC;\n    return (_HTTP_CODE_TO_JSONRPC = HTTP_CODE_TO_JSONRPC2[code]) !== null && _HTTP_CODE_TO_JSONRPC !== void 0 ? _HTTP_CODE_TO_JSONRPC : \"INTERNAL_SERVER_ERROR\";\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if (\"error\" in res && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(res.error.data)) {\n            var _res$error$data;\n            if (typeof ((_res$error$data = res.error.data) === null || _res$error$data === void 0 ? void 0 : _res$error$data[\"httpStatus\"]) === \"number\") return res.error.data[\"httpStatus\"];\n            const code = _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) return 207;\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    return getStatusCodeFromKey(error.code);\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\nvar require_typeof = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\" (exports, module) {\n        function _typeof$2(o) {\n            \"@babel/helpers - typeof\";\n            return module.exports = _typeof$2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n                return typeof o$1;\n            } : function(o$1) {\n                return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n            }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof$2(o);\n        }\n        module.exports = _typeof$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\nvar require_toPrimitive = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\" (exports, module) {\n        var _typeof$1 = require_typeof()[\"default\"];\n        function toPrimitive$1(t, r) {\n            if (\"object\" != _typeof$1(t) || !t) return t;\n            var e = t[Symbol.toPrimitive];\n            if (void 0 !== e) {\n                var i = e.call(t, r || \"default\");\n                if (\"object\" != _typeof$1(i)) return i;\n                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            return (\"string\" === r ? String : Number)(t);\n        }\n        module.exports = toPrimitive$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\nvar require_toPropertyKey = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\" (exports, module) {\n        var _typeof = require_typeof()[\"default\"];\n        var toPrimitive = require_toPrimitive();\n        function toPropertyKey$1(t) {\n            var i = toPrimitive(t, \"string\");\n            return \"symbol\" == _typeof(i) ? i : i + \"\";\n        }\n        module.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\nvar require_defineProperty = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\" (exports, module) {\n        var toPropertyKey = require_toPropertyKey();\n        function _defineProperty(e, r, t) {\n            return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n                value: t,\n                enumerable: !0,\n                configurable: !0,\n                writable: !0\n            }) : e[r] = t, e;\n        }\n        module.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\nvar require_objectSpread2 = __commonJS({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\" (exports, module) {\n        var defineProperty = require_defineProperty();\n        function ownKeys(e, r) {\n            var t = Object.keys(e);\n            if (Object.getOwnPropertySymbols) {\n                var o = Object.getOwnPropertySymbols(e);\n                r && (o = o.filter(function(r$1) {\n                    return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n                })), t.push.apply(t, o);\n            }\n            return t;\n        }\n        function _objectSpread2(e) {\n            for(var r = 1; r < arguments.length; r++){\n                var t = null != arguments[r] ? arguments[r] : {};\n                r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n                    defineProperty(e, r$1, t[r$1]);\n                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n                    Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n                });\n            }\n            return e;\n        }\n        module.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* @internal\n*/ function getErrorShape(opts) {\n    const { path, error, config } = opts;\n    const { code } = opts.error;\n    const shape = {\n        message: error.message,\n        code: _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_KEY[code],\n        data: {\n            code,\n            httpStatus: getHTTPStatusCodeFromError(error)\n        }\n    };\n    if (config.isDev && typeof opts.error.stack === \"string\") shape.data.stack = opts.error.stack;\n    if (typeof path === \"string\") shape.data.path = path;\n    return config.errorFormatter((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, {\n        shape\n    }));\n}\n//#endregion\n //# sourceMappingURL=getErrorShape-Uhlrl4Bk.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvZ2V0RXJyb3JTaGFwZS1VaGxybDRCay5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1BLE1BQU0sT0FBTyxLQUVaLENBRmtCO0FBSW5CLE1BQU0sb0JBQW9CLENBQUNBO0lBQ3pCLElBQUksT0FBTyxPQUNULFFBQU8sT0FBTyxJQUFJO0FBRXJCO0FBRUQsU0FBUyxpQkFDUEMsUUFBQUEsRUFDQUMsSUFBQUEsRUFDQUMsSUFBQUEsRUFDQTs7SUFDQSxNQUFNLFdBQVcsS0FBSyxLQUFLLElBQUk7SUFFL0IsdUJBQUsscURBQUwsS0FBSyxZQUFjLElBQUksTUFBTSxNQUFNO1FBQ2pDLEtBQUksTUFBTSxLQUFLO1lBQ2IsV0FBVyxRQUFRLFlBQVksUUFBUSxPQUdyQztZQUVGLE9BQU8saUJBQWlCLFVBQVUsQ0FBQzttQkFBRztnQkFBTSxHQUFJO2FBQUEsRUFBRSxLQUFLO1FBQ3hEO1FBQ0QsT0FBTSxJQUFJLElBQUksTUFBTTtZQUNsQixNQUFNLGFBQWEsS0FBSyxLQUFLLFNBQVM7WUFFdEMsSUFBSSxPQUFPO2dCQUFFO2dCQUFNO1lBQU07WUFFekIsSUFBSSxlQUFlLE9BQ2pCLFFBQU87Z0JBQ0wsTUFBTSxLQUFLLFVBQVUsSUFBSTtvQkFBQyxLQUFLLEVBQUc7aUJBQUEsR0FBRyxDQUFFO2dCQUN2QyxNQUFNLEtBQUssTUFBTSxHQUFHLEdBQUc7WUFDeEI7cUJBQ1EsZUFBZSxRQUN4QixRQUFPO2dCQUNMLE1BQU0sS0FBSyxVQUFVLElBQUksS0FBSyxLQUFLLENBQUU7Z0JBQ3JDLE1BQU0sS0FBSyxNQUFNLEdBQUcsR0FBRztZQUN4QjtZQUVILGtCQUFrQixLQUFLLEtBQUs7WUFDNUIsa0JBQWtCLEtBQUssS0FBSztZ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QUNqRCIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2NyZWF0ZVByb3h5LnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvZ2V0SFRUUFN0YXR1c0NvZGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3R5cGVvZi5qcyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9QcmltaXRpdmUuanMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL2dldEVycm9yU2hhcGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIFByb3h5Q2FsbGJhY2tPcHRpb25zIHtcbiAgcGF0aDogcmVhZG9ubHkgc3RyaW5nW107XG4gIGFyZ3M6IHJlYWRvbmx5IHVua25vd25bXTtcbn1cbnR5cGUgUHJveHlDYWxsYmFjayA9IChvcHRzOiBQcm94eUNhbGxiYWNrT3B0aW9ucykgPT4gdW5rbm93bjtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHtcbiAgLy8gbm9vcFxufTtcblxuY29uc3QgZnJlZXplSWZBdmFpbGFibGUgPSAob2JqOiBvYmplY3QpID0+IHtcbiAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyUHJveHkoXG4gIGNhbGxiYWNrOiBQcm94eUNhbGxiYWNrLFxuICBwYXRoOiByZWFkb25seSBzdHJpbmdbXSxcbiAgbWVtbzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4pIHtcbiAgY29uc3QgY2FjaGVLZXkgPSBwYXRoLmpvaW4oJy4nKTtcblxuICBtZW1vW2NhY2hlS2V5XSA/Pz0gbmV3IFByb3h5KG5vb3AsIHtcbiAgICBnZXQoX29iaiwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwga2V5ID09PSAndGhlbicpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpZiB0aGUgcHJveHkgaXMgYWNjaWRlbnRhbGx5IHRyZWF0ZWRcbiAgICAgICAgLy8gbGlrZSBhIFByb21pc2VMaWtlIChsaWtlIGluIGBQcm9taXNlLnJlc29sdmUocHJveHkpYClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBbLi4ucGF0aCwga2V5XSwgbWVtbyk7XG4gICAgfSxcbiAgICBhcHBseShfMSwgXzIsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IGxhc3RPZlBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgIGxldCBvcHRzID0geyBhcmdzLCBwYXRoIH07XG4gICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciBlLmcuIGB0cnBjLmhlbGxvLmNhbGwodGhpcywgJ3RoZXJlJylgIGFuZCBgdHJwYy5oZWxsby5hcHBseSh0aGlzLCBbJ3RoZXJlJ10pXG4gICAgICBpZiAobGFzdE9mUGF0aCA9PT0gJ2NhbGwnKSB7XG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgYXJnczogYXJncy5sZW5ndGggPj0gMiA/IFthcmdzWzFdXSA6IFtdLFxuICAgICAgICAgIHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChsYXN0T2ZQYXRoID09PSAnYXBwbHknKSB7XG4gICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgYXJnczogYXJncy5sZW5ndGggPj0gMiA/IGFyZ3NbMV0gOiBbXSxcbiAgICAgICAgICBwYXRoOiBwYXRoLnNsaWNlKDAsIC0xKSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyZWV6ZUlmQXZhaWxhYmxlKG9wdHMuYXJncyk7XG4gICAgICBmcmVlemVJZkF2YWlsYWJsZShvcHRzLnBhdGgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG9wdHMpO1xuICAgIH0sXG4gIH0pO1xuXG4gIHJldHVybiBtZW1vW2NhY2hlS2V5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgdGhhdCBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcGF0aCBhbmQgYXJndW1lbnRzXG4gKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZWN1cnNpdmVQcm94eSA9IDxURmF1eCA9IHVua25vd24+KFxuICBjYWxsYmFjazogUHJveHlDYWxsYmFjayxcbik6IFRGYXV4ID0+IGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFtdLCBPYmplY3QuY3JlYXRlKG51bGwpKSBhcyBURmF1eDtcblxuLyoqXG4gKiBVc2VkIGluIHBsYWNlIG9mIGBuZXcgUHJveHlgIHdoZXJlIGVhY2ggaGFuZGxlciB3aWxsIG1hcCAxIGxldmVsIGRlZXAgdG8gYW5vdGhlciB2YWx1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUZsYXRQcm94eSA9IDxURmF1eD4oXG4gIGNhbGxiYWNrOiAocGF0aDoga2V5b2YgVEZhdXgpID0+IGFueSxcbik6IFRGYXV4ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm94eShub29wLCB7XG4gICAgZ2V0KF9vYmosIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lID09PSAndGhlbicpIHtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIGZvciBpZiB0aGUgcHJveHkgaXMgYWNjaWRlbnRhbGx5IHRyZWF0ZWRcbiAgICAgICAgLy8gbGlrZSBhIFByb21pc2VMaWtlIChsaWtlIGluIGBQcm9taXNlLnJlc29sdmUocHJveHkpYClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYWxsYmFjayhuYW1lIGFzIGFueSk7XG4gICAgfSxcbiAgfSkgYXMgVEZhdXg7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUUlBDRXJyb3IgfSBmcm9tICcuLi9lcnJvci9UUlBDRXJyb3InO1xuaW1wb3J0IHR5cGUgeyBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSwgVFJQQ1Jlc3BvbnNlIH0gZnJvbSAnLi4vcnBjJztcbmltcG9ydCB7IFRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSIH0gZnJvbSAnLi4vcnBjJztcbmltcG9ydCB0eXBlIHsgSW52ZXJ0S2V5VmFsdWUsIFZhbHVlT2YgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IEpTT05SUEMyX1RPX0hUVFBfQ09ERTogUmVjb3JkPFxuICBrZXlvZiB0eXBlb2YgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVksXG4gIG51bWJlclxuPiA9IHtcbiAgUEFSU0VfRVJST1I6IDQwMCxcbiAgQkFEX1JFUVVFU1Q6IDQwMCxcbiAgVU5BVVRIT1JJWkVEOiA0MDEsXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IDQwMixcbiAgRk9SQklEREVOOiA0MDMsXG4gIE5PVF9GT1VORDogNDA0LFxuICBNRVRIT0RfTk9UX1NVUFBPUlRFRDogNDA1LFxuICBUSU1FT1VUOiA0MDgsXG4gIENPTkZMSUNUOiA0MDksXG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IDQxMixcbiAgUEFZTE9BRF9UT09fTEFSR0U6IDQxMyxcbiAgVU5TVVBQT1JURURfTUVESUFfVFlQRTogNDE1LFxuICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IDQyMixcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgQ0xJRU5UX0NMT1NFRF9SRVFVRVNUOiA0OTksXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogNTAwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDUwMSxcbiAgQkFEX0dBVEVXQVk6IDUwMixcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogNTAzLFxuICBHQVRFV0FZX1RJTUVPVVQ6IDUwNCxcbn07XG5cbmV4cG9ydCBjb25zdCBIVFRQX0NPREVfVE9fSlNPTlJQQzI6IEludmVydEtleVZhbHVlPFxuICB0eXBlb2YgSlNPTlJQQzJfVE9fSFRUUF9DT0RFXG4+ID0ge1xuICA0MDA6ICdCQURfUkVRVUVTVCcsXG4gIDQwMTogJ1VOQVVUSE9SSVpFRCcsXG4gIDQwMjogJ1BBWU1FTlRfUkVRVUlSRUQnLFxuICA0MDM6ICdGT1JCSURERU4nLFxuICA0MDQ6ICdOT1RfRk9VTkQnLFxuICA0MDU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gIDQwODogJ1RJTUVPVVQnLFxuICA0MDk6ICdDT05GTElDVCcsXG4gIDQxMjogJ1BSRUNPTkRJVElPTl9GQUlMRUQnLFxuICA0MTM6ICdQQVlMT0FEX1RPT19MQVJHRScsXG4gIDQxNTogJ1VOU1VQUE9SVEVEX01FRElBX1RZUEUnLFxuICA0MjI6ICdVTlBST0NFU1NBQkxFX0NPTlRFTlQnLFxuICA0Mjk6ICdUT09fTUFOWV9SRVFVRVNUUycsXG4gIDQ5OTogJ0NMSUVOVF9DTE9TRURfUkVRVUVTVCcsXG4gIDUwMDogJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUicsXG4gIDUwMTogJ05PVF9JTVBMRU1FTlRFRCcsXG4gIDUwMjogJ0JBRF9HQVRFV0FZJyxcbiAgNTAzOiAnU0VSVklDRV9VTkFWQUlMQUJMRScsXG4gIDUwNDogJ0dBVEVXQVlfVElNRU9VVCcsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUZyb21LZXkoXG4gIGNvZGU6IGtleW9mIHR5cGVvZiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSxcbikge1xuICByZXR1cm4gSlNPTlJQQzJfVE9fSFRUUF9DT0RFW2NvZGVdID8/IDUwMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXR1c0tleUZyb21Db2RlKFxuICBjb2RlOiBrZXlvZiB0eXBlb2YgSFRUUF9DT0RFX1RPX0pTT05SUEMyLFxuKTogVmFsdWVPZjx0eXBlb2YgSFRUUF9DT0RFX1RPX0pTT05SUEMyPiB7XG4gIHJldHVybiBIVFRQX0NPREVfVE9fSlNPTlJQQzJbY29kZV0gPz8gJ0lOVEVSTkFMX1NFUlZFUl9FUlJPUic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZShqc29uOiBUUlBDUmVzcG9uc2UgfCBUUlBDUmVzcG9uc2VbXSkge1xuICBjb25zdCBhcnIgPSBBcnJheS5pc0FycmF5KGpzb24pID8ganNvbiA6IFtqc29uXTtcbiAgY29uc3QgaHR0cFN0YXR1c2VzID0gbmV3IFNldDxudW1iZXI+KFxuICAgIGFyci5tYXAoKHJlcykgPT4ge1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzICYmIGlzT2JqZWN0KHJlcy5lcnJvci5kYXRhKSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcy5lcnJvci5kYXRhPy5bJ2h0dHBTdGF0dXMnXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gcmVzLmVycm9yLmRhdGFbJ2h0dHBTdGF0dXMnXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVJbcmVzLmVycm9yLmNvZGVdO1xuICAgICAgICByZXR1cm4gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMjAwO1xuICAgIH0pLFxuICApO1xuXG4gIGlmIChodHRwU3RhdHVzZXMuc2l6ZSAhPT0gMSkge1xuICAgIHJldHVybiAyMDc7XG4gIH1cblxuICBjb25zdCBodHRwU3RhdHVzID0gaHR0cFN0YXR1c2VzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICByZXR1cm4gaHR0cFN0YXR1cyE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcjogVFJQQ0Vycm9yKSB7XG4gIHJldHVybiBnZXRTdGF0dXNDb2RlRnJvbUtleShlcnJvci5jb2RlKTtcbn1cbiIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mKG8pO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi90eXBlb2YuanNcIilbXCJkZWZhdWx0XCJdO1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gdG9QcmltaXRpdmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKFwiLi90b1ByaW1pdGl2ZS5qc1wiKTtcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIHRvUHJvcGVydHlLZXkgPSByZXF1aXJlKFwiLi90b1Byb3BlcnR5S2V5LmpzXCIpO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4vZGVmaW5lUHJvcGVydHkuanNcIik7XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHsgZ2V0SFRUUFN0YXR1c0NvZGVGcm9tRXJyb3IgfSBmcm9tICcuLi9odHRwL2dldEhUVFBTdGF0dXNDb2RlJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlVHlwZSB9IGZyb20gJy4uL3Byb2NlZHVyZSc7XG5pbXBvcnQgdHlwZSB7IEFueVJvb3RUeXBlcywgUm9vdENvbmZpZyB9IGZyb20gJy4uL3Jvb3RDb25maWcnO1xuaW1wb3J0IHsgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVkgfSBmcm9tICcuLi9ycGMnO1xuaW1wb3J0IHR5cGUgeyBEZWZhdWx0RXJyb3JTaGFwZSB9IGZyb20gJy4vZm9ybWF0dGVyJztcbmltcG9ydCB0eXBlIHsgVFJQQ0Vycm9yIH0gZnJvbSAnLi9UUlBDRXJyb3InO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JTaGFwZTxUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcz4ob3B0czoge1xuICBjb25maWc6IFJvb3RDb25maWc8VFJvb3Q+O1xuICBlcnJvcjogVFJQQ0Vycm9yO1xuICB0eXBlOiBQcm9jZWR1cmVUeXBlIHwgJ3Vua25vd24nO1xuICBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGlucHV0OiB1bmtub3duO1xuICBjdHg6IFRSb290WydjdHgnXSB8IHVuZGVmaW5lZDtcbn0pOiBUUm9vdFsnZXJyb3JTaGFwZSddIHtcbiAgY29uc3QgeyBwYXRoLCBlcnJvciwgY29uZmlnIH0gPSBvcHRzO1xuICBjb25zdCB7IGNvZGUgfSA9IG9wdHMuZXJyb3I7XG4gIGNvbnN0IHNoYXBlOiBEZWZhdWx0RXJyb3JTaGFwZSA9IHtcbiAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgIGNvZGU6IFRSUENfRVJST1JfQ09ERVNfQllfS0VZW2NvZGVdLFxuICAgIGRhdGE6IHtcbiAgICAgIGNvZGUsXG4gICAgICBodHRwU3RhdHVzOiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvciksXG4gICAgfSxcbiAgfTtcbiAgaWYgKGNvbmZpZy5pc0RldiAmJiB0eXBlb2Ygb3B0cy5lcnJvci5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICBzaGFwZS5kYXRhLnN0YWNrID0gb3B0cy5lcnJvci5zdGFjaztcbiAgfVxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgc2hhcGUuZGF0YS5wYXRoID0gcGF0aDtcbiAgfVxuICByZXR1cm4gY29uZmlnLmVycm9yRm9ybWF0dGVyKHsgLi4ub3B0cywgc2hhcGUgfSk7XG59XG4iXSwibmFtZXMiOlsib2JqOiBvYmplY3QiLCJjYWxsYmFjazogUHJveHlDYWxsYmFjayIsInBhdGg6IHJlYWRvbmx5IHN0cmluZ1tdIiwibWVtbzogUmVjb3JkPHN0cmluZywgdW5rbm93bj4iLCJjYWxsYmFjazogKHBhdGg6IGtleW9mIFRGYXV4KSA9PiBhbnkiLCJKU09OUlBDMl9UT19IVFRQX0NPREU6IFJlY29yZDxcbiAga2V5b2YgdHlwZW9mIFRSUENfRVJST1JfQ09ERVNfQllfS0VZLFxuICBudW1iZXJcbj4iLCJIVFRQX0NPREVfVE9fSlNPTlJQQzI6IEludmVydEtleVZhbHVlPFxuICB0eXBlb2YgSlNPTlJQQzJfVE9fSFRUUF9DT0RFXG4+IiwiY29kZToga2V5b2YgdHlwZW9mIFRSUENfRVJST1JfQ09ERVNfQllfS0VZIiwiY29kZToga2V5b2YgdHlwZW9mIEhUVFBfQ09ERV9UT19KU09OUlBDMiIsImpzb246IFRSUENSZXNwb25zZSB8IFRSUENSZXNwb25zZVtdIiwiZXJyb3I6IFRSUENFcnJvciIsIl90eXBlb2YiLCJvIiwidG9QcmltaXRpdmUiLCJ0b1Byb3BlcnR5S2V5IiwiciIsIm9wdHM6IHtcbiAgY29uZmlnOiBSb290Q29uZmlnPFRSb290PjtcbiAgZXJyb3I6IFRSUENFcnJvcjtcbiAgdHlwZTogUHJvY2VkdXJlVHlwZSB8ICd1bmtub3duJztcbiAgcGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBpbnB1dDogdW5rbm93bjtcbiAgY3R4OiBUUm9vdFsnY3R4J10gfCB1bmRlZmluZWQ7XG59Iiwic2hhcGU6IERlZmF1bHRFcnJvclNoYXBlIl0sImlnbm9yZUxpc3QiOlsyLDMsNCw1LDZdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   behaviorSubject: () => (/* binding */ behaviorSubject),\n/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged),\n/* harmony export */   distinctUntilDeepChanged: () => (/* binding */ distinctUntilDeepChanged),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   share: () => (/* binding */ share),\n/* harmony export */   tap: () => (/* binding */ tap)\n/* harmony export */ });\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\");\n\n//#region src/observable/operators.ts\nfunction map(project) {\n    return (source)=>{\n        return (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination)=>{\n            let index = 0;\n            const subscription = source.subscribe({\n                next (value) {\n                    destination.next(project(value, index++));\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n            return subscription;\n        });\n    };\n}\nfunction share(_opts) {\n    return (source)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) return;\n            subscription = source.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        var _observer$next;\n                        (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        var _observer$error;\n                        (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        var _observer$complete;\n                        (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((subscriber)=>{\n            refCount++;\n            observers.push(subscriber);\n            startIfNeeded();\n            return {\n                unsubscribe () {\n                    refCount--;\n                    resetIfNeeded();\n                    const index = observers.findIndex((v)=>v === subscriber);\n                    if (index > -1) observers.splice(index, 1);\n                }\n            };\n        });\n    };\n}\nfunction tap(observer) {\n    return (source)=>{\n        return (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination)=>{\n            return source.subscribe({\n                next (value) {\n                    var _observer$next2;\n                    (_observer$next2 = observer.next) === null || _observer$next2 === void 0 || _observer$next2.call(observer, value);\n                    destination.next(value);\n                },\n                error (error) {\n                    var _observer$error2;\n                    (_observer$error2 = observer.error) === null || _observer$error2 === void 0 || _observer$error2.call(observer, error);\n                    destination.error(error);\n                },\n                complete () {\n                    var _observer$complete2;\n                    (_observer$complete2 = observer.complete) === null || _observer$complete2 === void 0 || _observer$complete2.call(observer);\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b)=>a === b) {\n    return (source)=>{\n        return (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination)=>{\n            let lastValue = distinctUnsetMarker;\n            return source.subscribe({\n                next (value) {\n                    if (lastValue !== distinctUnsetMarker && compare(lastValue, value)) return;\n                    lastValue = value;\n                    destination.next(value);\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\nconst isDeepEqual = (a, b)=>{\n    if (a === b) return true;\n    const bothAreObjects = a && b && typeof a === \"object\" && typeof b === \"object\";\n    return !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v])=>isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n    return distinctUntilChanged(isDeepEqual);\n}\n//#endregion\n//#region src/observable/behaviorSubject.ts\n/**\n* @internal\n* An observable that maintains and provides a \"current value\" to subscribers\n* @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n*/ function behaviorSubject(initialValue) {\n    let value = initialValue;\n    const observerList = [];\n    const addObserver = (observer)=>{\n        if (value !== void 0) observer.next(value);\n        observerList.push(observer);\n    };\n    const removeObserver = (observer)=>{\n        observerList.splice(observerList.indexOf(observer), 1);\n    };\n    const obs = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((observer)=>{\n        addObserver(observer);\n        return ()=>{\n            removeObserver(observer);\n        };\n    });\n    obs.next = (nextValue)=>{\n        if (value === nextValue) return;\n        value = nextValue;\n        for (const observer of observerList)observer.next(nextValue);\n    };\n    obs.get = ()=>value;\n    return obs;\n}\n//#endregion\n //# sourceMappingURL=observable-CUiPknO-.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3Qvb2JzZXJ2YWJsZS1DVWlQa25PLS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBUUEsU0FBZ0IsSUFDZEEsT0FBQUEsRUFDNkQ7SUFDN0QsT0FBTyxDQUFDO1FBQ04sT0FBTyxtRUFBVSxDQUFDLENBQUM7WUFDakIsSUFBSSxRQUFRO1lBQ1osTUFBTSxlQUFlLE9BQU8sVUFBVTtnQkFDcEMsTUFBSyxPQUFPO29CQUNWLFlBQVksS0FBSyxRQUFRLE9BQU8sUUFBUSxDQUFDO2dCQUMxQztnQkFDRCxPQUFNLE9BQU87b0JBQ1gsWUFBWSxNQUFNLE1BQU07Z0JBQ3pCO2dCQUNELFdBQVc7b0JBQ1QsWUFBWSxVQUFVO2dCQUN2QjtZQUNGLEVBQUM7WUFDRixPQUFPO1FBQ1IsRUFBQztJQUNIO0FBQ0Y7QUFHRCxTQUFnQixNQUNkQyxLQUFBQSxFQUMwQztJQUMxQyxPQUFPLENBQUM7UUFDTixJQUFJLFdBQVc7UUFFZixJQUFJQyxlQUFzQztRQUMxQyxNQUFNQyxZQUFpRCxDQUFFO1FBRXpELFNBQVMsZ0JBQWdCO1lBQ3ZCLElBQUksYUFDRjtZQUVGLGVBQWUsT0FBTyxVQUFVO2dCQUM5QixNQUFLLE9BQU87b0JBQ1YsS0FBSyxNQUFNLFlBQVksVUFBVzs7d0JBQ2hDLDJCQUFTLCtDQUFULDhCQUFnQixNQUFNO29CQUN2QjtnQkFDRjtnQkFDRCxPQUFNLE9BQU87b0JBQ1gsS0FBSyxNQUFNLFlBQVksVUFBVzs7d0JBQ2hDLDRCQUFTLGlEQUFULCtCQUFpQixNQUFNO29CQUN4QjtnQkFDRjtnQkFDRCxXQUFXO29CQUNULEtBQUssTUFBTSxZQUFZLFVBQVc7O3dCQUNoQywrQkFBUyx1REFBVCxpQ0FBcUI7b0JBQ3RCO2dCQUNGO1lBQ0YsRUFBQztRQUNIO1FBQ0QsU0FBUyxnQkFBZ0I7WUFF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cm1hcHAvYXBwcy9zcmMvb2JzZXJ2YWJsZS9vcGVyYXRvcnMudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy9vYnNlcnZhYmxlL2JlaGF2aW9yU3ViamVjdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvYnNlcnZhYmxlIH0gZnJvbSAnLi9vYnNlcnZhYmxlJztcbmltcG9ydCB0eXBlIHtcbiAgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uLFxuICBPYnNlcnZlcixcbiAgT3BlcmF0b3JGdW5jdGlvbixcbiAgVW5zdWJzY3JpYmFibGUsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbWFwPFRWYWx1ZUJlZm9yZSwgVEVycm9yLCBUVmFsdWVBZnRlcj4oXG4gIHByb2plY3Q6ICh2YWx1ZTogVFZhbHVlQmVmb3JlLCBpbmRleDogbnVtYmVyKSA9PiBUVmFsdWVBZnRlcixcbik6IE9wZXJhdG9yRnVuY3Rpb248VFZhbHVlQmVmb3JlLCBURXJyb3IsIFRWYWx1ZUFmdGVyLCBURXJyb3I+IHtcbiAgcmV0dXJuIChzb3VyY2UpID0+IHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZSgoZGVzdGluYXRpb24pID0+IHtcbiAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihlcnJvcikge1xuICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9KTtcbiAgfTtcbn1cblxuaW50ZXJmYWNlIFNoYXJlQ29uZmlnIHt9XG5leHBvcnQgZnVuY3Rpb24gc2hhcmU8VFZhbHVlLCBURXJyb3I+KFxuICBfb3B0cz86IFNoYXJlQ29uZmlnLFxuKTogTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPFRWYWx1ZSwgVEVycm9yPiB7XG4gIHJldHVybiAoc291cmNlKSA9PiB7XG4gICAgbGV0IHJlZkNvdW50ID0gMDtcblxuICAgIGxldCBzdWJzY3JpcHRpb246IFVuc3Vic2NyaWJhYmxlIHwgbnVsbCA9IG51bGw7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzOiBQYXJ0aWFsPE9ic2VydmVyPFRWYWx1ZSwgVEVycm9yPj5bXSA9IFtdO1xuXG4gICAgZnVuY3Rpb24gc3RhcnRJZk5lZWRlZCgpIHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4oZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlPy4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRJZk5lZWRlZCgpIHtcbiAgICAgIC8vIFwicmVzZXRPblJlZkNvdW50WmVyb1wiXG4gICAgICBpZiAocmVmQ291bnQgPT09IDAgJiYgc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IF9zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIF9zdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb2JzZXJ2YWJsZSgoc3Vic2NyaWJlcikgPT4ge1xuICAgICAgcmVmQ291bnQrKztcblxuICAgICAgb2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICBzdGFydElmTmVlZGVkKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgICByZWZDb3VudC0tO1xuICAgICAgICAgIHJlc2V0SWZOZWVkZWQoKTtcblxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gb2JzZXJ2ZXJzLmZpbmRJbmRleCgodikgPT4gdiA9PT0gc3Vic2NyaWJlcik7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcDxUVmFsdWUsIFRFcnJvcj4oXG4gIG9ic2VydmVyOiBQYXJ0aWFsPE9ic2VydmVyPFRWYWx1ZSwgVEVycm9yPj4sXG4pOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VFZhbHVlLCBURXJyb3I+IHtcbiAgcmV0dXJuIChzb3VyY2UpID0+IHtcbiAgICByZXR1cm4gb2JzZXJ2YWJsZSgoZGVzdGluYXRpb24pID0+IHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIG9ic2VydmVyLm5leHQ/Lih2YWx1ZSk7XG4gICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3I/LihlcnJvcik7XG4gICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZT8uKCk7XG4gICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBkaXN0aW5jdFVuc2V0TWFya2VyID0gU3ltYm9sKCk7XG5leHBvcnQgZnVuY3Rpb24gZGlzdGluY3RVbnRpbENoYW5nZWQ8VFZhbHVlLCBURXJyb3I+KFxuICBjb21wYXJlOiAoYTogVFZhbHVlLCBiOiBUVmFsdWUpID0+IGJvb2xlYW4gPSAoYSwgYikgPT4gYSA9PT0gYixcbik6IE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxUVmFsdWUsIFRFcnJvcj4ge1xuICByZXR1cm4gKHNvdXJjZSkgPT4ge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKChkZXN0aW5hdGlvbikgPT4ge1xuICAgICAgbGV0IGxhc3RWYWx1ZTogVFZhbHVlIHwgdHlwZW9mIGRpc3RpbmN0VW5zZXRNYXJrZXIgPSBkaXN0aW5jdFVuc2V0TWFya2VyO1xuXG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgICBpZiAobGFzdFZhbHVlICE9PSBkaXN0aW5jdFVuc2V0TWFya2VyICYmIGNvbXBhcmUobGFzdFZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGVycm9yKSB7XG4gICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG5cbmNvbnN0IGlzRGVlcEVxdWFsID0gPFQ+KGE6IFQsIGI6IFQpOiBib29sZWFuID0+IHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBib3RoQXJlT2JqZWN0cyA9XG4gICAgYSAmJiBiICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PT0gJ29iamVjdCc7XG5cbiAgcmV0dXJuIChcbiAgICAhIWJvdGhBcmVPYmplY3RzICYmXG4gICAgT2JqZWN0LmtleXMoYSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyhiKS5sZW5ndGggJiZcbiAgICBPYmplY3QuZW50cmllcyhhKS5ldmVyeSgoW2ssIHZdKSA9PiBpc0RlZXBFcXVhbCh2LCBiW2sgYXMga2V5b2YgVF0pKVxuICApO1xufTtcbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsRGVlcENoYW5nZWQ8XG4gIFRWYWx1ZSxcbiAgVEVycm9yLFxuPigpOiBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248VFZhbHVlLCBURXJyb3I+IHtcbiAgcmV0dXJuIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGlzRGVlcEVxdWFsKTtcbn1cbiIsImltcG9ydCB7IG9ic2VydmFibGUgfSBmcm9tICcuL29ic2VydmFibGUnO1xuaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJlaGF2aW9yU3ViamVjdDxUVmFsdWU+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUVmFsdWUsIG5ldmVyPiB7XG4gIG9ic2VydmFibGU6IE9ic2VydmFibGU8VFZhbHVlLCBuZXZlcj47XG4gIG5leHQ6ICh2YWx1ZTogVFZhbHVlKSA9PiB2b2lkO1xuICBnZXQ6ICgpID0+IFRWYWx1ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWFkb25seUJlaGF2aW9yU3ViamVjdDxUVmFsdWU+XG4gIGV4dGVuZHMgT21pdDxCZWhhdmlvclN1YmplY3Q8VFZhbHVlPiwgJ25leHQnPiB7fVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQW4gb2JzZXJ2YWJsZSB0aGF0IG1haW50YWlucyBhbmQgcHJvdmlkZXMgYSBcImN1cnJlbnQgdmFsdWVcIiB0byBzdWJzY3JpYmVyc1xuICogQHNlZSBodHRwczovL3d3dy5sZWFybnJ4anMuaW8vbGVhcm4tcnhqcy9zdWJqZWN0cy9iZWhhdmlvcnN1YmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJlaGF2aW9yU3ViamVjdDxUVmFsdWU+KFxuICBpbml0aWFsVmFsdWU6IFRWYWx1ZSxcbik6IEJlaGF2aW9yU3ViamVjdDxUVmFsdWU+IHtcbiAgbGV0IHZhbHVlOiBUVmFsdWUgPSBpbml0aWFsVmFsdWU7XG5cbiAgY29uc3Qgb2JzZXJ2ZXJMaXN0OiBPYnNlcnZlcjxUVmFsdWUsIG5ldmVyPltdID0gW107XG5cbiAgY29uc3QgYWRkT2JzZXJ2ZXIgPSAob2JzZXJ2ZXI6IE9ic2VydmVyPFRWYWx1ZSwgbmV2ZXI+KSA9PiB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgIH1cbiAgICBvYnNlcnZlckxpc3QucHVzaChvYnNlcnZlcik7XG4gIH07XG4gIGNvbnN0IHJlbW92ZU9ic2VydmVyID0gKG9ic2VydmVyOiBPYnNlcnZlcjxUVmFsdWUsIG5ldmVyPikgPT4ge1xuICAgIG9ic2VydmVyTGlzdC5zcGxpY2Uob2JzZXJ2ZXJMaXN0LmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcbiAgfTtcblxuICBjb25zdCBvYnMgPSBvYnNlcnZhYmxlPFRWYWx1ZSwgbmV2ZXI+KChvYnNlcnZlcikgPT4ge1xuICAgIGFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpO1xuICAgIH07XG4gIH0pIGFzIEJlaGF2aW9yU3ViamVjdDxUVmFsdWU+O1xuXG4gIG9icy5uZXh0ID0gKG5leHRWYWx1ZTogVFZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBuZXh0VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFsdWUgPSBuZXh0VmFsdWU7XG4gICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlckxpc3QpIHtcbiAgICAgIG9ic2VydmVyLm5leHQobmV4dFZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb2JzLmdldCA9ICgpID0+IHZhbHVlO1xuXG4gIHJldHVybiBvYnM7XG59XG4iXSwibmFtZXMiOlsicHJvamVjdDogKHZhbHVlOiBUVmFsdWVCZWZvcmUsIGluZGV4OiBudW1iZXIpID0+IFRWYWx1ZUFmdGVyIiwiX29wdHM/OiBTaGFyZUNvbmZpZyIsInN1YnNjcmlwdGlvbjogVW5zdWJzY3JpYmFibGUgfCBudWxsIiwib2JzZXJ2ZXJzOiBQYXJ0aWFsPE9ic2VydmVyPFRWYWx1ZSwgVEVycm9yPj5bXSIsIm9ic2VydmVyOiBQYXJ0aWFsPE9ic2VydmVyPFRWYWx1ZSwgVEVycm9yPj4iLCJjb21wYXJlOiAoYTogVFZhbHVlLCBiOiBUVmFsdWUpID0+IGJvb2xlYW4iLCJsYXN0VmFsdWU6IFRWYWx1ZSB8IHR5cGVvZiBkaXN0aW5jdFVuc2V0TWFya2VyIiwiYTogVCIsImI6IFQiLCJpbml0aWFsVmFsdWU6IFRWYWx1ZSIsInZhbHVlOiBUVmFsdWUiLCJvYnNlcnZlckxpc3Q6IE9ic2VydmVyPFRWYWx1ZSwgbmV2ZXI+W10iLCJvYnNlcnZlcjogT2JzZXJ2ZXI8VFZhbHVlLCBuZXZlcj4iLCJuZXh0VmFsdWU6IFRWYWx1ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observableToAsyncIterable: () => (/* binding */ observableToAsyncIterable),\n/* harmony export */   observableToPromise: () => (/* binding */ observableToPromise)\n/* harmony export */ });\n//#region src/observable/observable.ts\n/** @public */ function isObservable(x) {\n    return typeof x === \"object\" && x !== null && \"subscribe\" in x;\n}\n/** @public */ function observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) return;\n                unsubscribed = true;\n                if (typeof teardownRef === \"function\") teardownRef();\n                else if (teardownRef) teardownRef.unsubscribe();\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    var _observer$next;\n                    if (isDone) return;\n                    (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n                },\n                error (err) {\n                    var _observer$error;\n                    if (isDone) return;\n                    isDone = true;\n                    (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err);\n                    unsubscribe();\n                },\n                complete () {\n                    var _observer$complete;\n                    if (isDone) return;\n                    isDone = true;\n                    (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) unsubscribe();\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return operations.reduce(pipeReducer, self);\n        }\n    };\n    return self;\n}\nfunction pipeReducer(prev, fn) {\n    return fn(prev);\n}\n/** @internal */ function observableToPromise(observable$1) {\n    const ac = new AbortController();\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) return;\n            isDone = true;\n            obs$.unsubscribe();\n        }\n        ac.signal.addEventListener(\"abort\", ()=>{\n            reject(ac.signal.reason);\n        });\n        const obs$ = observable$1.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                reject(data);\n            },\n            complete () {\n                ac.abort();\n                onDone();\n            }\n        });\n    });\n    return promise;\n}\n/**\n* @internal\n*/ function observableToReadableStream(observable$1, signal) {\n    let unsub = null;\n    const onAbort = ()=>{\n        unsub === null || unsub === void 0 || unsub.unsubscribe();\n        unsub = null;\n        signal.removeEventListener(\"abort\", onAbort);\n    };\n    return new ReadableStream({\n        start (controller) {\n            unsub = observable$1.subscribe({\n                next (data) {\n                    controller.enqueue({\n                        ok: true,\n                        value: data\n                    });\n                },\n                error (error) {\n                    controller.enqueue({\n                        ok: false,\n                        error\n                    });\n                    controller.close();\n                },\n                complete () {\n                    controller.close();\n                }\n            });\n            if (signal.aborted) onAbort();\n            else signal.addEventListener(\"abort\", onAbort, {\n                once: true\n            });\n        },\n        cancel () {\n            onAbort();\n        }\n    });\n}\n/** @internal */ function observableToAsyncIterable(observable$1, signal) {\n    const stream = observableToReadableStream(observable$1, signal);\n    const reader = stream.getReader();\n    const iterator = {\n        async next () {\n            const value = await reader.read();\n            if (value.done) return {\n                value: void 0,\n                done: true\n            };\n            const { value: result } = value;\n            if (!result.ok) throw result.error;\n            return {\n                value: result.value,\n                done: false\n            };\n        },\n        async return () {\n            await reader.cancel();\n            return {\n                value: void 0,\n                done: true\n            };\n        }\n    };\n    return {\n        [Symbol.asyncIterator] () {\n            return iterator;\n        }\n    };\n}\n//#endregion\n //# sourceMappingURL=observable-UMO3vUa_.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3Qvb2JzZXJ2YWJsZS1VTU8zdlVhXy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7ZUFlQSxTQUFnQixhQUFhQSxDQUFBQSxFQUErQztJQUMxRSxjQUFjLE1BQU0sWUFBWSxNQUFNLFFBQVEsZUFBZTtBQUM5RDtlQUdELFNBQWdCLFdBQ2RDLFNBQUFBLEVBQzRCO0lBQzVCLE1BQU1DLE9BQW1DO1FBQ3ZDLFdBQVUsVUFBVTtZQUNsQixJQUFJQyxjQUFvQztZQUN4QyxJQUFJLFNBQVM7WUFDYixJQUFJLGVBQWU7WUFDbkIsSUFBSSxzQkFBc0I7WUFDMUIsU0FBUyxjQUFjO2dCQUNyQixJQUFJLGdCQUFnQixNQUFNO29CQUN4QixzQkFBc0I7b0JBQ3RCO2dCQUNEO2dCQUNELElBQUksYUFDRjtnQkFFRixlQUFlO2dCQUVmLFdBQVcsZ0JBQWdCLFdBQ3pCLGNBQWE7eUJBQ0osWUFDVCxhQUFZLGFBQWE7WUFFNUI7WUFDRCxjQUFjLFVBQVU7Z0JBQ3RCLE1BQUssT0FBTzs7b0JBQ1YsSUFBSSxPQUNGO29CQUVGLDJCQUFTLCtDQUFULDhCQUFnQixNQUFNO2dCQUN2QjtnQkFDRCxPQUFNLEtBQUs7O29CQUNULElBQUksT0FDRjtvQkFFRixTQUFTO29CQUNULDRCQUFTLGlEQUFULCtCQUFpQixJQUFJO29CQUNyQixhQUFhO2dCQUNkO2dCQUNELFdBQVc7O29CQUNULElBQUksT0FDRjtvQkFFRixTQUFTO29CQUNULCtCQUFTLHVEQUFULGlDQUFxQjtvQkFDckIsYUFBYTtnQkFDZDtZQUNGLEVBQUM7WUFDRixJQUFJLG9CQUNGLGNBQWE7WUFFZixPQUFPO2dCQUNMO1lBQ0Q7UUFDRjtRQUNELE1BQ0UsR0FBRyxZQUNtQjtZQUN0QixPQUFPLFdBQVcsT0FBTyxhQUFhLEtBQUs7UUFDNUM7SUFDRjtJQUNELE9BQU87QUFDUjtBQUVELFNBQVMsWUFBWUMsSUFBQUEsRUFBV0MsRUFBQUEsRUFBNkI7SUFDM0QsT0FBTyxHQUFHLEtBQUs7QUFDaEI7aUJBR0QsU0FBZ0Isb0JBQ2RDLFlBQUFBLEVBQ0E7SUFDQSxNQUFNLEtBQUssSUFBSTtJQUNmLE1BQU0sVUFBVSxJQUFJLFFBQWdCLENBQUMsU0FBUztRQUM1QyxJQUFJLFNBQVM7UUFDYixTQUFTLFNBQVM7WUFDaEIsSUFBSSxPQUNGO1lBRUYsU0FBUztZQUNULEtBQUssYUFBYTtRQUNuQjtRQUNELEdBQUcsT0FBTyxpQkFBaUIsU0FBUztZQUNsQyxPQUFPLEdBQUcsT0FBTyxPQUFPO1FBQ3pCLEVBQUM7UUFDRixNQUFNLE9BQU8sYUFBVyxVQUFVO1lBQ2hDLE1BQUssTUFBTTtnQkFDVCxTQUFTO2dCQUNULFFBQVEsS0FBSztnQkFDYixRQUFRO1lBQ1Q7WUFDRCxPQUFNLE1BQU07Z0JBQ1YsT0FBTyxLQUFLO1lBQ2I7WUFDRCxXQUFXO2dCQUNULEdBQUcsT0FBTztnQkFDVixRQUFRO1lBQ1Q7UUFDRixFQUFDO0lBQ0g7SUFDRCxPQUFPO0FBQ1I7OztHQUtELFNBQVMsMkJBQ1BBLFlBQUFBLEVBQ0FDLE1BQUFBLEVBQ2dDO0lBQ2hDLElBQUlDLFFBQStCO0lBRW5DLE1BQU0sVUFBVTtRQUNkLDRDQUFPLGFBQWE7UUFDcEIsUUFBUTtRQUNSLE9BQU8sb0JBQW9CLFNBQVMsUUFBUTtJQUM3QztJQUVELE9BQU8sSUFBSSxlQUErQjtRQUN4QyxPQUFNLFlBQVk7WUFDaEIsUUFBUSxhQUFXLFVBQVU7Z0JBQzNCLE1BQUssTUFBTTtvQkFDVCxXQUFXLFFBQVE7d0JBQUUsSUFBSTt3QkFBTSxPQUFPO29CQUFNLEVBQUM7Z0JBQzlDO2dCQUNELE9BQU0sT0FBTztvQkFDWCxXQUFXLFFBQVE7d0JBQUUsSUFBSTt3QkFBTztvQkFBTyxFQUFDO29CQUN4QyxXQUFXLE9BQU87Z0JBQ25CO2dCQUNELFdBQVc7b0JBQ1QsV0FBVyxPQUFPO2dCQUNuQjtZQUNGLEVBQUM7WUFFRixJQUFJLE9BQU8sUUFDVCxVQUFTO2lCQUVULE9BQU8saUJBQWlCLFNBQVMsU0FBUztnQkFBRSxNQUFNO1lBQU0sRUFBQztRQUU1RDtRQUNELFNBQVM7WUFDUCxTQUFTO1FBQ1Y7SUFDRjtBQUNGO2lCQUdELFNBQWdCLDBCQUNkRixZQUFBQSxFQUNBQyxNQUFBQSxFQUN1QjtJQUN2QixNQUFNLFNBQVMsMkJBQTJCRSxjQUFZLE9BQU87SUFFN0QsTUFBTSxTQUFTLE9BQU8sV0FBVztJQUNqQyxNQUFNQyxXQUFrQztRQUN0QyxNQUFNLE9BQU87WUFDWCxNQUFNLFFBQVEsTUFBTSxPQUFPLE1BQU07WUFDakMsSUFBSSxNQUFNLEtBQ1IsUUFBTztnQkFDTDtnQkFDQSxNQUFNO1lBQ1A7WUFFSCxNQUFNLEVBQUUsT0FBTyxRQUFRLEdBQUc7WUFDMUIsS0FBSyxPQUFPLEdBQ1YsT0FBTSxPQUFPO1lBRWYsT0FBTztnQkFDTCxPQUFPLE9BQU87Z0JBQ2QsTUFBTTtZQUNQO1FBQ0Y7UUFDRCxNQUFNLFNBQVM7WUFDYixNQUFNLE9BQU8sUUFBUTtZQUNyQixPQUFPO2dCQUNMO2dCQUNBLE1BQU07WUFDUDtRQUNGO0lBQ0Y7SUFDRCxPQUFPO1FBQ0wsQ0FBQyxPQUFPLGlCQUFpQjtZQUN2QixPQUFPO1FBQ1I7SUFDRjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBSZXN1bHQgfSBmcm9tICcuLi91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQnO1xuaW1wb3J0IHR5cGUge1xuICBPYnNlcnZhYmxlLFxuICBPYnNlcnZlcixcbiAgT3BlcmF0b3JGdW5jdGlvbixcbiAgVGVhcmRvd25Mb2dpYyxcbiAgVW5hcnlGdW5jdGlvbixcbiAgVW5zdWJzY3JpYmFibGUsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IHR5cGUgaW5mZXJPYnNlcnZhYmxlVmFsdWU8VE9ic2VydmFibGU+ID1cbiAgVE9ic2VydmFibGUgZXh0ZW5kcyBPYnNlcnZhYmxlPGluZmVyIFRWYWx1ZSwgdW5rbm93bj4gPyBUVmFsdWUgOiBuZXZlcjtcblxuLyoqIEBwdWJsaWMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09ic2VydmFibGUoeDogdW5rbm93bik6IHggaXMgT2JzZXJ2YWJsZTx1bmtub3duLCB1bmtub3duPiB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCAmJiAnc3Vic2NyaWJlJyBpbiB4O1xufVxuXG4vKiogQHB1YmxpYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGU8VFZhbHVlLCBURXJyb3IgPSB1bmtub3duPihcbiAgc3Vic2NyaWJlOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFRWYWx1ZSwgVEVycm9yPikgPT4gVGVhcmRvd25Mb2dpYyxcbik6IE9ic2VydmFibGU8VFZhbHVlLCBURXJyb3I+IHtcbiAgY29uc3Qgc2VsZjogT2JzZXJ2YWJsZTxUVmFsdWUsIFRFcnJvcj4gPSB7XG4gICAgc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICBsZXQgdGVhcmRvd25SZWY6IFRlYXJkb3duTG9naWMgfCBudWxsID0gbnVsbDtcbiAgICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICAgIGxldCB1bnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICAgIGxldCB0ZWFyZG93bkltbWVkaWF0ZWx5ID0gZmFsc2U7XG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRlYXJkb3duUmVmID09PSBudWxsKSB7XG4gICAgICAgICAgdGVhcmRvd25JbW1lZGlhdGVseSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bnN1YnNjcmliZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdW5zdWJzY3JpYmVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIHRlYXJkb3duUmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGVhcmRvd25SZWYoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZWFyZG93blJlZikge1xuICAgICAgICAgIHRlYXJkb3duUmVmLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlYXJkb3duUmVmID0gc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0RvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dD8uKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgICAgaWYgKGlzRG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgIG9ic2VydmVyLmVycm9yPy4oZXJyKTtcbiAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGU/LigpO1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGlmICh0ZWFyZG93bkltbWVkaWF0ZWx5KSB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bnN1YnNjcmliZSxcbiAgICAgIH07XG4gICAgfSxcbiAgICBwaXBlKFxuICAgICAgLi4ub3BlcmF0aW9uczogT3BlcmF0b3JGdW5jdGlvbjxhbnksIGFueSwgYW55LCBhbnk+W11cbiAgICApOiBPYnNlcnZhYmxlPGFueSwgYW55PiB7XG4gICAgICByZXR1cm4gb3BlcmF0aW9ucy5yZWR1Y2UocGlwZVJlZHVjZXIsIHNlbGYpO1xuICAgIH0sXG4gIH07XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBwaXBlUmVkdWNlcihwcmV2OiBhbnksIGZuOiBVbmFyeUZ1bmN0aW9uPGFueSwgYW55Pikge1xuICByZXR1cm4gZm4ocHJldik7XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZhYmxlVG9Qcm9taXNlPFRWYWx1ZT4oXG4gIG9ic2VydmFibGU6IE9ic2VydmFibGU8VFZhbHVlLCB1bmtub3duPixcbikge1xuICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPFRWYWx1ZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBpc0RvbmUgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBvbkRvbmUoKSB7XG4gICAgICBpZiAoaXNEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBvYnMkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgIHJlamVjdChhYy5zaWduYWwucmVhc29uKTtcbiAgICB9KTtcbiAgICBjb25zdCBvYnMkID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dChkYXRhKSB7XG4gICAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIG9uRG9uZSgpO1xuICAgICAgfSxcbiAgICAgIGVycm9yKGRhdGEpIHtcbiAgICAgICAgcmVqZWN0KGRhdGEpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBvbkRvbmUoKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW08VFZhbHVlPihcbiAgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUVmFsdWUsIHVua25vd24+LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuKTogUmVhZGFibGVTdHJlYW08UmVzdWx0PFRWYWx1ZT4+IHtcbiAgbGV0IHVuc3ViOiBVbnN1YnNjcmliYWJsZSB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgdW5zdWI/LnVuc3Vic2NyaWJlKCk7XG4gICAgdW5zdWIgPSBudWxsO1xuICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQpO1xuICB9O1xuXG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW08UmVzdWx0PFRWYWx1ZT4+KHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB1bnN1YiA9IG9ic2VydmFibGUuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dChkYXRhKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgb2s6IHRydWUsIHZhbHVlOiBkYXRhIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcihlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IG9rOiBmYWxzZSwgZXJyb3IgfSk7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgICAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIG9uQWJvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQWJvcnQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmNlbCgpIHtcbiAgICAgIG9uQWJvcnQoKTtcbiAgICB9LFxuICB9KTtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGU8VFZhbHVlPihcbiAgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUVmFsdWUsIHVua25vd24+LFxuICBzaWduYWw6IEFib3J0U2lnbmFsLFxuKTogQXN5bmNJdGVyYWJsZTxUVmFsdWU+IHtcbiAgY29uc3Qgc3RyZWFtID0gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSwgc2lnbmFsKTtcblxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IGl0ZXJhdG9yOiBBc3luY0l0ZXJhdG9yPFRWYWx1ZT4gPSB7XG4gICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgIGlmICh2YWx1ZS5kb25lKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgeyB2YWx1ZTogcmVzdWx0IH0gPSB2YWx1ZTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9LFxuICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWUsXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9LFxuICB9O1xufVxuIl0sIm5hbWVzIjpbIng6IHVua25vd24iLCJzdWJzY3JpYmU6IChvYnNlcnZlcjogT2JzZXJ2ZXI8VFZhbHVlLCBURXJyb3I+KSA9PiBUZWFyZG93bkxvZ2ljIiwic2VsZjogT2JzZXJ2YWJsZTxUVmFsdWUsIFRFcnJvcj4iLCJ0ZWFyZG93blJlZjogVGVhcmRvd25Mb2dpYyB8IG51bGwiLCJwcmV2OiBhbnkiLCJmbjogVW5hcnlGdW5jdGlvbjxhbnksIGFueT4iLCJvYnNlcnZhYmxlOiBPYnNlcnZhYmxlPFRWYWx1ZSwgdW5rbm93bj4iLCJzaWduYWw6IEFib3J0U2lnbmFsIiwidW5zdWI6IFVuc3Vic2NyaWJhYmxlIHwgbnVsbCIsIm9ic2VydmFibGUiLCJpdGVyYXRvcjogQXN5bmNJdGVyYXRvcjxUVmFsdWU+Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpromise: () => (/* binding */ Unpromise),\n/* harmony export */   createDeferred: () => (/* binding */ createDeferred),\n/* harmony export */   getRequestInfo: () => (/* binding */ getRequestInfo),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iteratorResource: () => (/* binding */ iteratorResource),\n/* harmony export */   jsonlStreamConsumer: () => (/* binding */ jsonlStreamConsumer),\n/* harmony export */   jsonlStreamProducer: () => (/* binding */ jsonlStreamProducer),\n/* harmony export */   makeAsyncResource: () => (/* binding */ makeAsyncResource),\n/* harmony export */   makeResource: () => (/* binding */ makeResource),\n/* harmony export */   parseConnectionParamsFromString: () => (/* binding */ parseConnectionParamsFromString),\n/* harmony export */   parseConnectionParamsFromUnknown: () => (/* binding */ parseConnectionParamsFromUnknown),\n/* harmony export */   require_usingCtx: () => (/* binding */ require_usingCtx),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   sseHeaders: () => (/* binding */ sseHeaders),\n/* harmony export */   sseStreamConsumer: () => (/* binding */ sseStreamConsumer),\n/* harmony export */   sseStreamProducer: () => (/* binding */ sseStreamProducer),\n/* harmony export */   takeWithGrace: () => (/* binding */ takeWithGrace),\n/* harmony export */   throwAbortError: () => (/* binding */ throwAbortError),\n/* harmony export */   withMaxDuration: () => (/* binding */ withMaxDuration)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\");\n/* harmony import */ var _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-gU3ttYjg.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs\");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\");\n\n\n\n\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n    try {\n        if (parsed === null) return null;\n        if (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(parsed)) throw new Error(\"Expected object\");\n        const nonStringValues = Object.entries(parsed).filter(([_key, value])=>typeof value !== \"string\");\n        if (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value])=>`${key}: ${typeof value}`).join(\", \")}`);\n        return parsed;\n    } catch (cause) {\n        throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"PARSE_ERROR\",\n            message: \"Invalid connection params shape\",\n            cause\n        });\n    }\n}\nfunction parseConnectionParamsFromString(str) {\n    let parsed;\n    try {\n        parsed = JSON.parse(str);\n    } catch (cause) {\n        throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"PARSE_ERROR\",\n            message: \"Not JSON-parsable query params\",\n            cause\n        });\n    }\n    return parseConnectionParamsFromUnknown(parsed);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/ function memo(fn) {\n    let promise = null;\n    const sym = Symbol.for(\"@trpc/server/http/memo\");\n    let value = sym;\n    return {\n        read: async ()=>{\n            var _promise;\n            if (value !== sym) return value;\n            (_promise = promise) !== null && _promise !== void 0 || (promise = fn().catch((cause)=>{\n                if (cause instanceof _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError) throw cause;\n                throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"BAD_REQUEST\",\n                    message: cause instanceof Error ? cause.message : \"Invalid input\",\n                    cause\n                });\n            }));\n            value = await promise;\n            promise = null;\n            return value;\n        },\n        result: ()=>{\n            return value !== sym ? value : void 0;\n        }\n    };\n}\nconst jsonContentTypeHandler = {\n    isMatch (req) {\n        var _req$headers$get;\n        return !!((_req$headers$get = req.headers.get(\"content-type\")) === null || _req$headers$get === void 0 ? void 0 : _req$headers$get.startsWith(\"application/json\"));\n    },\n    async parse (opts) {\n        var _types$values$next$va;\n        const { req } = opts;\n        const isBatchCall = opts.searchParams.get(\"batch\") === \"1\";\n        const paths = isBatchCall ? opts.path.split(\",\") : [\n            opts.path\n        ];\n        const getInputs = memo(async ()=>{\n            let inputs = void 0;\n            if (req.method === \"GET\") {\n                const queryInput = opts.searchParams.get(\"input\");\n                if (queryInput) inputs = JSON.parse(queryInput);\n            } else inputs = await req.json();\n            if (inputs === void 0) return {};\n            if (!isBatchCall) return {\n                0: opts.router._def._config.transformer.input.deserialize(inputs)\n            };\n            if (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(inputs)) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                code: \"BAD_REQUEST\",\n                message: \"\\\"input\\\" needs to be an object when doing a batch call\"\n            });\n            const acc = {};\n            for (const index of paths.keys()){\n                const input = inputs[index];\n                if (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n            }\n            return acc;\n        });\n        const calls = await Promise.all(paths.map(async (path, index)=>{\n            const procedure = await (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, path);\n            return {\n                path,\n                procedure,\n                getRawInput: async ()=>{\n                    const inputs = await getInputs.read();\n                    let input = inputs[index];\n                    if ((procedure === null || procedure === void 0 ? void 0 : procedure._def.type) === \"subscription\") {\n                        var _ref, _opts$headers$get;\n                        const lastEventId = (_ref = (_opts$headers$get = opts.headers.get(\"last-event-id\")) !== null && _opts$headers$get !== void 0 ? _opts$headers$get : opts.searchParams.get(\"lastEventId\")) !== null && _ref !== void 0 ? _ref : opts.searchParams.get(\"Last-Event-Id\");\n                        if (lastEventId) if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) input = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, input), {}, {\n                            lastEventId\n                        });\n                        else {\n                            var _input;\n                            (_input = input) !== null && _input !== void 0 || (input = {\n                                lastEventId\n                            });\n                        }\n                    }\n                    return input;\n                },\n                result: ()=>{\n                    var _getInputs$result;\n                    return (_getInputs$result = getInputs.result()) === null || _getInputs$result === void 0 ? void 0 : _getInputs$result[index];\n                }\n            };\n        }));\n        const types = new Set(calls.map((call)=>{\n            var _call$procedure;\n            return (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n        }).filter(Boolean));\n        /* istanbul ignore if -- @preserve */ if (types.size > 1) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Cannot mix procedure types in call: ${Array.from(types).join(\", \")}`\n        });\n        const type = (_types$values$next$va = types.values().next().value) !== null && _types$values$next$va !== void 0 ? _types$values$next$va : \"unknown\";\n        const connectionParamsStr = opts.searchParams.get(\"connectionParams\");\n        const info = {\n            isBatchCall,\n            accept: req.headers.get(\"trpc-accept\"),\n            calls,\n            type,\n            connectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n            signal: req.signal,\n            url: opts.url\n        };\n        return info;\n    }\n};\nconst formDataContentTypeHandler = {\n    isMatch (req) {\n        var _req$headers$get2;\n        return !!((_req$headers$get2 = req.headers.get(\"content-type\")) === null || _req$headers$get2 === void 0 ? void 0 : _req$headers$get2.startsWith(\"multipart/form-data\"));\n    },\n    async parse (opts) {\n        const { req } = opts;\n        if (req.method !== \"POST\") throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"METHOD_NOT_SUPPORTED\",\n            message: \"Only POST requests are supported for multipart/form-data requests\"\n        });\n        const getInputs = memo(async ()=>{\n            const fd = await req.formData();\n            return fd;\n        });\n        const procedure = await (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path);\n        return {\n            accept: null,\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure\n                }\n            ],\n            isBatchCall: false,\n            type: \"mutation\",\n            connectionParams: null,\n            signal: req.signal,\n            url: opts.url\n        };\n    }\n};\nconst octetStreamContentTypeHandler = {\n    isMatch (req) {\n        var _req$headers$get3;\n        return !!((_req$headers$get3 = req.headers.get(\"content-type\")) === null || _req$headers$get3 === void 0 ? void 0 : _req$headers$get3.startsWith(\"application/octet-stream\"));\n    },\n    async parse (opts) {\n        const { req } = opts;\n        if (req.method !== \"POST\") throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"METHOD_NOT_SUPPORTED\",\n            message: \"Only POST requests are supported for application/octet-stream requests\"\n        });\n        const getInputs = memo(async ()=>{\n            return req.body;\n        });\n        return {\n            calls: [\n                {\n                    path: opts.path,\n                    getRawInput: getInputs.read,\n                    result: getInputs.result,\n                    procedure: await (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path)\n                }\n            ],\n            isBatchCall: false,\n            accept: null,\n            type: \"mutation\",\n            connectionParams: null,\n            signal: req.signal,\n            url: opts.url\n        };\n    }\n};\nconst handlers = [\n    jsonContentTypeHandler,\n    formDataContentTypeHandler,\n    octetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n    const handler = handlers.find((handler$1)=>handler$1.isMatch(req));\n    if (handler) return handler;\n    if (!handler && req.method === \"GET\") return jsonContentTypeHandler;\n    throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n        code: \"UNSUPPORTED_MEDIA_TYPE\",\n        message: req.headers.has(\"content-type\") ? `Unsupported content-type \"${req.headers.get(\"content-type\")}` : \"Missing content-type header\"\n    });\n}\nasync function getRequestInfo(opts) {\n    const handler = getContentTypeHandler(opts.req);\n    return await handler.parse(opts);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(error) && error[\"name\"] === \"AbortError\";\n}\nfunction throwAbortError(message = \"AbortError\") {\n    throw new DOMException(message, \"AbortError\");\n}\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_defineProperty)(), 1);\nlet _Symbol$toStringTag;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/ const subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */ const NOOP = ()=>{};\n_Symbol$toStringTag = Symbol.toStringTag;\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/ var Unpromise = class Unpromise {\n    constructor(arg){\n        (0, import_defineProperty.default)(this, \"promise\", void 0);\n        (0, import_defineProperty.default)(this, \"subscribers\", []);\n        (0, import_defineProperty.default)(this, \"settlement\", null);\n        (0, import_defineProperty.default)(this, _Symbol$toStringTag, \"Unpromise\");\n        if (typeof arg === \"function\") this.promise = new Promise(arg);\n        else this.promise = arg;\n        const thenReturn = this.promise.then((value)=>{\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"fulfilled\",\n                value\n            };\n            subscribers === null || subscribers === void 0 || subscribers.forEach(({ resolve })=>{\n                resolve(value);\n            });\n        });\n        if (\"catch\" in thenReturn) thenReturn.catch((reason)=>{\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"rejected\",\n                reason\n            };\n            subscribers === null || subscribers === void 0 || subscribers.forEach(({ reject })=>{\n                reject(reason);\n            });\n        });\n    }\n    /** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/ subscribe() {\n        let promise;\n        let unsubscribe;\n        const { settlement } = this;\n        if (settlement === null) {\n            if (this.subscribers === null) throw new Error(\"Unpromise settled but still has subscribers\");\n            const subscriber = withResolvers();\n            this.subscribers = listWithMember(this.subscribers, subscriber);\n            promise = subscriber.promise;\n            unsubscribe = ()=>{\n                if (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n            };\n        } else {\n            const { status } = settlement;\n            if (status === \"fulfilled\") promise = Promise.resolve(settlement.value);\n            else promise = Promise.reject(settlement.reason);\n            unsubscribe = NOOP;\n        }\n        return Object.assign(promise, {\n            unsubscribe\n        });\n    }\n    /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */ then(onfulfilled, onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.then(onfulfilled, onrejected), {\n            unsubscribe\n        });\n    }\n    catch(onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.catch(onrejected), {\n            unsubscribe\n        });\n    }\n    finally(onfinally) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.finally(onfinally), {\n            unsubscribe\n        });\n    }\n    /** Unpromise STATIC METHODS */ /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */ static proxy(promise) {\n        const cached = Unpromise.getSubscribablePromise(promise);\n        return typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n    }\n    /** Create and store an Unpromise keyed by an original Promise. */ static createSubscribablePromise(promise) {\n        const created = new Unpromise(promise);\n        subscribableCache.set(promise, created);\n        subscribableCache.set(created, created);\n        return created;\n    }\n    /** Retrieve a previously-created Unpromise keyed by an original Promise. */ static getSubscribablePromise(promise) {\n        return subscribableCache.get(promise);\n    }\n    /** Promise STATIC METHODS */ /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */ static resolve(value) {\n        const promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n        return Unpromise.proxy(promise).subscribe();\n    }\n    static async any(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.any(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    static async race(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.race(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    /** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */ static async raceReferences(promises) {\n        const selfPromises = promises.map(resolveSelfTuple);\n        try {\n            return await Promise.race(selfPromises);\n        } finally{\n            for (const promise of selfPromises)promise.unsubscribe();\n        }\n    }\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */ function resolveSelfTuple(promise) {\n    return Unpromise.proxy(promise).then(()=>[\n            promise\n        ]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */ /** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */ function withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject)=>{\n        resolve = _resolve;\n        reject = _reject;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n/** IMMUTABLE LIST OPERATIONS */ function listWithMember(arr, member) {\n    return [\n        ...arr,\n        member\n    ];\n}\nfunction listWithoutIndex(arr, index) {\n    return [\n        ...arr.slice(0, index),\n        ...arr.slice(index + 1)\n    ];\n}\nfunction listWithoutMember(arr, member) {\n    const index = arr.indexOf(member);\n    if (index !== -1) return listWithoutIndex(arr, index);\n    return arr;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nvar _Symbol, _Symbol$dispose, _Symbol2, _Symbol2$asyncDispose;\n(_Symbol$dispose = (_Symbol = Symbol).dispose) !== null && _Symbol$dispose !== void 0 || (_Symbol.dispose = Symbol());\n(_Symbol2$asyncDispose = (_Symbol2 = Symbol).asyncDispose) !== null && _Symbol2$asyncDispose !== void 0 || (_Symbol2.asyncDispose = Symbol());\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/ function makeResource(thing, dispose) {\n    const it = thing;\n    const existing = it[Symbol.dispose];\n    it[Symbol.dispose] = ()=>{\n        dispose();\n        existing === null || existing === void 0 || existing();\n    };\n    return it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/ function makeAsyncResource(thing, dispose) {\n    const it = thing;\n    const existing = it[Symbol.asyncDispose];\n    it[Symbol.asyncDispose] = async ()=>{\n        await dispose();\n        await (existing === null || existing === void 0 ? void 0 : existing());\n    };\n    return it;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n    let timer = null;\n    return makeResource({\n        start () {\n            if (timer) throw new Error(\"Timer already started\");\n            const promise = new Promise((resolve)=>{\n                timer = setTimeout(()=>resolve(disposablePromiseTimerResult), ms);\n            });\n            return promise;\n        }\n    }, ()=>{\n        if (timer) clearTimeout(timer);\n    });\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\" (exports, module) {\n        function _usingCtx() {\n            var r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n                var n$1 = Error();\n                return n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n            }, e = {}, n = [];\n            function using(r$1, e$1) {\n                if (null != e$1) {\n                    if (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n                    if (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n                    if (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n                    if (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n                    t && (o = function o$1() {\n                        try {\n                            t.call(e$1);\n                        } catch (r$2) {\n                            return Promise.reject(r$2);\n                        }\n                    }), n.push({\n                        v: e$1,\n                        d: o,\n                        a: r$1\n                    });\n                } else r$1 && n.push({\n                    d: e$1,\n                    a: r$1\n                });\n                return e$1;\n            }\n            return {\n                e,\n                u: using.bind(null, !1),\n                a: using.bind(null, !0),\n                d: function d() {\n                    var o, t = this.e, s = 0;\n                    function next() {\n                        for(; o = n.pop();)try {\n                            if (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n                            if (o.d) {\n                                var r$1 = o.d.call(o.v);\n                                if (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n                            } else s |= 1;\n                        } catch (r$2) {\n                            return err(r$2);\n                        }\n                        if (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n                        if (t !== e) throw t;\n                    }\n                    function err(n$1) {\n                        return t = t !== e ? new r(n$1, t) : n$1, next();\n                    }\n                    return next();\n                }\n            };\n        }\n        module.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\nvar require_OverloadYield = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\" (exports, module) {\n        function _OverloadYield(e, d) {\n            this.v = e, this.k = d;\n        }\n        module.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\nvar require_awaitAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\" (exports, module) {\n        var OverloadYield$2 = require_OverloadYield();\n        function _awaitAsyncGenerator$5(e) {\n            return new OverloadYield$2(e, 0);\n        }\n        module.exports = _awaitAsyncGenerator$5, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\nvar require_wrapAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\" (exports, module) {\n        var OverloadYield$1 = require_OverloadYield();\n        function _wrapAsyncGenerator$6(e) {\n            return function() {\n                return new AsyncGenerator(e.apply(this, arguments));\n            };\n        }\n        function AsyncGenerator(e) {\n            var r, t;\n            function resume(r$1, t$1) {\n                try {\n                    var n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield$1;\n                    Promise.resolve(u ? o.v : o).then(function(t$2) {\n                        if (u) {\n                            var i = \"return\" === r$1 ? \"return\" : \"next\";\n                            if (!o.k || t$2.done) return resume(i, t$2);\n                            t$2 = e[i](t$2).value;\n                        }\n                        settle(n.done ? \"return\" : \"normal\", t$2);\n                    }, function(e$1) {\n                        resume(\"throw\", e$1);\n                    });\n                } catch (e$1) {\n                    settle(\"throw\", e$1);\n                }\n            }\n            function settle(e$1, n) {\n                switch(e$1){\n                    case \"return\":\n                        r.resolve({\n                            value: n,\n                            done: !0\n                        });\n                        break;\n                    case \"throw\":\n                        r.reject(n);\n                        break;\n                    default:\n                        r.resolve({\n                            value: n,\n                            done: !1\n                        });\n                }\n                (r = r.next) ? resume(r.key, r.arg) : t = null;\n            }\n            this._invoke = function(e$1, n) {\n                return new Promise(function(o, u) {\n                    var i = {\n                        key: e$1,\n                        arg: n,\n                        resolve: o,\n                        reject: u,\n                        next: null\n                    };\n                    t ? t = t.next = i : (r = t = i, resume(e$1, n));\n                });\n            }, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n        }\n        AsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function() {\n            return this;\n        }, AsyncGenerator.prototype.next = function(e) {\n            return this._invoke(\"next\", e);\n        }, AsyncGenerator.prototype[\"throw\"] = function(e) {\n            return this._invoke(\"throw\", e);\n        }, AsyncGenerator.prototype[\"return\"] = function(e) {\n            return this._invoke(\"return\", e);\n        };\n        module.exports = _wrapAsyncGenerator$6, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$5 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction iteratorResource(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    if (iterator[Symbol.asyncDispose]) return iterator;\n    return makeAsyncResource(iterator, async ()=>{\n        var _iterator$return;\n        await ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n    });\n}\n/**\n* Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n*/ function withMaxDuration(_x, _x2) {\n    return _withMaxDuration.apply(this, arguments);\n}\nfunction _withMaxDuration() {\n    _withMaxDuration = (0, import_wrapAsyncGenerator$5.default)(function*(iterable, opts) {\n        try {\n            var _usingCtx$1 = (0, import_usingCtx$4.default)();\n            const iterator = _usingCtx$1.a(iteratorResource(iterable));\n            const timer = _usingCtx$1.u(timerResource(opts.maxDurationMs));\n            const timerPromise = timer.start();\n            let result;\n            while(true){\n                result = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([\n                    iterator.next(),\n                    timerPromise\n                ]));\n                if (result === disposablePromiseTimerResult) throwAbortError();\n                if (result.done) return result;\n                yield result.value;\n                result = null;\n            }\n        } catch (_) {\n            _usingCtx$1.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator$4.default)(_usingCtx$1.d());\n        }\n    });\n    return _withMaxDuration.apply(this, arguments);\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/ function takeWithGrace(_x3, _x4) {\n    return _takeWithGrace.apply(this, arguments);\n}\nfunction _takeWithGrace() {\n    _takeWithGrace = (0, import_wrapAsyncGenerator$5.default)(function*(iterable, opts) {\n        try {\n            var _usingCtx3 = (0, import_usingCtx$4.default)();\n            const iterator = _usingCtx3.a(iteratorResource(iterable));\n            let result;\n            const timer = _usingCtx3.u(timerResource(opts.gracePeriodMs));\n            let count = opts.count;\n            let timerPromise = new Promise(()=>{});\n            while(true){\n                result = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([\n                    iterator.next(),\n                    timerPromise\n                ]));\n                if (result === disposablePromiseTimerResult) throwAbortError();\n                if (result.done) return result.value;\n                yield result.value;\n                if (--count === 0) timerPromise = timer.start();\n                result = null;\n            }\n        } catch (_) {\n            _usingCtx3.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator$4.default)(_usingCtx3.d());\n        }\n    });\n    return _takeWithGrace.apply(this, arguments);\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$4 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction createManagedIterator(iterable, onResult) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let state = \"idle\";\n    function cleanup() {\n        state = \"done\";\n        onResult = ()=>{};\n    }\n    function pull() {\n        if (state !== \"idle\") return;\n        state = \"pending\";\n        const next = iterator.next();\n        next.then((result)=>{\n            if (result.done) {\n                state = \"done\";\n                onResult({\n                    status: \"return\",\n                    value: result.value\n                });\n                cleanup();\n                return;\n            }\n            state = \"idle\";\n            onResult({\n                status: \"yield\",\n                value: result.value\n            });\n        }).catch((cause)=>{\n            onResult({\n                status: \"error\",\n                error: cause\n            });\n            cleanup();\n        });\n    }\n    return {\n        pull,\n        destroy: async ()=>{\n            var _iterator$return;\n            cleanup();\n            await ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n        }\n    };\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/ function mergeAsyncIterables() {\n    let state = \"idle\";\n    let flushSignal = createDeferred();\n    /**\n\t* used while {@link state} is `idle`\n\t*/ const iterables = [];\n    /**\n\t* used while {@link state} is `pending`\n\t*/ const iterators = /* @__PURE__ */ new Set();\n    const buffer = [];\n    function initIterable(iterable) {\n        if (state !== \"pending\") return;\n        const iterator = createManagedIterator(iterable, (result)=>{\n            if (state !== \"pending\") return;\n            switch(result.status){\n                case \"yield\":\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    break;\n                case \"return\":\n                    iterators.delete(iterator);\n                    break;\n                case \"error\":\n                    buffer.push([\n                        iterator,\n                        result\n                    ]);\n                    iterators.delete(iterator);\n                    break;\n            }\n            flushSignal.resolve();\n        });\n        iterators.add(iterator);\n        iterator.pull();\n    }\n    return {\n        add (iterable) {\n            switch(state){\n                case \"idle\":\n                    iterables.push(iterable);\n                    break;\n                case \"pending\":\n                    initIterable(iterable);\n                    break;\n                case \"done\":\n                    break;\n            }\n        },\n        [Symbol.asyncIterator] () {\n            return (0, import_wrapAsyncGenerator$4.default)(function*() {\n                try {\n                    var _usingCtx$1 = (0, import_usingCtx$3.default)();\n                    if (state !== \"idle\") throw new Error(\"Cannot iterate twice\");\n                    state = \"pending\";\n                    const _finally = _usingCtx$1.a(makeAsyncResource({}, async ()=>{\n                        state = \"done\";\n                        const errors = [];\n                        await Promise.all(Array.from(iterators.values()).map(async (it)=>{\n                            try {\n                                await it.destroy();\n                            } catch (cause) {\n                                errors.push(cause);\n                            }\n                        }));\n                        buffer.length = 0;\n                        iterators.clear();\n                        flushSignal.resolve();\n                        if (errors.length > 0) throw new AggregateError(errors);\n                    }));\n                    while(iterables.length > 0)initIterable(iterables.shift());\n                    while(iterators.size > 0){\n                        yield (0, import_awaitAsyncGenerator$3.default)(flushSignal.promise);\n                        while(buffer.length > 0){\n                            const [iterator, result] = buffer.shift();\n                            switch(result.status){\n                                case \"yield\":\n                                    yield result.value;\n                                    iterator.pull();\n                                    break;\n                                case \"error\":\n                                    throw result.error;\n                            }\n                        }\n                        flushSignal = createDeferred();\n                    }\n                } catch (_) {\n                    _usingCtx$1.e = _;\n                } finally{\n                    yield (0, import_awaitAsyncGenerator$3.default)(_usingCtx$1.d());\n                }\n            })();\n        }\n    };\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/ function readableStreamFrom(iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async cancel () {\n            var _iterator$return;\n            await ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n        },\n        async pull (controller) {\n            const result = await iterator.next();\n            if (result.done) {\n                controller.close();\n                return;\n            }\n            controller.enqueue(result.value);\n        }\n    });\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$3 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nconst PING_SYM = Symbol(\"ping\");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/ function withPing(_x, _x2) {\n    return _withPing.apply(this, arguments);\n}\nfunction _withPing() {\n    _withPing = (0, import_wrapAsyncGenerator$3.default)(function*(iterable, pingIntervalMs) {\n        try {\n            var _usingCtx$1 = (0, import_usingCtx$2.default)();\n            const iterator = _usingCtx$1.a(iteratorResource(iterable));\n            let result;\n            let nextPromise = iterator.next();\n            while(true)try {\n                var _usingCtx3 = (0, import_usingCtx$2.default)();\n                const pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n                result = yield (0, import_awaitAsyncGenerator$2.default)(Unpromise.race([\n                    nextPromise,\n                    pingPromise.start()\n                ]));\n                if (result === disposablePromiseTimerResult) {\n                    yield PING_SYM;\n                    continue;\n                }\n                if (result.done) return result.value;\n                nextPromise = iterator.next();\n                yield result.value;\n                result = null;\n            } catch (_) {\n                _usingCtx3.e = _;\n            } finally{\n                _usingCtx3.d();\n            }\n        } catch (_) {\n            _usingCtx$1.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator$2.default)(_usingCtx$1.d());\n        }\n    });\n    return _withPing.apply(this, arguments);\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\nvar require_asyncIterator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\" (exports, module) {\n        function _asyncIterator$2(r) {\n            var n, t, o, e = 2;\n            for(\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;){\n                if (t && null != (n = r[t])) return n.call(r);\n                if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n                t = \"@@asyncIterator\", o = \"@@iterator\";\n            }\n            throw new TypeError(\"Object is not async iterable\");\n        }\n        function AsyncFromSyncIterator(r) {\n            function AsyncFromSyncIteratorContinuation(r$1) {\n                if (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + \" is not an object.\"));\n                var n = r$1.done;\n                return Promise.resolve(r$1.value).then(function(r$2) {\n                    return {\n                        value: r$2,\n                        done: n\n                    };\n                });\n            }\n            return AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {\n                this.s = r$1, this.n = r$1.next;\n            }, AsyncFromSyncIterator.prototype = {\n                s: null,\n                n: null,\n                next: function next() {\n                    return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n                },\n                \"return\": function _return(r$1) {\n                    var n = this.s[\"return\"];\n                    return void 0 === n ? Promise.resolve({\n                        value: r$1,\n                        done: !0\n                    }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n                },\n                \"throw\": function _throw(r$1) {\n                    var n = this.s[\"return\"];\n                    return void 0 === n ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n                }\n            }, new AsyncFromSyncIterator(r);\n        }\n        module.exports = _asyncIterator$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_awaitAsyncGenerator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_usingCtx$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_asyncIterator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nfunction isPlainObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n    return ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) && typeof (value === null || value === void 0 ? void 0 : value[\"then\"]) === \"function\" && typeof (value === null || value === void 0 ? void 0 : value[\"catch\"]) === \"function\";\n}\nvar MaxDepthError = class extends Error {\n    constructor(path){\n        super(\"Max depth reached at path: \" + path.join(\".\"));\n        this.path = path;\n    }\n};\nfunction createBatchStreamProducer(_x3) {\n    return _createBatchStreamProducer.apply(this, arguments);\n}\nfunction _createBatchStreamProducer() {\n    _createBatchStreamProducer = (0, import_wrapAsyncGenerator$2.default)(function*(opts) {\n        const { data } = opts;\n        let counter = 0;\n        const placeholder = 0;\n        const mergedIterables = mergeAsyncIterables();\n        function registerAsync(callback) {\n            const idx = counter++;\n            const iterable$1 = callback(idx);\n            mergedIterables.add(iterable$1);\n            return idx;\n        }\n        function encodePromise(promise, path) {\n            return registerAsync(/* @__PURE__ */ function() {\n                var _ref = (0, import_wrapAsyncGenerator$2.default)(function*(idx) {\n                    const error = checkMaxDepth(path);\n                    if (error) {\n                        promise.catch((cause)=>{\n                            var _opts$onError;\n                            (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n                                error: cause,\n                                path\n                            });\n                        });\n                        promise = Promise.reject(error);\n                    }\n                    try {\n                        const next = yield (0, import_awaitAsyncGenerator$1.default)(promise);\n                        yield [\n                            idx,\n                            PROMISE_STATUS_FULFILLED,\n                            encode(next, path)\n                        ];\n                    } catch (cause) {\n                        var _opts$onError2, _opts$formatError;\n                        (_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n                            error: cause,\n                            path\n                        });\n                        yield [\n                            idx,\n                            PROMISE_STATUS_REJECTED,\n                            (_opts$formatError = opts.formatError) === null || _opts$formatError === void 0 ? void 0 : _opts$formatError.call(opts, {\n                                error: cause,\n                                path\n                            })\n                        ];\n                    }\n                });\n                return function(_x) {\n                    return _ref.apply(this, arguments);\n                };\n            }());\n        }\n        function encodeAsyncIterable(iterable$1, path) {\n            return registerAsync(/* @__PURE__ */ function() {\n                var _ref2 = (0, import_wrapAsyncGenerator$2.default)(function*(idx) {\n                    try {\n                        var _usingCtx$1 = (0, import_usingCtx$1.default)();\n                        const error = checkMaxDepth(path);\n                        if (error) throw error;\n                        const iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n                        try {\n                            while(true){\n                                const next = yield (0, import_awaitAsyncGenerator$1.default)(iterator.next());\n                                if (next.done) {\n                                    yield [\n                                        idx,\n                                        ASYNC_ITERABLE_STATUS_RETURN,\n                                        encode(next.value, path)\n                                    ];\n                                    break;\n                                }\n                                yield [\n                                    idx,\n                                    ASYNC_ITERABLE_STATUS_YIELD,\n                                    encode(next.value, path)\n                                ];\n                            }\n                        } catch (cause) {\n                            var _opts$onError3, _opts$formatError2;\n                            (_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n                                error: cause,\n                                path\n                            });\n                            yield [\n                                idx,\n                                ASYNC_ITERABLE_STATUS_ERROR,\n                                (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n                                    error: cause,\n                                    path\n                                })\n                            ];\n                        }\n                    } catch (_) {\n                        _usingCtx$1.e = _;\n                    } finally{\n                        yield (0, import_awaitAsyncGenerator$1.default)(_usingCtx$1.d());\n                    }\n                });\n                return function(_x2) {\n                    return _ref2.apply(this, arguments);\n                };\n            }());\n        }\n        function checkMaxDepth(path) {\n            if (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n            return null;\n        }\n        function encodeAsync(value, path) {\n            if (isPromise(value)) return [\n                CHUNK_VALUE_TYPE_PROMISE,\n                encodePromise(value, path)\n            ];\n            if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value)) {\n                if (opts.maxDepth && path.length >= opts.maxDepth) throw new Error(\"Max depth reached\");\n                return [\n                    CHUNK_VALUE_TYPE_ASYNC_ITERABLE,\n                    encodeAsyncIterable(value, path)\n                ];\n            }\n            return null;\n        }\n        function encode(value, path) {\n            if (value === void 0) return [\n                []\n            ];\n            const reg = encodeAsync(value, path);\n            if (reg) return [\n                [\n                    placeholder\n                ],\n                [\n                    null,\n                    ...reg\n                ]\n            ];\n            if (!isPlainObject(value)) return [\n                [\n                    value\n                ]\n            ];\n            const newObj = {};\n            const asyncValues = [];\n            for (const [key, item] of Object.entries(value)){\n                const transformed = encodeAsync(item, [\n                    ...path,\n                    key\n                ]);\n                if (!transformed) {\n                    newObj[key] = item;\n                    continue;\n                }\n                newObj[key] = placeholder;\n                asyncValues.push([\n                    key,\n                    ...transformed\n                ]);\n            }\n            return [\n                [\n                    newObj\n                ],\n                ...asyncValues\n            ];\n        }\n        const newHead = {};\n        for (const [key, item] of Object.entries(data))newHead[key] = encode(item, [\n            key\n        ]);\n        yield newHead;\n        let iterable = mergedIterables;\n        if (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n        var _iteratorAbruptCompletion = false;\n        var _didIteratorError = false;\n        var _iteratorError;\n        try {\n            for(var _iterator = (0, import_asyncIterator$1.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator$1.default)(_iterator.next())).done; _iteratorAbruptCompletion = false){\n                const value = _step.value;\n                yield value;\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator$1.default)(_iterator.return());\n            } finally{\n                if (_didIteratorError) throw _iteratorError;\n            }\n        }\n    });\n    return _createBatchStreamProducer.apply(this, arguments);\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/ function jsonlStreamProducer(opts) {\n    let stream = readableStreamFrom(createBatchStreamProducer(opts));\n    const { serialize } = opts;\n    if (serialize) stream = stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk === PING_SYM) controller.enqueue(PING_SYM);\n            else controller.enqueue(serialize(chunk));\n        }\n    }));\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (chunk === PING_SYM) controller.enqueue(\" \");\n            else controller.enqueue(JSON.stringify(chunk) + \"\\n\");\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n    constructor(data){\n        super(\"Received error from server\");\n        this.data = data;\n    }\n};\nconst nodeJsStreamToReaderEsque = (source)=>{\n    return {\n        getReader () {\n            const stream = new ReadableStream({\n                start (controller) {\n                    source.on(\"data\", (chunk)=>{\n                        controller.enqueue(chunk);\n                    });\n                    source.on(\"end\", ()=>{\n                        controller.close();\n                    });\n                    source.on(\"error\", (error)=>{\n                        controller.error(error);\n                    });\n                }\n            });\n            return stream.getReader();\n        }\n    };\n};\nfunction createLineAccumulator(from) {\n    const reader = \"getReader\" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n    let lineAggregate = \"\";\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await reader.read();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        cancel () {\n            return reader.cancel();\n        }\n    }).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            var _parts$pop;\n            lineAggregate += chunk;\n            const parts = lineAggregate.split(\"\\n\");\n            lineAggregate = (_parts$pop = parts.pop()) !== null && _parts$pop !== void 0 ? _parts$pop : \"\";\n            for (const part of parts)controller.enqueue(part);\n        }\n    }));\n}\nfunction createConsumerStream(from) {\n    const stream = createLineAccumulator(from);\n    let sentHead = false;\n    return stream.pipeThrough(new TransformStream({\n        transform (line, controller) {\n            if (!sentHead) {\n                const head = JSON.parse(line);\n                controller.enqueue(head);\n                sentHead = true;\n            } else {\n                const chunk = JSON.parse(line);\n                controller.enqueue(chunk);\n            }\n        }\n    }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/ function createStreamsManager(abortController) {\n    const controllerMap = /* @__PURE__ */ new Map();\n    /**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/ function isEmpty() {\n        return Array.from(controllerMap.values()).every((c)=>c.closed);\n    }\n    /**\n\t* Creates a stream controller\n\t*/ function createStreamController() {\n        let originalController;\n        const stream = new ReadableStream({\n            start (controller) {\n                originalController = controller;\n            }\n        });\n        const streamController = {\n            enqueue: (v)=>originalController.enqueue(v),\n            close: ()=>{\n                originalController.close();\n                clear();\n                if (isEmpty()) abortController.abort();\n            },\n            closed: false,\n            getReaderResource: ()=>{\n                const reader = stream.getReader();\n                return makeResource(reader, ()=>{\n                    reader.releaseLock();\n                    streamController.close();\n                });\n            },\n            error: (reason)=>{\n                originalController.error(reason);\n                clear();\n            }\n        };\n        function clear() {\n            Object.assign(streamController, {\n                closed: true,\n                close: ()=>{},\n                enqueue: ()=>{},\n                getReaderResource: null,\n                error: ()=>{}\n            });\n        }\n        return streamController;\n    }\n    /**\n\t* Gets or creates a stream controller\n\t*/ function getOrCreate(chunkId) {\n        let c = controllerMap.get(chunkId);\n        if (!c) {\n            c = createStreamController();\n            controllerMap.set(chunkId, c);\n        }\n        return c;\n    }\n    /**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/ function cancelAll(reason) {\n        for (const controller of controllerMap.values())controller.error(reason);\n    }\n    return {\n        getOrCreate,\n        isEmpty,\n        cancelAll\n    };\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/ async function jsonlStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let source = createConsumerStream(opts.from);\n    if (deserialize) source = source.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            controller.enqueue(deserialize(chunk));\n        }\n    }));\n    let headDeferred = createDeferred();\n    const streamManager = createStreamsManager(opts.abortController);\n    function decodeChunkDefinition(value) {\n        const [_path, type, chunkId] = value;\n        const controller = streamManager.getOrCreate(chunkId);\n        switch(type){\n            case CHUNK_VALUE_TYPE_PROMISE:\n                return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async ()=>{\n                    try {\n                        var _usingCtx3 = (0, import_usingCtx$1.default)();\n                        const reader = _usingCtx3.u(controller.getReaderResource());\n                        const { value: value$1 } = await reader.read();\n                        const [_chunkId, status, data] = value$1;\n                        switch(status){\n                            case PROMISE_STATUS_FULFILLED:\n                                return decode(data);\n                            case PROMISE_STATUS_REJECTED:\n                                var _opts$formatError3, _opts$formatError4;\n                                throw (_opts$formatError3 = (_opts$formatError4 = opts.formatError) === null || _opts$formatError4 === void 0 ? void 0 : _opts$formatError4.call(opts, {\n                                    error: data\n                                })) !== null && _opts$formatError3 !== void 0 ? _opts$formatError3 : new AsyncError(data);\n                        }\n                    } catch (_) {\n                        _usingCtx3.e = _;\n                    } finally{\n                        _usingCtx3.d();\n                    }\n                });\n            case CHUNK_VALUE_TYPE_ASYNC_ITERABLE:\n                return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$2.default)(function*() {\n                    try {\n                        var _usingCtx4 = (0, import_usingCtx$1.default)();\n                        const reader = _usingCtx4.u(controller.getReaderResource());\n                        while(true){\n                            const { value: value$1 } = yield (0, import_awaitAsyncGenerator$1.default)(reader.read());\n                            const [_chunkId, status, data] = value$1;\n                            switch(status){\n                                case ASYNC_ITERABLE_STATUS_YIELD:\n                                    yield decode(data);\n                                    break;\n                                case ASYNC_ITERABLE_STATUS_RETURN:\n                                    return decode(data);\n                                case ASYNC_ITERABLE_STATUS_ERROR:\n                                    var _opts$formatError5, _opts$formatError6;\n                                    throw (_opts$formatError5 = (_opts$formatError6 = opts.formatError) === null || _opts$formatError6 === void 0 ? void 0 : _opts$formatError6.call(opts, {\n                                        error: data\n                                    })) !== null && _opts$formatError5 !== void 0 ? _opts$formatError5 : new AsyncError(data);\n                            }\n                        }\n                    } catch (_) {\n                        _usingCtx4.e = _;\n                    } finally{\n                        _usingCtx4.d();\n                    }\n                }));\n        }\n    }\n    function decode(value) {\n        const [[data], ...asyncProps] = value;\n        for (const value$1 of asyncProps){\n            const [key] = value$1;\n            const decoded = decodeChunkDefinition(value$1);\n            if (key === null) return decoded;\n            data[key] = decoded;\n        }\n        return data;\n    }\n    const closeOrAbort = (reason)=>{\n        headDeferred === null || headDeferred === void 0 || headDeferred.reject(reason);\n        streamManager.cancelAll(reason);\n    };\n    source.pipeTo(new WritableStream({\n        write (chunkOrHead) {\n            if (headDeferred) {\n                const head = chunkOrHead;\n                for (const [key, value] of Object.entries(chunkOrHead)){\n                    const parsed = decode(value);\n                    head[key] = parsed;\n                }\n                headDeferred.resolve(head);\n                headDeferred = null;\n                return;\n            }\n            const chunk = chunkOrHead;\n            const [idx] = chunk;\n            const controller = streamManager.getOrCreate(idx);\n            controller.enqueue(chunk);\n        },\n        close: ()=>closeOrAbort(new Error(\"Stream closed\")),\n        abort: closeOrAbort\n    }), {\n        signal: opts.abortController.signal\n    }).catch((error)=>{\n        var _opts$onError4;\n        (_opts$onError4 = opts.onError) === null || _opts$onError4 === void 0 || _opts$onError4.call(opts, {\n            error\n        });\n        closeOrAbort(error);\n    });\n    return [\n        await headDeferred.promise,\n        streamManager\n    ];\n}\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\nvar require_asyncGeneratorDelegate = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({\n    \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\" (exports, module) {\n        var OverloadYield = require_OverloadYield();\n        function _asyncGeneratorDelegate$1(t) {\n            var e = {}, n = !1;\n            function pump(e$1, r) {\n                return n = !0, r = new Promise(function(n$1) {\n                    n$1(t[e$1](r));\n                }), {\n                    done: !1,\n                    value: new OverloadYield(r, 1)\n                };\n            }\n            return e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function() {\n                return this;\n            }, e.next = function(t$1) {\n                return n ? (n = !1, t$1) : pump(\"next\", t$1);\n            }, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function(t$1) {\n                if (n) throw n = !1, t$1;\n                return pump(\"throw\", t$1);\n            }), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function(t$1) {\n                return n ? (n = !1, t$1) : pump(\"return\", t$1);\n            }), e;\n        }\n        module.exports = _asyncGeneratorDelegate$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n    }\n});\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_asyncIterator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nvar import_awaitAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_asyncGeneratorDelegate = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncGeneratorDelegate(), 1);\nvar import_usingCtx = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nconst PING_EVENT = \"ping\";\nconst SERIALIZED_ERROR_EVENT = \"serialized-error\";\nconst CONNECTED_EVENT = \"connected\";\nconst RETURN_EVENT = \"return\";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/ function sseStreamProducer(opts) {\n    var _opts$ping$enabled, _opts$ping, _opts$ping$intervalMs, _opts$ping2, _opts$client;\n    const { serialize = _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.identity } = opts;\n    const ping = {\n        enabled: (_opts$ping$enabled = (_opts$ping = opts.ping) === null || _opts$ping === void 0 ? void 0 : _opts$ping.enabled) !== null && _opts$ping$enabled !== void 0 ? _opts$ping$enabled : false,\n        intervalMs: (_opts$ping$intervalMs = (_opts$ping2 = opts.ping) === null || _opts$ping2 === void 0 ? void 0 : _opts$ping2.intervalMs) !== null && _opts$ping$intervalMs !== void 0 ? _opts$ping$intervalMs : 1e3\n    };\n    const client = (_opts$client = opts.client) !== null && _opts$client !== void 0 ? _opts$client : {};\n    if (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n    function generator() {\n        return _generator.apply(this, arguments);\n    }\n    function _generator() {\n        _generator = (0, import_wrapAsyncGenerator$1.default)(function*() {\n            yield {\n                event: CONNECTED_EVENT,\n                data: JSON.stringify(client)\n            };\n            let iterable = opts.data;\n            if (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n                count: 1,\n                gracePeriodMs: 1\n            });\n            if (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) iterable = withMaxDuration(iterable, {\n                maxDurationMs: opts.maxDurationMs\n            });\n            if (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n            let value;\n            let chunk;\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n            var _iteratorError;\n            try {\n                for(var _iterator = (0, import_asyncIterator.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator.default)(_iterator.next())).done; _iteratorAbruptCompletion = false){\n                    value = _step.value;\n                    {\n                        if (value === PING_SYM) {\n                            yield {\n                                event: PING_EVENT,\n                                data: \"\"\n                            };\n                            continue;\n                        }\n                        chunk = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.isTrackedEnvelope)(value) ? {\n                            id: value[0],\n                            data: value[1]\n                        } : {\n                            data: value\n                        };\n                        chunk.data = JSON.stringify(serialize(chunk.data));\n                        yield chunk;\n                        value = null;\n                        chunk = null;\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator.default)(_iterator.return());\n                } finally{\n                    if (_didIteratorError) throw _iteratorError;\n                }\n            }\n        });\n        return _generator.apply(this, arguments);\n    }\n    function generatorWithErrorHandling() {\n        return _generatorWithErrorHandling.apply(this, arguments);\n    }\n    function _generatorWithErrorHandling() {\n        _generatorWithErrorHandling = (0, import_wrapAsyncGenerator$1.default)(function*() {\n            try {\n                yield* (0, import_asyncGeneratorDelegate.default)((0, import_asyncIterator.default)(generator()));\n                yield {\n                    event: RETURN_EVENT,\n                    data: \"\"\n                };\n            } catch (cause) {\n                var _opts$formatError, _opts$formatError2;\n                if (isAbortError(cause)) return;\n                const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n                const data = (_opts$formatError = (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n                    error\n                })) !== null && _opts$formatError !== void 0 ? _opts$formatError : null;\n                yield {\n                    event: SERIALIZED_ERROR_EVENT,\n                    data: JSON.stringify(serialize(data))\n                };\n            }\n        });\n        return _generatorWithErrorHandling.apply(this, arguments);\n    }\n    const stream = readableStreamFrom(generatorWithErrorHandling());\n    return stream.pipeThrough(new TransformStream({\n        transform (chunk, controller) {\n            if (\"event\" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n            if (\"data\" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n            if (\"id\" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n            if (\"comment\" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n            controller.enqueue(\"\\n\\n\");\n        }\n    })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n    try {\n        var _usingCtx$1 = (0, import_usingCtx.default)();\n        const timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n        const res = await Unpromise.race([\n            opts.promise,\n            timeoutPromise.start()\n        ]);\n        if (res === disposablePromiseTimerResult) return await opts.onTimeout();\n        return res;\n    } catch (_) {\n        _usingCtx$1.e = _;\n    } finally{\n        _usingCtx$1.d();\n    }\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/ function sseStreamConsumer(opts) {\n    const { deserialize = (v)=>v } = opts;\n    let clientOptions = {};\n    const signal = opts.signal;\n    let _es = null;\n    const createStream = ()=>new ReadableStream({\n            async start (controller) {\n                const [url, init] = await Promise.all([\n                    opts.url(),\n                    opts.init()\n                ]);\n                const eventSource = _es = new opts.EventSource(url, init);\n                controller.enqueue({\n                    type: \"connecting\",\n                    eventSource: _es,\n                    event: null\n                });\n                eventSource.addEventListener(CONNECTED_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    const options = JSON.parse(msg.data);\n                    clientOptions = options;\n                    controller.enqueue({\n                        type: \"connected\",\n                        options,\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg)=>{\n                    const msg = _msg;\n                    controller.enqueue({\n                        type: \"serialized-error\",\n                        error: deserialize(JSON.parse(msg.data)),\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(PING_EVENT, ()=>{\n                    controller.enqueue({\n                        type: \"ping\",\n                        eventSource\n                    });\n                });\n                eventSource.addEventListener(RETURN_EVENT, ()=>{\n                    eventSource.close();\n                    controller.close();\n                    _es = null;\n                });\n                eventSource.addEventListener(\"error\", (event)=>{\n                    if (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n                    else controller.enqueue({\n                        type: \"connecting\",\n                        eventSource,\n                        event\n                    });\n                });\n                eventSource.addEventListener(\"message\", (_msg)=>{\n                    const msg = _msg;\n                    const chunk = deserialize(JSON.parse(msg.data));\n                    const def = {\n                        data: chunk\n                    };\n                    if (msg.lastEventId) def.id = msg.lastEventId;\n                    controller.enqueue({\n                        type: \"data\",\n                        data: def,\n                        eventSource\n                    });\n                });\n                const onAbort = ()=>{\n                    try {\n                        eventSource.close();\n                        controller.close();\n                    } catch (_unused) {}\n                };\n                if (signal.aborted) onAbort();\n                else signal.addEventListener(\"abort\", onAbort);\n            },\n            cancel () {\n                _es === null || _es === void 0 || _es.close();\n            }\n        });\n    const getStreamResource = ()=>{\n        let stream = createStream();\n        let reader = stream.getReader();\n        async function dispose() {\n            await reader.cancel();\n            _es = null;\n        }\n        return makeAsyncResource({\n            read () {\n                return reader.read();\n            },\n            async recreate () {\n                await dispose();\n                stream = createStream();\n                reader = stream.getReader();\n            }\n        }, dispose);\n    };\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$1.default)(function*() {\n        try {\n            var _usingCtx3 = (0, import_usingCtx.default)();\n            const stream = _usingCtx3.a(getStreamResource());\n            while(true){\n                let promise = stream.read();\n                const timeoutMs = clientOptions.reconnectAfterInactivityMs;\n                if (timeoutMs) promise = withTimeout({\n                    promise,\n                    timeoutMs,\n                    onTimeout: async ()=>{\n                        const res = {\n                            value: {\n                                type: \"timeout\",\n                                ms: timeoutMs,\n                                eventSource: _es\n                            },\n                            done: false\n                        };\n                        await stream.recreate();\n                        return res;\n                    }\n                });\n                const result = yield (0, import_awaitAsyncGenerator.default)(promise);\n                if (result.done) return result.value;\n                yield result.value;\n            }\n        } catch (_) {\n            _usingCtx3.e = _;\n        } finally{\n            yield (0, import_awaitAsyncGenerator.default)(_usingCtx3.d());\n        }\n    }));\n}\nconst sseHeaders = {\n    \"Content-Type\": \"text/event-stream\",\n    \"Cache-Control\": \"no-cache, no-transform\",\n    \"X-Accel-Buffering\": \"no\",\n    Connection: \"keep-alive\"\n};\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nvar import_wrapAsyncGenerator = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\nfunction errorToAsyncIterable(err) {\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator.default)(function*() {\n        throw err;\n    }));\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n    mutation: [\n        \"POST\"\n    ],\n    query: [\n        \"GET\"\n    ],\n    subscription: [\n        \"GET\"\n    ]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n    mutation: [\n        \"POST\"\n    ],\n    query: [\n        \"GET\",\n        \"POST\"\n    ],\n    subscription: [\n        \"GET\",\n        \"POST\"\n    ]\n};\nfunction initResponse(initOpts) {\n    var _responseMeta, _info$calls$find$proc, _info$calls$find;\n    const { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n    let status = untransformedJSON ? (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getHTTPStatusCode)(untransformedJSON) : 200;\n    const eagerGeneration = !untransformedJSON;\n    const data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [\n        untransformedJSON\n    ];\n    const meta = (_responseMeta = responseMeta === null || responseMeta === void 0 ? void 0 : responseMeta({\n        ctx,\n        info,\n        paths: info === null || info === void 0 ? void 0 : info.calls.map((call)=>call.path),\n        data,\n        errors,\n        eagerGeneration,\n        type: (_info$calls$find$proc = info === null || info === void 0 || (_info$calls$find = info.calls.find((call)=>{\n            var _call$procedure;\n            return (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n        })) === null || _info$calls$find === void 0 || (_info$calls$find = _info$calls$find.procedure) === null || _info$calls$find === void 0 ? void 0 : _info$calls$find._def.type) !== null && _info$calls$find$proc !== void 0 ? _info$calls$find$proc : \"unknown\"\n    })) !== null && _responseMeta !== void 0 ? _responseMeta : {};\n    if (meta.headers) {\n        if (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries())headers.append(key, value);\n        else /**\n\t\t* @deprecated, delete in v12\n\t\t*/ for (const [key, value] of Object.entries(meta.headers))if (Array.isArray(value)) for (const v of value)headers.append(key, v);\n        else if (typeof value === \"string\") headers.set(key, value);\n    }\n    if (meta.status) status = meta.status;\n    return {\n        status\n    };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n    const { router, req, onError } = errorOpts.opts;\n    const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n    onError === null || onError === void 0 || onError({\n        error,\n        path: errorOpts.path,\n        input: errorOpts.input,\n        ctx: errorOpts.ctx,\n        type: errorOpts.type,\n        req\n    });\n    const untransformedJSON = {\n        error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n            config: router._def._config,\n            error,\n            type: errorOpts.type,\n            path: errorOpts.path,\n            input: errorOpts.input,\n            ctx: errorOpts.ctx\n        })\n    };\n    const transformedJSON = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(router._def._config, untransformedJSON);\n    const body = JSON.stringify(transformedJSON);\n    return {\n        error,\n        untransformedJSON,\n        body\n    };\n}\n/**\n* Check if a value is a stream-like object\n* - if it's an async iterable\n* - if it's an object with async iterables or promises\n*/ function isDataStream(v) {\n    if (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(v)) return false;\n    if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(v)) return true;\n    return Object.values(v).some(isPromise) || Object.values(v).some(_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n    var _ref, _opts$allowBatching, _opts$batching, _opts$allowMethodOver, _config$sse$enabled, _config$sse;\n    const { router, req } = opts;\n    const headers = new Headers([\n        [\n            \"vary\",\n            \"trpc-accept\"\n        ]\n    ]);\n    const config = router._def._config;\n    const url = new URL(req.url);\n    if (req.method === \"HEAD\") return new Response(null, {\n        status: 204\n    });\n    const allowBatching = (_ref = (_opts$allowBatching = opts.allowBatching) !== null && _opts$allowBatching !== void 0 ? _opts$allowBatching : (_opts$batching = opts.batching) === null || _opts$batching === void 0 ? void 0 : _opts$batching.enabled) !== null && _ref !== void 0 ? _ref : true;\n    const allowMethodOverride = ((_opts$allowMethodOver = opts.allowMethodOverride) !== null && _opts$allowMethodOver !== void 0 ? _opts$allowMethodOver : false) && req.method === \"POST\";\n    const infoTuple = await (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async ()=>{\n        try {\n            return [\n                void 0,\n                await getRequestInfo({\n                    req,\n                    path: decodeURIComponent(opts.path),\n                    router,\n                    searchParams: url.searchParams,\n                    headers: opts.req.headers,\n                    url\n                })\n            ];\n        } catch (cause) {\n            return [\n                (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                void 0\n            ];\n        }\n    });\n    const ctxManager = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(()=>{\n        let result = void 0;\n        return {\n            valueOrUndefined: ()=>{\n                if (!result) return void 0;\n                return result[1];\n            },\n            value: ()=>{\n                const [err, ctx] = result;\n                if (err) throw err;\n                return ctx;\n            },\n            create: async (info)=>{\n                if (result) throw new Error(\"This should only be called once - report a bug in tRPC\");\n                try {\n                    const ctx = await opts.createContext({\n                        info\n                    });\n                    result = [\n                        void 0,\n                        ctx\n                    ];\n                } catch (cause) {\n                    result = [\n                        (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                        void 0\n                    ];\n                }\n            }\n        };\n    });\n    const methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n    /**\n\t* @deprecated\n\t*/ const isStreamCall = req.headers.get(\"trpc-accept\") === \"application/jsonl\";\n    const experimentalSSE = (_config$sse$enabled = (_config$sse = config.sse) === null || _config$sse === void 0 ? void 0 : _config$sse.enabled) !== null && _config$sse$enabled !== void 0 ? _config$sse$enabled : true;\n    try {\n        const [infoError, info] = infoTuple;\n        if (infoError) throw infoError;\n        if (info.isBatchCall && !allowBatching) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            code: \"BAD_REQUEST\",\n            message: `Batching is not enabled on the server`\n        });\n        /* istanbul ignore if -- @preserve */ if (isStreamCall && !info.isBatchCall) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n            message: `Streaming requests must be batched (you can do a batch of 1)`,\n            code: \"BAD_REQUEST\"\n        });\n        await ctxManager.create(info);\n        const rpcCalls = info.calls.map(async (call)=>{\n            const proc = call.procedure;\n            try {\n                if (opts.error) throw opts.error;\n                if (!proc) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"NOT_FOUND\",\n                    message: `No procedure found on path \"${call.path}\"`\n                });\n                if (!methodMapper[proc._def.type].includes(req.method)) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"METHOD_NOT_SUPPORTED\",\n                    message: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n                });\n                if (proc._def.type === \"subscription\") {\n                    /* istanbul ignore if -- @preserve */ if (info.isBatchCall) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                        code: \"BAD_REQUEST\",\n                        message: `Cannot batch subscription calls`\n                    });\n                }\n                const data = await proc({\n                    path: call.path,\n                    getRawInput: call.getRawInput,\n                    ctx: ctxManager.value(),\n                    type: proc._def.type,\n                    signal: opts.req.signal\n                });\n                return [\n                    void 0,\n                    {\n                        data\n                    }\n                ];\n            } catch (cause) {\n                var _opts$onError, _call$procedure$_def$, _call$procedure2;\n                const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n                const input = call.result();\n                (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n                    error,\n                    path: call.path,\n                    input,\n                    ctx: ctxManager.valueOrUndefined(),\n                    type: (_call$procedure$_def$ = (_call$procedure2 = call.procedure) === null || _call$procedure2 === void 0 ? void 0 : _call$procedure2._def.type) !== null && _call$procedure$_def$ !== void 0 ? _call$procedure$_def$ : \"unknown\",\n                    req: opts.req\n                });\n                return [\n                    error,\n                    void 0\n                ];\n            }\n        });\n        if (!info.isBatchCall) {\n            const [call] = info.calls;\n            const [error, result] = await rpcCalls[0];\n            switch(info.type){\n                case \"unknown\":\n                case \"mutation\":\n                case \"query\":\n                    {\n                        headers.set(\"content-type\", \"application/json\");\n                        if (isDataStream(result === null || result === void 0 ? void 0 : result.data)) throw new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                            code: \"UNSUPPORTED_MEDIA_TYPE\",\n                            message: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n                        });\n                        const res = error ? {\n                            error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: info.type\n                            })\n                        } : {\n                            result: {\n                                data: result.data\n                            }\n                        };\n                        const headResponse$1 = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: error ? [\n                                error\n                            ] : [],\n                            headers,\n                            untransformedJSON: [\n                                res\n                            ]\n                        });\n                        return new Response(JSON.stringify((0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, res)), {\n                            status: headResponse$1.status,\n                            headers\n                        });\n                    }\n                case \"subscription\":\n                    {\n                        const iterable = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(()=>{\n                            if (error) return errorToAsyncIterable(error);\n                            if (!experimentalSSE) return errorToAsyncIterable(new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                                code: \"METHOD_NOT_SUPPORTED\",\n                                message: \"Missing experimental flag \\\"sseSubscriptions\\\"\"\n                            }));\n                            if (!(0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) && !(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(result.data)) return errorToAsyncIterable(new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                                message: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n                                code: \"INTERNAL_SERVER_ERROR\"\n                            }));\n                            const dataAsIterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : result.data;\n                            return dataAsIterable;\n                        });\n                        const stream = sseStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.sse), {}, {\n                            data: iterable,\n                            serialize: (v)=>config.transformer.output.serialize(v),\n                            formatError (errorOpts) {\n                                var _call$procedure$_def$2, _call$procedure3, _opts$onError2;\n                                const error$1 = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n                                const input = call === null || call === void 0 ? void 0 : call.result();\n                                const path = call === null || call === void 0 ? void 0 : call.path;\n                                const type = (_call$procedure$_def$2 = call === null || call === void 0 || (_call$procedure3 = call.procedure) === null || _call$procedure3 === void 0 ? void 0 : _call$procedure3._def.type) !== null && _call$procedure$_def$2 !== void 0 ? _call$procedure$_def$2 : \"unknown\";\n                                (_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n                                    error: error$1,\n                                    path,\n                                    input,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    req: opts.req,\n                                    type\n                                });\n                                const shape = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                    config,\n                                    ctx: ctxManager.valueOrUndefined(),\n                                    error: error$1,\n                                    input,\n                                    path,\n                                    type\n                                });\n                                return shape;\n                            }\n                        }));\n                        for (const [key, value] of Object.entries(sseHeaders))headers.set(key, value);\n                        const headResponse$1 = initResponse({\n                            ctx: ctxManager.valueOrUndefined(),\n                            info,\n                            responseMeta: opts.responseMeta,\n                            errors: [],\n                            headers,\n                            untransformedJSON: null\n                        });\n                        return new Response(stream, {\n                            headers,\n                            status: headResponse$1.status\n                        });\n                    }\n            }\n        }\n        if (info.accept === \"application/jsonl\") {\n            headers.set(\"content-type\", \"application/json\");\n            headers.set(\"transfer-encoding\", \"chunked\");\n            const headResponse$1 = initResponse({\n                ctx: ctxManager.valueOrUndefined(),\n                info,\n                responseMeta: opts.responseMeta,\n                errors: [],\n                headers,\n                untransformedJSON: null\n            });\n            const stream = jsonlStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.jsonl), {}, {\n                maxDepth: Infinity,\n                data: rpcCalls.map(async (res)=>{\n                    const [error, result] = await res;\n                    const call = info.calls[0];\n                    if (error) {\n                        var _procedure$_def$type, _procedure;\n                        return {\n                            error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                                config,\n                                ctx: ctxManager.valueOrUndefined(),\n                                error,\n                                input: call.result(),\n                                path: call.path,\n                                type: (_procedure$_def$type = (_procedure = call.procedure) === null || _procedure === void 0 ? void 0 : _procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n                            })\n                        };\n                    }\n                    /**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/ const iterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : Promise.resolve(result.data);\n                    return {\n                        result: Promise.resolve({\n                            data: iterable\n                        })\n                    };\n                }),\n                serialize: config.transformer.output.serialize,\n                onError: (cause)=>{\n                    var _opts$onError3, _info$type;\n                    (_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n                        error: (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n                        path: void 0,\n                        input: void 0,\n                        ctx: ctxManager.valueOrUndefined(),\n                        req: opts.req,\n                        type: (_info$type = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type !== void 0 ? _info$type : \"unknown\"\n                    });\n                },\n                formatError (errorOpts) {\n                    var _call$procedure$_def$3, _call$procedure4;\n                    const call = info === null || info === void 0 ? void 0 : info.calls[errorOpts.path[0]];\n                    const error = (0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n                    const input = call === null || call === void 0 ? void 0 : call.result();\n                    const path = call === null || call === void 0 ? void 0 : call.path;\n                    const type = (_call$procedure$_def$3 = call === null || call === void 0 || (_call$procedure4 = call.procedure) === null || _call$procedure4 === void 0 ? void 0 : _call$procedure4._def.type) !== null && _call$procedure$_def$3 !== void 0 ? _call$procedure$_def$3 : \"unknown\";\n                    const shape = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input,\n                        path,\n                        type\n                    });\n                    return shape;\n                }\n            }));\n            return new Response(stream, {\n                headers,\n                status: headResponse$1.status\n            });\n        }\n        /**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/ headers.set(\"content-type\", \"application/json\");\n        const results = (await Promise.all(rpcCalls)).map((res)=>{\n            const [error, result] = res;\n            if (error) return res;\n            if (isDataStream(result.data)) return [\n                new _tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n                    code: \"UNSUPPORTED_MEDIA_TYPE\",\n                    message: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n                }),\n                void 0\n            ];\n            return res;\n        });\n        const resultAsRPCResponse = results.map(([error, result], index)=>{\n            const call = info.calls[index];\n            if (error) {\n                var _call$procedure$_def$4, _call$procedure5;\n                return {\n                    error: (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n                        config,\n                        ctx: ctxManager.valueOrUndefined(),\n                        error,\n                        input: call.result(),\n                        path: call.path,\n                        type: (_call$procedure$_def$4 = (_call$procedure5 = call.procedure) === null || _call$procedure5 === void 0 ? void 0 : _call$procedure5._def.type) !== null && _call$procedure$_def$4 !== void 0 ? _call$procedure$_def$4 : \"unknown\"\n                    })\n                };\n            }\n            return {\n                result: {\n                    data: result.data\n                }\n            };\n        });\n        const errors = results.map(([error])=>error).filter(Boolean);\n        const headResponse = initResponse({\n            ctx: ctxManager.valueOrUndefined(),\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON: resultAsRPCResponse,\n            errors,\n            headers\n        });\n        return new Response(JSON.stringify((0,_tracked_gU3ttYjg_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, resultAsRPCResponse)), {\n            status: headResponse.status,\n            headers\n        });\n    } catch (cause) {\n        var _info$type2;\n        const [_infoError, info] = infoTuple;\n        const ctx = ctxManager.valueOrUndefined();\n        const { error, untransformedJSON, body } = caughtErrorToData(cause, {\n            opts,\n            ctx: ctxManager.valueOrUndefined(),\n            type: (_info$type2 = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type2 !== void 0 ? _info$type2 : \"unknown\"\n        });\n        const headResponse = initResponse({\n            ctx,\n            info,\n            responseMeta: opts.responseMeta,\n            untransformedJSON,\n            errors: [\n                error\n            ],\n            headers\n        });\n        return new Response(body, {\n            status: headResponse.status,\n            headers\n        });\n    }\n}\n//#endregion\n //# sourceMappingURL=resolveResponse-CzlbRpCI.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvcmVzb2x2ZVJlc3BvbnNlLUN6bGJScENJLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLFNBQWdCLGlDQUNkQSxNQUFBQSxFQUNxQztJQUNyQyxJQUFJO1FBQ0YsSUFBSSxXQUFXLEtBQ2IsUUFBTztRQUVULEtBQUssNkRBQVEsQ0FBQyxPQUFPLENBQ25CLE9BQU0sSUFBSSxNQUFNO1FBRWxCLE1BQU0sa0JBQWtCLE9BQU8sUUFBUSxPQUFPLENBQUMsT0FDN0MsQ0FBQyxDQUFDLE1BQU0sTUFBTSxVQUFZLFVBQVUsU0FDckM7UUFFRCxJQUFJLGdCQUFnQixTQUFTLEVBQzNCLE9BQU0sSUFBSSxPQUNQLHFEQUFxRCxnQkFDbkQsSUFBSSxDQUFDLENBQUMsS0FBSyxNQUFNLElBQU0sRUFBRSxJQUFJLFdBQVcsTUFBTSxFQUFFLENBQ2hELEtBQUssS0FBSyxDQUFDO1FBR2xCLE9BQU87SUFDUixTQUFRLE9BQU87UUFDZCxNQUFNLElBQUksNERBQVMsQ0FBQztZQUNsQixNQUFNO1lBQ04sU0FBUztZQUNUO1FBQ0Q7SUFDRjtBQUNGO0FBQ0QsU0FBZ0IsZ0NBQ2RDLEdBQUFBLEVBQ3FDO0lBQ3JDLElBQUlEO0lBQ0osSUFBSTtRQUNGLFNBQVMsS0FBSyxNQUFNLElBQUk7SUFDekIsU0FBUSxPQUFPO1FBQ2QsTUFBTSxJQUFJLDREQUFTLENBQUM7WUFDbEIsTUFBTTtZQUNOLFNBQVM7WUFDVDtRQUNEO0lBQ0Y7SUFDRCxPQUFPLGlDQUFpQyxPQUFPO0FBQ2hEOzs7Ozs7O0dDdkJELFNBQVMsS0FBY0UsRUFBQUEsRUFBNEI7SUFDakQsSUFBSUMsVUFBbUM7SUFDdkMsTUFBTSxNQUFNLE9BQU8sSUFBSSx5QkFBeUI7SUFDaEQsSUFBSUMsUUFBOEI7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QUFNLEVBQUUsT0FBTyxtQkFBbUIsTUFBTSxHQUFHLGtCQUFrQixPQUFPO1lBQ2xFO1lBQ0EsS0FBSyxXQUFXLGtCQUFrQjtZQUNsQyxpRUFBTSxLQUFNLHlEQUFRO1FBQ3JCLEVBQUM7UUFFRixNQUFNLGVBQWUsYUFBYTtZQUNoQztZQUNBO1lBQ0EsY0FBYyxLQUFLO1lBQ25CO1lBQ0EsUUFBUTtnQkFBQyxLQUFNO2FBQUE7WUFDZjtRQUNELEVBQUM7UUFFRixPQUFPLElBQUksU0FBUyxNQUFNO1lBQ3hCLFFBQVEsYUFBYTtZQUNyQjtRQUNEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvcGFyc2VDb25uZWN0aW9uUGFyYW1zLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvY29udGVudFR5cGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvaHR0cC9hYm9ydEVycm9yLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdmVuZG9yL3VucHJvbWlzZS91bnByb21pc2UudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2Rpc3Bvc2FibGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3RpbWVyUmVzb3VyY2UudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3VzaW5nQ3R4LmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9PdmVybG9hZFlpZWxkLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3IuanMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2FzeW5jSXRlcmFibGUudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2NyZWF0ZURlZmVycmVkLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9tZXJnZUFzeW5jSXRlcmFibGVzLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20udHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL3dpdGhQaW5nLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3luY0l0ZXJhdG9yLmpzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS9qc29ubC50cyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZS5qcyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vc3NlLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvcmVzb2x2ZVJlc3BvbnNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRSUENFcnJvciB9IGZyb20gJy4uL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB0eXBlIHsgVFJQQ1JlcXVlc3RJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93bihcbiAgcGFyc2VkOiB1bmtub3duLFxuKTogVFJQQ1JlcXVlc3RJbmZvWydjb25uZWN0aW9uUGFyYW1zJ10ge1xuICB0cnkge1xuICAgIGlmIChwYXJzZWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIWlzT2JqZWN0KHBhcnNlZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IG5vblN0cmluZ1ZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHBhcnNlZCkuZmlsdGVyKFxuICAgICAgKFtfa2V5LCB2YWx1ZV0pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycsXG4gICAgKTtcblxuICAgIGlmIChub25TdHJpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgY29ubmVjdGlvblBhcmFtcyB0byBiZSBzdHJpbmcgdmFsdWVzLiBHb3QgJHtub25TdHJpbmdWYWx1ZXNcbiAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06ICR7dHlwZW9mIHZhbHVlfWApXG4gICAgICAgICAgLmpvaW4oJywgJyl9YCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgIGNvZGU6ICdQQVJTRV9FUlJPUicsXG4gICAgICBtZXNzYWdlOiAnSW52YWxpZCBjb25uZWN0aW9uIHBhcmFtcyBzaGFwZScsXG4gICAgICBjYXVzZSxcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoXG4gIHN0cjogc3RyaW5nLFxuKTogVFJQQ1JlcXVlc3RJbmZvWydjb25uZWN0aW9uUGFyYW1zJ10ge1xuICBsZXQgcGFyc2VkOiB1bmtub3duO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RyKTtcbiAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgIGNvZGU6ICdQQVJTRV9FUlJPUicsXG4gICAgICBtZXNzYWdlOiAnTm90IEpTT04tcGFyc2FibGUgcXVlcnkgcGFyYW1zJyxcbiAgICAgIGNhdXNlLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93bihwYXJzZWQpO1xufVxuIiwiaW1wb3J0IHsgVFJQQ0Vycm9yIH0gZnJvbSAnLi4vZXJyb3IvVFJQQ0Vycm9yJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlVHlwZSB9IGZyb20gJy4uL3Byb2NlZHVyZSc7XG5pbXBvcnQgeyBnZXRQcm9jZWR1cmVBdFBhdGgsIHR5cGUgQW55Um91dGVyIH0gZnJvbSAnLi4vcm91dGVyJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVN0cmluZyB9IGZyb20gJy4vcGFyc2VDb25uZWN0aW9uUGFyYW1zJztcbmltcG9ydCB0eXBlIHsgVFJQQ0FjY2VwdEhlYWRlciwgVFJQQ1JlcXVlc3RJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbnR5cGUgR2V0UmVxdWVzdEluZm9PcHRpb25zID0ge1xuICBwYXRoOiBzdHJpbmc7XG4gIHJlcTogUmVxdWVzdDtcbiAgdXJsOiBVUkwgfCBudWxsO1xuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcztcbiAgaGVhZGVyczogSGVhZGVycztcbiAgcm91dGVyOiBBbnlSb3V0ZXI7XG59O1xuXG50eXBlIENvbnRlbnRUeXBlSGFuZGxlciA9IHtcbiAgaXNNYXRjaDogKG9wdHM6IFJlcXVlc3QpID0+IGJvb2xlYW47XG4gIHBhcnNlOiAob3B0czogR2V0UmVxdWVzdEluZm9PcHRpb25zKSA9PiBQcm9taXNlPFRSUENSZXF1ZXN0SW5mbz47XG59O1xuXG4vKipcbiAqIE1lbW9pemUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vIGFyZ3VtZW50c1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1lbW88VFJldHVybj4oZm46ICgpID0+IFByb21pc2U8VFJldHVybj4pIHtcbiAgbGV0IHByb21pc2U6IFByb21pc2U8VFJldHVybj4gfCBudWxsID0gbnVsbDtcbiAgY29uc3Qgc3ltID0gU3ltYm9sLmZvcignQHRycGMvc2VydmVyL2h0dHAvbWVtbycpO1xuICBsZXQgdmFsdWU6IFRSZXR1cm4gfCB0eXBlb2Ygc3ltID0gc3ltO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIExhemlseSByZWFkIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIHJlYWQ6IGFzeW5jICgpOiBQcm9taXNlPFRSZXR1cm4+ID0+IHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gc3ltKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVkdXBlcyBwcm9taXNlcyBhbmQgY2F0Y2hlcyBlcnJvcnNcbiAgICAgIHByb21pc2UgPz89IGZuKCkuY2F0Y2goKGNhdXNlKSA9PiB7XG4gICAgICAgIGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikge1xuICAgICAgICAgIHRocm93IGNhdXNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgIGNvZGU6ICdCQURfUkVRVUVTVCcsXG4gICAgICAgICAgbWVzc2FnZTogY2F1c2UgaW5zdGFuY2VvZiBFcnJvciA/IGNhdXNlLm1lc3NhZ2UgOiAnSW52YWxpZCBpbnB1dCcsXG4gICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhbHVlID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBudWxsO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYWxyZWFkeSBzdG9yZWQgcmVzdWx0XG4gICAgICovXG4gICAgcmVzdWx0OiAoKTogVFJldHVybiB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IHN5bSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gIH07XG59XG5cbmNvbnN0IGpzb25Db250ZW50VHlwZUhhbmRsZXI6IENvbnRlbnRUeXBlSGFuZGxlciA9IHtcbiAgaXNNYXRjaChyZXEpIHtcbiAgICByZXR1cm4gISFyZXEuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpPy5zdGFydHNXaXRoKCdhcHBsaWNhdGlvbi9qc29uJyk7XG4gIH0sXG4gIGFzeW5jIHBhcnNlKG9wdHMpIHtcbiAgICBjb25zdCB7IHJlcSB9ID0gb3B0cztcbiAgICBjb25zdCBpc0JhdGNoQ2FsbCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnYmF0Y2gnKSA9PT0gJzEnO1xuICAgIGNvbnN0IHBhdGhzID0gaXNCYXRjaENhbGwgPyBvcHRzLnBhdGguc3BsaXQoJywnKSA6IFtvcHRzLnBhdGhdO1xuXG4gICAgdHlwZSBJbnB1dFJlY29yZCA9IFJlY29yZDxudW1iZXIsIHVua25vd24+O1xuICAgIGNvbnN0IGdldElucHV0cyA9IG1lbW8oYXN5bmMgKCk6IFByb21pc2U8SW5wdXRSZWNvcmQ+ID0+IHtcbiAgICAgIGxldCBpbnB1dHM6IHVua25vd24gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgY29uc3QgcXVlcnlJbnB1dCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnaW5wdXQnKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5wdXQpIHtcbiAgICAgICAgICBpbnB1dHMgPSBKU09OLnBhcnNlKHF1ZXJ5SW5wdXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dHMgPSBhd2FpdCByZXEuanNvbigpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0JhdGNoQ2FsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIDA6IG9wdHMucm91dGVyLl9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lci5pbnB1dC5kZXNlcmlhbGl6ZShpbnB1dHMpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzT2JqZWN0KGlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgICBtZXNzYWdlOiAnXCJpbnB1dFwiIG5lZWRzIHRvIGJlIGFuIG9iamVjdCB3aGVuIGRvaW5nIGEgYmF0Y2ggY2FsbCcsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgYWNjOiBJbnB1dFJlY29yZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBwYXRocy5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBpbnB1dHNbaW5kZXhdO1xuICAgICAgICBpZiAoaW5wdXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFjY1tpbmRleF0gPVxuICAgICAgICAgICAgb3B0cy5yb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLmlucHV0LmRlc2VyaWFsaXplKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0pO1xuXG4gICAgY29uc3QgY2FsbHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHBhdGhzLm1hcChcbiAgICAgICAgYXN5bmMgKHBhdGgsIGluZGV4KTogUHJvbWlzZTxUUlBDUmVxdWVzdEluZm9bJ2NhbGxzJ11bbnVtYmVyXT4gPT4ge1xuICAgICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBwcm9jZWR1cmUsXG4gICAgICAgICAgICBnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dHMgPSBhd2FpdCBnZXRJbnB1dHMucmVhZCgpO1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgIGlmIChwcm9jZWR1cmU/Ll9kZWYudHlwZSA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0RXZlbnRJZCA9XG4gICAgICAgICAgICAgICAgICBvcHRzLmhlYWRlcnMuZ2V0KCdsYXN0LWV2ZW50LWlkJykgPz9cbiAgICAgICAgICAgICAgICAgIG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnbGFzdEV2ZW50SWQnKSA/P1xuICAgICAgICAgICAgICAgICAgb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KCdMYXN0LUV2ZW50LUlkJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdEV2ZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgLi4uaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQ6IGxhc3RFdmVudElkLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQgPz89IHtcbiAgICAgICAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZDogbGFzdEV2ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN1bHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldElucHV0cy5yZXN1bHQoKT8uW2luZGV4XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcblxuICAgIGNvbnN0IHR5cGVzID0gbmV3IFNldChcbiAgICAgIGNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSkuZmlsdGVyKEJvb2xlYW4pLFxuICAgICk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLS0gQHByZXNlcnZlICovXG4gICAgaWYgKHR5cGVzLnNpemUgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgICAgbWVzc2FnZTogYENhbm5vdCBtaXggcHJvY2VkdXJlIHR5cGVzIGluIGNhbGw6ICR7QXJyYXkuZnJvbSh0eXBlcykuam9pbihcbiAgICAgICAgICAnLCAnLFxuICAgICAgICApfWAsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdHlwZTogUHJvY2VkdXJlVHlwZSB8ICd1bmtub3duJyA9XG4gICAgICB0eXBlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUgPz8gJ3Vua25vd24nO1xuXG4gICAgY29uc3QgY29ubmVjdGlvblBhcmFtc1N0ciA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldCgnY29ubmVjdGlvblBhcmFtcycpO1xuXG4gICAgY29uc3QgaW5mbzogVFJQQ1JlcXVlc3RJbmZvID0ge1xuICAgICAgaXNCYXRjaENhbGwsXG4gICAgICBhY2NlcHQ6IHJlcS5oZWFkZXJzLmdldCgndHJwYy1hY2NlcHQnKSBhcyBUUlBDQWNjZXB0SGVhZGVyIHwgbnVsbCxcbiAgICAgIGNhbGxzLFxuICAgICAgdHlwZSxcbiAgICAgIGNvbm5lY3Rpb25QYXJhbXM6XG4gICAgICAgIGNvbm5lY3Rpb25QYXJhbXNTdHIgPT09IG51bGxcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHBhcnNlQ29ubmVjdGlvblBhcmFtc0Zyb21TdHJpbmcoY29ubmVjdGlvblBhcmFtc1N0ciksXG4gICAgICBzaWduYWw6IHJlcS5zaWduYWwsXG4gICAgICB1cmw6IG9wdHMudXJsLFxuICAgIH07XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG59O1xuXG5jb25zdCBmb3JtRGF0YUNvbnRlbnRUeXBlSGFuZGxlcjogQ29udGVudFR5cGVIYW5kbGVyID0ge1xuICBpc01hdGNoKHJlcSkge1xuICAgIHJldHVybiAhIXJlcS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk/LnN0YXJ0c1dpdGgoJ211bHRpcGFydC9mb3JtLWRhdGEnKTtcbiAgfSxcbiAgYXN5bmMgcGFyc2Uob3B0cykge1xuICAgIGNvbnN0IHsgcmVxIH0gPSBvcHRzO1xuICAgIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcbiAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBjb2RlOiAnTUVUSE9EX05PVF9TVVBQT1JURUQnLFxuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSByZXF1ZXN0cycsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBmZCA9IGF3YWl0IHJlcS5mb3JtRGF0YSgpO1xuICAgICAgcmV0dXJuIGZkO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgb3B0cy5wYXRoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjZXB0OiBudWxsLFxuICAgICAgY2FsbHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHBhdGg6IG9wdHMucGF0aCxcbiAgICAgICAgICBnZXRSYXdJbnB1dDogZ2V0SW5wdXRzLnJlYWQsXG4gICAgICAgICAgcmVzdWx0OiBnZXRJbnB1dHMucmVzdWx0LFxuICAgICAgICAgIHByb2NlZHVyZSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBpc0JhdGNoQ2FsbDogZmFsc2UsXG4gICAgICB0eXBlOiAnbXV0YXRpb24nLFxuICAgICAgY29ubmVjdGlvblBhcmFtczogbnVsbCxcbiAgICAgIHNpZ25hbDogcmVxLnNpZ25hbCxcbiAgICAgIHVybDogb3B0cy51cmwsXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IG9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyOiBDb250ZW50VHlwZUhhbmRsZXIgPSB7XG4gIGlzTWF0Y2gocmVxKSB7XG4gICAgcmV0dXJuICEhcmVxLmhlYWRlcnNcbiAgICAgIC5nZXQoJ2NvbnRlbnQtdHlwZScpXG4gICAgICA/LnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICB9LFxuICBhc3luYyBwYXJzZShvcHRzKSB7XG4gICAgY29uc3QgeyByZXEgfSA9IG9wdHM7XG4gICAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xuICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgJ09ubHkgUE9TVCByZXF1ZXN0cyBhcmUgc3VwcG9ydGVkIGZvciBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0gcmVxdWVzdHMnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGdldElucHV0cyA9IG1lbW8oYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIHJlcS5ib2R5O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBjYWxsczogW1xuICAgICAgICB7XG4gICAgICAgICAgcGF0aDogb3B0cy5wYXRoLFxuICAgICAgICAgIGdldFJhd0lucHV0OiBnZXRJbnB1dHMucmVhZCxcbiAgICAgICAgICByZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG4gICAgICAgICAgcHJvY2VkdXJlOiBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIG9wdHMucGF0aCksXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgICAgaXNCYXRjaENhbGw6IGZhbHNlLFxuICAgICAgYWNjZXB0OiBudWxsLFxuICAgICAgdHlwZTogJ211dGF0aW9uJyxcbiAgICAgIGNvbm5lY3Rpb25QYXJhbXM6IG51bGwsXG4gICAgICBzaWduYWw6IHJlcS5zaWduYWwsXG4gICAgICB1cmw6IG9wdHMudXJsLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBoYW5kbGVycyA9IFtcbiAganNvbkNvbnRlbnRUeXBlSGFuZGxlcixcbiAgZm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXIsXG4gIG9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyLFxuXTtcblxuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVIYW5kbGVyKHJlcTogUmVxdWVzdCk6IENvbnRlbnRUeXBlSGFuZGxlciB7XG4gIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVycy5maW5kKChoYW5kbGVyKSA9PiBoYW5kbGVyLmlzTWF0Y2gocmVxKSk7XG4gIGlmIChoYW5kbGVyKSB7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cblxuICBpZiAoIWhhbmRsZXIgJiYgcmVxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAvLyBmYWxsYmFjayB0byBKU09OIGZvciBnZXQgcmVxdWVzdHMgc28gR0VULXJlcXVlc3RzIGNhbiBiZSBvcGVuZWQgaW4gYnJvd3NlciBlYXNpbHlcbiAgICByZXR1cm4ganNvbkNvbnRlbnRUeXBlSGFuZGxlcjtcbiAgfVxuXG4gIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgIGNvZGU6ICdVTlNVUFBPUlRFRF9NRURJQV9UWVBFJyxcbiAgICBtZXNzYWdlOiByZXEuaGVhZGVycy5oYXMoJ2NvbnRlbnQtdHlwZScpXG4gICAgICA/IGBVbnN1cHBvcnRlZCBjb250ZW50LXR5cGUgXCIke3JlcS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyl9YFxuICAgICAgOiAnTWlzc2luZyBjb250ZW50LXR5cGUgaGVhZGVyJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRSZXF1ZXN0SW5mbyhcbiAgb3B0czogR2V0UmVxdWVzdEluZm9PcHRpb25zLFxuKTogUHJvbWlzZTxUUlBDUmVxdWVzdEluZm8+IHtcbiAgY29uc3QgaGFuZGxlciA9IGdldENvbnRlbnRUeXBlSGFuZGxlcihvcHRzLnJlcSk7XG4gIHJldHVybiBhd2FpdCBoYW5kbGVyLnBhcnNlKG9wdHMpO1xufVxuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Fib3J0RXJyb3IoXG4gIGVycm9yOiB1bmtub3duLFxuKTogZXJyb3IgaXMgRE9NRXhjZXB0aW9uIHwgRXJyb3IgfCB7IG5hbWU6ICdBYm9ydEVycm9yJyB9IHtcbiAgcmV0dXJuIGlzT2JqZWN0KGVycm9yKSAmJiBlcnJvclsnbmFtZSddID09PSAnQWJvcnRFcnJvcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0aHJvd0Fib3J0RXJyb3IobWVzc2FnZSA9ICdBYm9ydEVycm9yJyk6IG5ldmVyIHtcbiAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihtZXNzYWdlLCAnQWJvcnRFcnJvcicpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kICovXG4gXG4gXG5cbmltcG9ydCB0eXBlIHtcbiAgUHJvbWlzZUV4ZWN1dG9yLFxuICBQcm9taXNlV2l0aFJlc29sdmVycyxcbiAgUHJveHlQcm9taXNlLFxuICBTdWJzY3JpYmVkUHJvbWlzZSxcbn0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLyoqIE1lbW9yeSBzYWZlICh3ZWFrbWFwcGVkKSBjYWNoZSBvZiB0aGUgUHJveHlQcm9taXNlIGZvciBlYWNoIFByb21pc2UsXG4gKiB3aGljaCBpcyByZXRhaW5lZCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBvcmlnaW5hbCBQcm9taXNlLlxuICovXG5jb25zdCBzdWJzY3JpYmFibGVDYWNoZSA9IG5ldyBXZWFrTWFwPFxuICBQcm9taXNlTGlrZTx1bmtub3duPixcbiAgUHJveHlQcm9taXNlPHVua25vd24+XG4+KCk7XG5cbi8qKiBBIE5PT1AgZnVuY3Rpb24gYWxsb3dpbmcgYSBjb25zaXN0ZW50IGludGVyZmFjZSBmb3Igc2V0dGxlZFxuICogU3Vic2NyaWJlZFByb21pc2VzIChzZXR0bGVkIHByb21pc2VzIGFyZSBub3Qgc3Vic2NyaWJlZCAtIHRoZXkgcmVzb2x2ZVxuICogaW1tZWRpYXRlbHkpLiAqL1xuY29uc3QgTk9PUCA9ICgpID0+IHtcbiAgLy8gbm9vcFxufTtcblxuLyoqXG4gKiBFdmVyeSBgUHJvbWlzZTxUPmAgY2FuIGJlIHNoYWRvd2VkIGJ5IGEgc2luZ2xlIGBQcm94eVByb21pc2U8VD5gLiBJdCBpc1xuICogY3JlYXRlZCBvbmNlLCBjYWNoZWQgYW5kIHJldXNlZCB0aHJvdWdob3V0IHRoZSBsaWZldGltZSBvZiB0aGUgUHJvbWlzZS4gR2V0IGFcbiAqIFByb21pc2UncyBQcm94eVByb21pc2UgdXNpbmcgYFVucHJvbWlzZS5wcm94eShwcm9taXNlKWAuXG4gKlxuICogVGhlIGBQcm94eVByb21pc2U8VD5gIGF0dGFjaGVzIGhhbmRsZXJzIHRvIHRoZSBvcmlnaW5hbCBgUHJvbWlzZTxUPmBcbiAqIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBqdXN0IG9uY2UuIFByb21pc2VzIGRlcml2ZWQgZnJvbSBpdCB1c2UgYVxuICogc3Vic2NyaXB0aW9uLSAoYW5kIHVuc3Vic2NyaXB0aW9uLSkgYmFzZWQgbWVjaGFuaXNtIHRoYXQgbW9uaXRvcnMgdGhlc2VcbiAqIGhhbmRsZXJzLlxuICpcbiAqIEV2ZXJ5IHRpbWUgeW91IGNhbGwgYC5zdWJzY3JpYmUoKWAsIGAudGhlbigpYCBgLmNhdGNoKClgIG9yIGAuZmluYWxseSgpYCBvbiBhXG4gKiBgUHJveHlQcm9taXNlPFQ+YCBpdCByZXR1cm5zIGEgYFN1YnNjcmliZWRQcm9taXNlPFQ+YCBoYXZpbmcgYW4gYWRkaXRpb25hbFxuICogYHVuc3Vic2NyaWJlKClgIG1ldGhvZC4gQ2FsbGluZyBgdW5zdWJzY3JpYmUoKWAgZGV0YWNoZXMgcmVmZXJlbmNlIGNoYWluc1xuICogZnJvbSB0aGUgb3JpZ2luYWwsIHBvdGVudGlhbGx5IGxvbmctbGl2ZWQgUHJvbWlzZSwgZWxpbWluYXRpbmcgbWVtb3J5IGxlYWtzLlxuICpcbiAqIFRoaXMgYXBwcm9hY2ggY2FuIGVsaW1pbmF0ZSB0aGUgbWVtb3J5IGxlYWtzIHRoYXQgb3RoZXJ3aXNlIGNvbWUgYWJvdXQgZnJvbVxuICogcmVwZWF0ZWQgYHJhY2UoKWAgb3IgYGFueSgpYCBjYWxscyBpbnZva2luZyBgLnRoZW4oKWAgYW5kIGAuY2F0Y2goKWAgbXVsdGlwbGVcbiAqIHRpbWVzIG9uIHRoZSBzYW1lIGxvbmctbGl2ZWQgbmF0aXZlIFByb21pc2UgKHN1YnNjcmlwdGlvbnMgd2hpY2ggY2FuIG5ldmVyIGJlXG4gKiBjbGVhbmVkIHVwKS5cbiAqXG4gKiBgVW5wcm9taXNlLnJhY2UocHJvbWlzZXMpYCBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBgUHJvbWlzZS5yYWNlYFxuICogYXZvaWRpbmcgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgbG9uZy1saXZlZCB1bnNldHRsZWQgUHJvbWlzZXMuXG4gKlxuICogYFVucHJvbWlzZS5hbnkocHJvbWlzZXMpYCBpcyBhIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiBvZiBgUHJvbWlzZS5hbnlgXG4gKiBhdm9pZGluZyBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyBsb25nLWxpdmVkIHVuc2V0dGxlZCBQcm9taXNlcy5cbiAqXG4gKiBgVW5wcm9taXNlLnJlc29sdmUocHJvbWlzZSlgIHJldHVybnMgYW4gZXBoZW1lcmFsIGBTdWJzY3JpYmVkUHJvbWlzZTxUPmAgZm9yXG4gKiBhbnkgZ2l2ZW4gYFByb21pc2U8VD5gIGZhY2lsaXRhdGluZyBhcmJpdHJhcnkgYXN5bmMvYXdhaXQgcGF0dGVybnMuIEJlaGluZFxuICogdGhlIHNjZW5lcywgYHJlc29sdmVgIGlzIGltcGxlbWVudGVkIHNpbXBseSBhc1xuICogYFVucHJvbWlzZS5wcm94eShwcm9taXNlKS5zdWJzY3JpYmUoKWAuIERvbid0IGZvcmdldCB0byBjYWxsIGAudW5zdWJzY3JpYmUoKWBcbiAqIHRvIHRpZHkgdXAhXG4gKlxuICovXG5leHBvcnQgY2xhc3MgVW5wcm9taXNlPFQ+IGltcGxlbWVudHMgUHJveHlQcm9taXNlPFQ+IHtcbiAgLyoqIElOU1RBTkNFIElNUExFTUVOVEFUSU9OICovXG5cbiAgLyoqIFRoZSBwcm9taXNlIHNoYWRvd2VkIGJ5IHRoaXMgVW5wcm9taXNlPFQ+ICAqL1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcHJvbWlzZTogUHJvbWlzZTxUPiB8IFByb21pc2VMaWtlPFQ+O1xuXG4gIC8qKiBQcm9taXNlcyBleHBlY3RpbmcgZXZlbnR1YWwgc2V0dGxlbWVudCAodW5sZXNzIHVuc3Vic2NyaWJlZCBmaXJzdCkuIFRoaXMgbGlzdCBpcyBkZWxldGVkXG4gICAqIGFmdGVyIHRoZSBvcmlnaW5hbCBwcm9taXNlIHNldHRsZXMgLSBubyBmdXJ0aGVyIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBpc3N1ZWQuICovXG4gIHByb3RlY3RlZCBzdWJzY3JpYmVyczogUmVhZG9ubHlBcnJheTxQcm9taXNlV2l0aFJlc29sdmVyczxUPj4gfCBudWxsID0gW107XG5cbiAgLyoqIFRoZSBQcm9taXNlJ3Mgc2V0dGxlbWVudCAocmVjb3JkZWQgd2hlbiBpdCBmdWxmaWxzIG9yIHJlamVjdHMpLiBUaGlzIGlzIGNvbnN1bHRlZCB3aGVuXG4gICAqIGNhbGxpbmcgLnN1YnNjcmliZSgpIC50aGVuKCkgLmNhdGNoKCkgLmZpbmFsbHkoKSB0byBzZWUgaWYgYW4gaW1tZWRpYXRlbHktcmVzb2x2aW5nIFByb21pc2VcbiAgICogY2FuIGJlIHJldHVybmVkLCBhbmQgdGhlcmVmb3JlIHN1YnNjcmlwdGlvbiBjYW4gYmUgYnlwYXNzZWQuICovXG4gIHByb3RlY3RlZCBzZXR0bGVtZW50OiBQcm9taXNlU2V0dGxlZFJlc3VsdDxUPiB8IG51bGwgPSBudWxsO1xuXG4gIC8qKiBDb25zdHJ1Y3RvciBhY2NlcHRzIGEgbm9ybWFsIFByb21pc2UgZXhlY3V0b3IgZnVuY3Rpb24gbGlrZSBgbmV3XG4gICAqIFVucHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7Li4ufSlgIG9yIGFjY2VwdHMgYSBwcmUtZXhpc3RpbmcgUHJvbWlzZVxuICAgKiBsaWtlIGBuZXcgVW5wcm9taXNlKGV4aXN0aW5nUHJvbWlzZSlgLiBBZGRzIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYFxuICAgKiBoYW5kbGVycyB0byB0aGUgUHJvbWlzZS4gVGhlc2UgaGFuZGxlcnMgcGFzcyBmdWxmaWxtZW50IGFuZCByZWplY3Rpb25cbiAgICogbm90aWZpY2F0aW9ucyB0byBkb3duc3RyZWFtIHN1YnNjcmliZXJzIGFuZCBtYWludGFpbnMgcmVjb3JkcyBvZiB2YWx1ZVxuICAgKiBvciBlcnJvciBpZiB0aGUgUHJvbWlzZSBldmVyIHNldHRsZXMuICovXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3Rvcihwcm9taXNlOiBQcm9taXNlPFQ+KTtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByb21pc2U6IFByb21pc2VMaWtlPFQ+KTtcbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGV4ZWN1dG9yOiBQcm9taXNlRXhlY3V0b3I8VD4pO1xuICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYXJnOiBQcm9taXNlPFQ+IHwgUHJvbWlzZUxpa2U8VD4gfCBQcm9taXNlRXhlY3V0b3I8VD4pIHtcbiAgICAvLyBoYW5kbGUgZWl0aGVyIGEgUHJvbWlzZSBvciBhIFByb21pc2UgZXhlY3V0b3IgZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShhcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb21pc2UgPSBhcmc7XG4gICAgfVxuXG4gICAgLy8gc3Vic2NyaWJlIGZvciBldmVudHVhbCBmdWxmaWxtZW50IGFuZCByZWplY3Rpb25cblxuICAgIC8vIGhhbmRsZSBQcm9taXNlTGlrZSBvYmplY3RzICh0aGF0IGF0IGxlYXN0IGhhdmUgLnRoZW4pXG4gICAgY29uc3QgdGhlblJldHVybiA9IHRoaXMucHJvbWlzZS50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgLy8gYXRvbWljYWxseSByZWNvcmQgZnVsZmlsbWVudCBhbmQgZGV0YWNoIHN1YnNjcmliZXIgbGlzdFxuICAgICAgY29uc3QgeyBzdWJzY3JpYmVycyB9ID0gdGhpcztcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMgPSBudWxsO1xuICAgICAgdGhpcy5zZXR0bGVtZW50ID0ge1xuICAgICAgICBzdGF0dXM6IFwiZnVsZmlsbGVkXCIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfTtcbiAgICAgIC8vIG5vdGlmeSBmdWxmaWxtZW50IHRvIHN1YnNjcmliZXIgbGlzdFxuICAgICAgc3Vic2NyaWJlcnM/LmZvckVhY2goKHsgcmVzb2x2ZSB9KSA9PiB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBoYW5kbGUgUHJvbWlzZSAodGhhdCBhbHNvIGhhdmUgYSAuY2F0Y2ggYmVoYXZpb3VyKVxuICAgIGlmIChcImNhdGNoXCIgaW4gdGhlblJldHVybikge1xuICAgICAgdGhlblJldHVybi5jYXRjaCgocmVhc29uKSA9PiB7XG4gICAgICAgIC8vIGF0b21pY2FsbHkgcmVjb3JkIHJlamVjdGlvbiBhbmQgZGV0YWNoIHN1YnNjcmliZXIgbGlzdFxuICAgICAgICBjb25zdCB7IHN1YnNjcmliZXJzIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXR0bGVtZW50ID0ge1xuICAgICAgICAgIHN0YXR1czogXCJyZWplY3RlZFwiLFxuICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbm90aWZ5IHJlamVjdGlvbiB0byBzdWJzY3JpYmVyIGxpc3RcbiAgICAgICAgc3Vic2NyaWJlcnM/LmZvckVhY2goKHsgcmVqZWN0IH0pID0+IHtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IG1pdGlnYXRlcyB1bmNvbnRyb2xsZWQgc3Vic2NyaXB0aW9uIHRvIGEgbG9uZy1saXZlZFxuICAgKiBQcm9taXNlIHZpYSAudGhlbigpIGFuZCAuY2F0Y2goKSAtIG90aGVyd2lzZSBhIHNvdXJjZSBvZiBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBwcm9taXNlIGhhcyBhbiBgdW5zdWJzY3JpYmUoKWAgbWV0aG9kIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2hlblxuICAgKiB0aGUgUHJvbWlzZSBpcyBubyBsb25nZXIgYmVpbmcgdHJhY2tlZCBieSBhcHBsaWNhdGlvbiBsb2dpYywgYW5kIHdoaWNoXG4gICAqIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBubyByZWZlcmVuY2UgY2hhaW4gZnJvbSB0aGUgb3JpZ2luYWwgcHJvbWlzZSB0byB0aGVcbiAgICogbmV3IG9uZSwgYW5kIHRoZXJlZm9yZSBubyBtZW1vcnkgbGVhay5cbiAgICpcbiAgICogSWYgb3JpZ2luYWwgcHJvbWlzZSBoYXMgbm90IHlldCBzZXR0bGVkLCB0aGlzIGFkZHMgYSBuZXcgdW5pcXVlIHByb21pc2VcbiAgICogdGhhdCBsaXN0ZW5zIHRvIHRoZW4vY2F0Y2ggZXZlbnRzLCBhbG9uZyB3aXRoIGFuIGB1bnN1YnNjcmliZSgpYCBtZXRob2QgdG9cbiAgICogZGV0YWNoIGl0LlxuICAgKlxuICAgKiBJZiBvcmlnaW5hbCBwcm9taXNlIGhhcyBzZXR0bGVkLCB0aGVuIGNyZWF0ZXMgYSBuZXcgUHJvbWlzZS5yZXNvbHZlKCkgb3JcbiAgICogUHJvbWlzZS5yZWplY3QoKSBhbmQgcHJvdmlkZWQgdW5zdWJzY3JpYmUgaXMgYSBub29wLlxuICAgKlxuICAgKiBJZiB5b3UgY2FsbCBgdW5zdWJzY3JpYmUoKWAgYmVmb3JlIHRoZSByZXR1cm5lZCBQcm9taXNlIGhhcyBzZXR0bGVkLCBpdFxuICAgKiB3aWxsIG5ldmVyIHNldHRsZS5cbiAgICovXG4gIHN1YnNjcmliZSgpOiBTdWJzY3JpYmVkUHJvbWlzZTxUPiB7XG4gICAgLy8gaW4gYWxsIGNhc2VzIHdlIHdpbGwgY29tYmluZSBzb21lIHByb21pc2Ugd2l0aCBpdHMgdW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgICBsZXQgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQ7XG5cbiAgICBjb25zdCB7IHNldHRsZW1lbnQgfSA9IHRoaXM7XG4gICAgaWYgKHNldHRsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIG5vdCB5ZXQgc2V0dGxlZCAtIHN1YnNjcmliZSBuZXcgcHJvbWlzZS4gRXhwZWN0IGV2ZW50dWFsIHNldHRsZW1lbnRcbiAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJzID09PSBudWxsKSB7XG4gICAgICAgIC8vIGludmFyaWFudCAtIGl0IGlzIG5vdCBzZXR0bGVkLCBzbyBpdCBtdXN0IGhhdmUgc3Vic2NyaWJlcnNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5wcm9taXNlIHNldHRsZWQgYnV0IHN0aWxsIGhhcyBzdWJzY3JpYmVyc1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnNjcmliZXIgPSB3aXRoUmVzb2x2ZXJzPFQ+KCk7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzID0gbGlzdFdpdGhNZW1iZXIodGhpcy5zdWJzY3JpYmVycywgc3Vic2NyaWJlcik7XG4gICAgICBwcm9taXNlID0gc3Vic2NyaWJlci5wcm9taXNlO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRob3V0TWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXR0bGVkIC0gZG9uJ3QgY3JlYXRlIHN1YnNjcmliZWQgcHJvbWlzZS4gSnVzdCByZXNvbHZlIG9yIHJlamVjdFxuICAgICAgY29uc3QgeyBzdGF0dXMgfSA9IHNldHRsZW1lbnQ7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoc2V0dGxlbWVudC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZWplY3Qoc2V0dGxlbWVudC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgdW5zdWJzY3JpYmUgPSBOT09QO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBwcm9taXNlIHNpZ25hdHVyZSB3aXRoIHRoZSBleHRyYSBtZXRob2RcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7IHVuc3Vic2NyaWJlIH0pO1xuICB9XG5cbiAgLyoqIFNUQU5EQVJEIFBST01JU0UgTUVUSE9EUyAoYnV0IHJldHVybmluZyBhIFN1YnNjcmliZWRQcm9taXNlKSAqL1xuXG4gIHRoZW48VFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgICBvbmZ1bGZpbGxlZD86XG4gICAgICB8ICgodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KVxuICAgICAgfCBudWxsXG4gICAgICAgLFxuICAgIG9ucmVqZWN0ZWQ/OlxuICAgICAgfCAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0MiB8IFByb21pc2VMaWtlPFRSZXN1bHQyPilcbiAgICAgIHwgbnVsbFxuICAgICAgIFxuICApOiBTdWJzY3JpYmVkUHJvbWlzZTxUUmVzdWx0MSB8IFRSZXN1bHQyPiB7XG4gICAgY29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG4gICAgY29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpLCB7XG4gICAgICB1bnN1YnNjcmliZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNhdGNoPFRSZXN1bHQgPSBuZXZlcj4oXG4gICAgb25yZWplY3RlZD86XG4gICAgICB8ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQgfCBQcm9taXNlTGlrZTxUUmVzdWx0PilcbiAgICAgIHwgbnVsbFxuICAgICAgIFxuICApOiBTdWJzY3JpYmVkUHJvbWlzZTxUIHwgVFJlc3VsdD4ge1xuICAgIGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLnN1YnNjcmliZSgpO1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHN1YnNjcmliZWQ7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3Vic2NyaWJlZC5jYXRjaChvbnJlamVjdGVkKSwge1xuICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfSk7XG4gIH1cblxuICBmaW5hbGx5KG9uZmluYWxseT86ICgoKSA9PiB2b2lkKSB8IG51bGwgICk6IFN1YnNjcmliZWRQcm9taXNlPFQ+IHtcbiAgICBjb25zdCBzdWJzY3JpYmVkID0gdGhpcy5zdWJzY3JpYmUoKTtcbiAgICBjb25zdCB7IHVuc3Vic2NyaWJlIH0gPSBzdWJzY3JpYmVkO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN1YnNjcmliZWQuZmluYWxseShvbmZpbmFsbHkpLCB7XG4gICAgICB1bnN1YnNjcmliZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBUT1NUUklORyBTVVBQT1JUICovXG5cbiAgcmVhZG9ubHkgW1N5bWJvbC50b1N0cmluZ1RhZ10gPSBcIlVucHJvbWlzZVwiO1xuXG4gIC8qKiBVbnByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblxuICAvKiogQ3JlYXRlIG9yIFJldHJpZXZlIHRoZSBwcm94eSBVbnByb21pc2UgKGEgcmUtdXNlZCBVbnByb21pc2UgZm9yIHRoZSBWTSBsaWZldGltZVxuICAgKiBvZiB0aGUgcHJvdmlkZWQgUHJvbWlzZSByZWZlcmVuY2UpICovXG4gIHN0YXRpYyBwcm94eTxUPihwcm9taXNlOiBQcm9taXNlTGlrZTxUPik6IFByb3h5UHJvbWlzZTxUPiB7XG4gICAgY29uc3QgY2FjaGVkID0gVW5wcm9taXNlLmdldFN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSk7XG4gICAgcmV0dXJuIHR5cGVvZiBjYWNoZWQgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgID8gY2FjaGVkXG4gICAgICA6IFVucHJvbWlzZS5jcmVhdGVTdWJzY3JpYmFibGVQcm9taXNlKHByb21pc2UpO1xuICB9XG5cbiAgLyoqIENyZWF0ZSBhbmQgc3RvcmUgYW4gVW5wcm9taXNlIGtleWVkIGJ5IGFuIG9yaWdpbmFsIFByb21pc2UuICovXG4gIHByb3RlY3RlZCBzdGF0aWMgY3JlYXRlU3Vic2NyaWJhYmxlUHJvbWlzZTxUPihwcm9taXNlOiBQcm9taXNlTGlrZTxUPikge1xuICAgIGNvbnN0IGNyZWF0ZWQgPSBuZXcgVW5wcm9taXNlPFQ+KHByb21pc2UpO1xuICAgIHN1YnNjcmliYWJsZUNhY2hlLnNldChwcm9taXNlLCBjcmVhdGVkIGFzIFVucHJvbWlzZTx1bmtub3duPik7IC8vIHJlc29sdmUgcHJvbWlzZSB0byB1bnByb21pc2VcbiAgICBzdWJzY3JpYmFibGVDYWNoZS5zZXQoY3JlYXRlZCwgY3JlYXRlZCBhcyBVbnByb21pc2U8dW5rbm93bj4pOyAvLyByZXNvbHZlIHRoZSB1bnByb21pc2UgdG8gaXRzZWxmXG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvKiogUmV0cmlldmUgYSBwcmV2aW91c2x5LWNyZWF0ZWQgVW5wcm9taXNlIGtleWVkIGJ5IGFuIG9yaWdpbmFsIFByb21pc2UuICovXG4gIHByb3RlY3RlZCBzdGF0aWMgZ2V0U3Vic2NyaWJhYmxlUHJvbWlzZTxUPihwcm9taXNlOiBQcm9taXNlTGlrZTxUPikge1xuICAgIHJldHVybiBzdWJzY3JpYmFibGVDYWNoZS5nZXQocHJvbWlzZSkgYXMgUHJveHlQcm9taXNlPFQ+IHwgdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqIFByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblxuICAvKiogTG9va3VwIHRoZSBVbnByb21pc2UgZm9yIHRoaXMgcHJvbWlzZSwgYW5kIGRlcml2ZSBhIFN1YnNjcmliZWRQcm9taXNlIGZyb21cbiAgICogaXQgKHRoYXQgY2FuIGJlIGxhdGVyIHVuc3Vic2NyaWJlZCB0byBlbGltaW5hdGUgTWVtb3J5IGxlYWtzKSAqL1xuICBzdGF0aWMgcmVzb2x2ZTxUPih2YWx1ZTogVCB8IFByb21pc2VMaWtlPFQ+KSB7XG4gICAgY29uc3QgcHJvbWlzZTogUHJvbWlzZUxpa2U8VD4gPVxuICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgXCJ0aGVuXCIgaW4gdmFsdWUgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyB2YWx1ZVxuICAgICAgICA6IFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS5zdWJzY3JpYmUoKSBhcyBTdWJzY3JpYmVkUHJvbWlzZTxcbiAgICAgIEF3YWl0ZWQ8VD5cbiAgICA+O1xuICB9XG5cbiAgLyoqIFBlcmZvcm0gUHJvbWlzZS5hbnkoKSB2aWEgU3Vic2NyaWJlZFByb21pc2VzLCB0aGVuIHVuc3Vic2NyaWJlIHRoZW0uXG4gICAqIEVxdWl2YWxlbnQgdG8gUHJvbWlzZS5hbnkgYnV0IGVsaW1pbmF0ZXMgbWVtb3J5IGxlYWtzIGZyb20gbG9uZy1saXZlZFxuICAgKiBwcm9taXNlcyBhY2N1bXVsYXRpbmcgLnRoZW4oKSBhbmQgLmNhdGNoKCkgc3Vic2NyaWJlcnMuICovXG4gIHN0YXRpYyBhc3luYyBhbnk8VCBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXSB8IFtdPihcbiAgICB2YWx1ZXM6IFRcbiAgKTogUHJvbWlzZTxBd2FpdGVkPFRbbnVtYmVyXT4+O1xuICBzdGF0aWMgYXN5bmMgYW55PFQ+KFxuICAgIHZhbHVlczogSXRlcmFibGU8VCB8IFByb21pc2VMaWtlPFQ+PlxuICApOiBQcm9taXNlPEF3YWl0ZWQ8VD4+IHtcbiAgICBjb25zdCB2YWx1ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFsuLi52YWx1ZXNdO1xuICAgIGNvbnN0IHN1YnNjcmliZWRQcm9taXNlcyA9IHZhbHVlc0FycmF5Lm1hcChVbnByb21pc2UucmVzb2x2ZSk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFueShzdWJzY3JpYmVkUHJvbWlzZXMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzdWJzY3JpYmVkUHJvbWlzZXMuZm9yRWFjaCgoeyB1bnN1YnNjcmliZSB9KSA9PiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogUGVyZm9ybSBQcm9taXNlLnJhY2UgdmlhIFN1YnNjcmliZWRQcm9taXNlcywgdGhlbiB1bnN1YnNjcmliZSB0aGVtLlxuICAgKiBFcXVpdmFsZW50IHRvIFByb21pc2UucmFjZSBidXQgZWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkXG4gICAqIHByb21pc2VzIGFjY3VtdWxhdGluZyAudGhlbigpIGFuZCAuY2F0Y2goKSBzdWJzY3JpYmVycy4gKi9cbiAgc3RhdGljIGFzeW5jIHJhY2U8VCBleHRlbmRzIHJlYWRvbmx5IHVua25vd25bXSB8IFtdPihcbiAgICB2YWx1ZXM6IFRcbiAgKTogUHJvbWlzZTxBd2FpdGVkPFRbbnVtYmVyXT4+O1xuICBzdGF0aWMgYXN5bmMgcmFjZTxUPihcbiAgICB2YWx1ZXM6IEl0ZXJhYmxlPFQgfCBQcm9taXNlTGlrZTxUPj5cbiAgKTogUHJvbWlzZTxBd2FpdGVkPFQ+PiB7XG4gICAgY29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbLi4udmFsdWVzXTtcbiAgICBjb25zdCBzdWJzY3JpYmVkUHJvbWlzZXMgPSB2YWx1ZXNBcnJheS5tYXAoVW5wcm9taXNlLnJlc29sdmUpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKHN1YnNjcmliZWRQcm9taXNlcyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHN1YnNjcmliZWRQcm9taXNlcy5mb3JFYWNoKCh7IHVuc3Vic2NyaWJlIH0pID0+IHtcbiAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDcmVhdGUgYSByYWNlIG9mIFN1YnNjcmliZWRQcm9taXNlcyB0aGF0IHdpbGwgZnVsZmlsIHRvIGEgc2luZ2xlIHdpbm5pbmdcbiAgICogUHJvbWlzZSAoaW4gYSAxLVR1cGxlKS4gRWxpbWluYXRlcyBtZW1vcnkgbGVha3MgZnJvbSBsb25nLWxpdmVkIHByb21pc2VzXG4gICAqIGFjY3VtdWxhdGluZyAudGhlbigpIGFuZCAuY2F0Y2goKSBzdWJzY3JpYmVycy4gQWxsb3dzIHNpbXBsZSBsb2dpYyB0b1xuICAgKiBjb25zdW1lIHRoZSByZXN1bHQsIGxpa2UuLi5cbiAgICogYGBgdHNcbiAgICogY29uc3QgWyB3aW5uZXIgXSA9IGF3YWl0IFVucHJvbWlzZS5yYWNlKFsgcHJvbWlzZUEsIHByb21pc2VCIF0pO1xuICAgKiBpZih3aW5uZXIgPT09IHByb21pc2VCKXtcbiAgICogICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlQjtcbiAgICogICAvLyBkbyB0aGUgdGhpbmdcbiAgICogfVxuICAgKiBgYGBcbiAgICogKi9cbiAgc3RhdGljIGFzeW5jIHJhY2VSZWZlcmVuY2VzPFRQcm9taXNlIGV4dGVuZHMgUHJvbWlzZTx1bmtub3duPj4oXG4gICAgcHJvbWlzZXM6IHJlYWRvbmx5IFRQcm9taXNlW11cbiAgKSB7XG4gICAgLy8gbWFwIGVhY2ggcHJvbWlzZSB0byBhbiBldmVudHVhbCAxLXR1cGxlIGNvbnRhaW5pbmcgaXRzZWxmXG4gICAgY29uc3Qgc2VsZlByb21pc2VzID0gcHJvbWlzZXMubWFwKHJlc29sdmVTZWxmVHVwbGUpO1xuXG4gICAgLy8gbm93IHJhY2UgdGhlbS4gVGhleSB3aWxsIGZ1bGZpbCB0byBhIHJlYWRvbmx5IFtQXSBvciByZWplY3QuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2Uoc2VsZlByb21pc2VzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZm9yIChjb25zdCBwcm9taXNlIG9mIHNlbGZQcm9taXNlcykge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBwcm94eSBwcm9taXNlcyB3aGVuIHRoZSByYWNlIGlzIG92ZXIgdG8gbWl0aWdhdGUgbWVtb3J5IGxlYWtzXG4gICAgICAgIHByb21pc2UudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIFByb21pc2VzIGEgMS10dXBsZSBjb250YWluaW5nIHRoZSBvcmlnaW5hbCBwcm9taXNlIHdoZW4gaXQgcmVzb2x2ZXMuIEFsbG93c1xuICogYXdhaXRpbmcgdGhlIGV2ZW50dWFsIFByb21pc2UgKioqcmVmZXJlbmNlKioqIChlYXN5IHRvIGRlc3RydWN0dXJlIGFuZFxuICogZXhhY3RseSBjb21wYXJlIHdpdGggPT09KS4gQXZvaWRzIHJlc29sdmluZyB0byB0aGUgUHJvbWlzZSAqKip2YWx1ZSoqKiAod2hpY2hcbiAqIG1heSBiZSBhbWJpZ3VvdXMgYW5kIHRoZXJlZm9yZSBoYXJkIHRvIGlkZW50aWZ5IGFzIHRoZSB3aW5uZXIgb2YgYSByYWNlKS5cbiAqIFlvdSBjYW4gY2FsbCB1bnN1YnNjcmliZSBvbiB0aGUgUHJvbWlzZSB0byBtaXRpZ2F0ZSBtZW1vcnkgbGVha3MuXG4gKiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVTZWxmVHVwbGU8VFByb21pc2UgZXh0ZW5kcyBQcm9taXNlPHVua25vd24+PihcbiAgcHJvbWlzZTogVFByb21pc2Vcbik6IFN1YnNjcmliZWRQcm9taXNlPHJlYWRvbmx5IFtUUHJvbWlzZV0+IHtcbiAgcmV0dXJuIFVucHJvbWlzZS5wcm94eShwcm9taXNlKS50aGVuKCgpID0+IFtwcm9taXNlXSBhcyBjb25zdCk7XG59XG5cbi8qKiBWRU5ET1JFRCAoRnV0dXJlKSBQUk9NSVNFIFVUSUxJVElFUyAqL1xuXG4vKiogUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2Utd2l0aC1yZXNvbHZlcnMgKi9cbmZ1bmN0aW9uIHdpdGhSZXNvbHZlcnM8VD4oKTogUHJvbWlzZVdpdGhSZXNvbHZlcnM8VD4ge1xuICBsZXQgcmVzb2x2ZSE6IFByb21pc2VXaXRoUmVzb2x2ZXJzPFQ+W1wicmVzb2x2ZVwiXTtcbiAgbGV0IHJlamVjdCE6IFByb21pc2VXaXRoUmVzb2x2ZXJzPFQ+W1wicmVqZWN0XCJdO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgIHJlamVjdCA9IF9yZWplY3Q7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZSxcbiAgICByZWplY3QsXG4gIH07XG59XG5cbi8qKiBJTU1VVEFCTEUgTElTVCBPUEVSQVRJT05TICovXG5cbmZ1bmN0aW9uIGxpc3RXaXRoTWVtYmVyPFQ+KGFycjogcmVhZG9ubHkgVFtdLCBtZW1iZXI6IFQpOiByZWFkb25seSBUW10ge1xuICByZXR1cm4gWy4uLmFyciwgbWVtYmVyXTtcbn1cblxuZnVuY3Rpb24gbGlzdFdpdGhvdXRJbmRleDxUPihhcnI6IHJlYWRvbmx5IFRbXSwgaW5kZXg6IG51bWJlcikge1xuICByZXR1cm4gWy4uLmFyci5zbGljZSgwLCBpbmRleCksIC4uLmFyci5zbGljZShpbmRleCArIDEpXTtcbn1cblxuZnVuY3Rpb24gbGlzdFdpdGhvdXRNZW1iZXI8VD4oYXJyOiByZWFkb25seSBUW10sIG1lbWJlcjogdW5rbm93bikge1xuICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKG1lbWJlciBhcyBUKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBsaXN0V2l0aG91dEluZGV4KGFyciwgaW5kZXgpO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG4iLCIvLyBAdHMtZXhwZWN0LWVycm9yIC0gcG9seWZpbGxpbmcgc3ltYm9sXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcblN5bWJvbC5kaXNwb3NlID8/PSBTeW1ib2woKTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvciAtIHBvbHlmaWxsaW5nIHN5bWJvbFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG5TeW1ib2wuYXN5bmNEaXNwb3NlID8/PSBTeW1ib2woKTtcblxuLyoqXG4gKiBUYWtlcyBhIHZhbHVlIGFuZCBhIGRpc3Bvc2UgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgRGlzcG9zYWJsZSBpbnRlcmZhY2UuXG4gKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCB2YWx1ZSBhdWdtZW50ZWQgd2l0aCBhIFN5bWJvbC5kaXNwb3NlIG1ldGhvZC5cbiAqIEBwYXJhbSB0aGluZyBUaGUgdmFsdWUgdG8gbWFrZSBkaXNwb3NhYmxlXG4gKiBAcGFyYW0gZGlzcG9zZSBGdW5jdGlvbiB0byBjYWxsIHdoZW4gZGlzcG9zaW5nIHRoZSByZXNvdXJjZVxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmRpc3Bvc2UgbWV0aG9kIGFkZGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVzb3VyY2U8VD4odGhpbmc6IFQsIGRpc3Bvc2U6ICgpID0+IHZvaWQpOiBUICYgRGlzcG9zYWJsZSB7XG4gIGNvbnN0IGl0ID0gdGhpbmcgYXMgVCAmIFBhcnRpYWw8RGlzcG9zYWJsZT47XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmRpc3Bvc2VdO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICBpdFtTeW1ib2wuZGlzcG9zZV0gPSAoKSA9PiB7XG4gICAgZGlzcG9zZSgpO1xuICAgIGV4aXN0aW5nPy4oKTtcbiAgfTtcblxuICByZXR1cm4gaXQgYXMgVCAmIERpc3Bvc2FibGU7XG59XG5cbi8qKlxuICogVGFrZXMgYSB2YWx1ZSBhbmQgYW4gYXN5bmMgZGlzcG9zZSBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBBc3luY0Rpc3Bvc2FibGUgaW50ZXJmYWNlLlxuICogVGhlIHJldHVybmVkIG9iamVjdCBpcyB0aGUgb3JpZ2luYWwgdmFsdWUgYXVnbWVudGVkIHdpdGggYSBTeW1ib2wuYXN5bmNEaXNwb3NlIG1ldGhvZC5cbiAqIEBwYXJhbSB0aGluZyBUaGUgdmFsdWUgdG8gbWFrZSBhc3luYyBkaXNwb3NhYmxlXG4gKiBAcGFyYW0gZGlzcG9zZSBBc3luYyBmdW5jdGlvbiB0byBjYWxsIHdoZW4gZGlzcG9zaW5nIHRoZSByZXNvdXJjZVxuICogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmFzeW5jRGlzcG9zZSBtZXRob2QgYWRkZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VBc3luY1Jlc291cmNlPFQ+KFxuICB0aGluZzogVCxcbiAgZGlzcG9zZTogKCkgPT4gUHJvbWlzZTx2b2lkPixcbik6IFQgJiBBc3luY0Rpc3Bvc2FibGUge1xuICBjb25zdCBpdCA9IHRoaW5nIGFzIFQgJiBQYXJ0aWFsPEFzeW5jRGlzcG9zYWJsZT47XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmFzeW5jRGlzcG9zZV07XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGl0W1N5bWJvbC5hc3luY0Rpc3Bvc2VdID0gYXN5bmMgKCkgPT4ge1xuICAgIGF3YWl0IGRpc3Bvc2UoKTtcbiAgICBhd2FpdCBleGlzdGluZz8uKCk7XG4gIH07XG5cbiAgcmV0dXJuIGl0IGFzIFQgJiBBc3luY0Rpc3Bvc2FibGU7XG59XG4iLCJpbXBvcnQgeyBtYWtlUmVzb3VyY2UgfSBmcm9tICcuL2Rpc3Bvc2FibGUnO1xuXG5leHBvcnQgY29uc3QgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCA9IFN5bWJvbCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJSZXNvdXJjZShtczogbnVtYmVyKSB7XG4gIGxldCB0aW1lcjogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD4gfCBudWxsID0gbnVsbDtcblxuICByZXR1cm4gbWFrZVJlc291cmNlKFxuICAgIHtcbiAgICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVyIGFscmVhZHkgc3RhcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlPHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0PihcbiAgICAgICAgICAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUoZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCksIG1zKTtcbiAgICAgICAgICB9LFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9LFxuICApO1xufVxuIiwiZnVuY3Rpb24gX3VzaW5nQ3R4KCkge1xuICB2YXIgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKHIsIGUpIHtcbiAgICAgIHZhciBuID0gRXJyb3IoKTtcbiAgICAgIHJldHVybiBuLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBuLmVycm9yID0gciwgbi5zdXBwcmVzc2VkID0gZSwgbjtcbiAgICB9LFxuICAgIGUgPSB7fSxcbiAgICBuID0gW107XG4gIGZ1bmN0aW9uIHVzaW5nKHIsIGUpIHtcbiAgICBpZiAobnVsbCAhPSBlKSB7XG4gICAgICBpZiAoT2JqZWN0KGUpICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNpbmcgZGVjbGFyYXRpb25zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBvYmplY3RzLCBmdW5jdGlvbnMsIG51bGwsIG9yIHVuZGVmaW5lZC5cIik7XG4gICAgICBpZiAocikgdmFyIG8gPSBlW1N5bWJvbC5hc3luY0Rpc3Bvc2UgfHwgU3ltYm9sW1wiZm9yXCJdKFwiU3ltYm9sLmFzeW5jRGlzcG9zZVwiKV07XG4gICAgICBpZiAodm9pZCAwID09PSBvICYmIChvID0gZVtTeW1ib2wuZGlzcG9zZSB8fCBTeW1ib2xbXCJmb3JcIl0oXCJTeW1ib2wuZGlzcG9zZVwiKV0sIHIpKSB2YXIgdCA9IG87XG4gICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBkaXNwb3NhYmxlLlwiKTtcbiAgICAgIHQgJiYgKG8gPSBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHQuY2FsbChlKTtcbiAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgfVxuICAgICAgfSksIG4ucHVzaCh7XG4gICAgICAgIHY6IGUsXG4gICAgICAgIGQ6IG8sXG4gICAgICAgIGE6IHJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSByICYmIG4ucHVzaCh7XG4gICAgICBkOiBlLFxuICAgICAgYTogclxuICAgIH0pO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgZTogZSxcbiAgICB1OiB1c2luZy5iaW5kKG51bGwsICExKSxcbiAgICBhOiB1c2luZy5iaW5kKG51bGwsICEwKSxcbiAgICBkOiBmdW5jdGlvbiBkKCkge1xuICAgICAgdmFyIG8sXG4gICAgICAgIHQgPSB0aGlzLmUsXG4gICAgICAgIHMgPSAwO1xuICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgZm9yICg7IG8gPSBuLnBvcCgpOykgdHJ5IHtcbiAgICAgICAgICBpZiAoIW8uYSAmJiAxID09PSBzKSByZXR1cm4gcyA9IDAsIG4ucHVzaChvKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihuZXh0KTtcbiAgICAgICAgICBpZiAoby5kKSB7XG4gICAgICAgICAgICB2YXIgciA9IG8uZC5jYWxsKG8udik7XG4gICAgICAgICAgICBpZiAoby5hKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUocikudGhlbihuZXh0LCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSBzIHw9IDE7XG4gICAgICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgICAgICByZXR1cm4gZXJyKHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgxID09PSBzKSByZXR1cm4gdCAhPT0gZSA/IFByb21pc2UucmVqZWN0KHQpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIGlmICh0ICE9PSBlKSB0aHJvdyB0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZXJyKG4pIHtcbiAgICAgICAgcmV0dXJuIHQgPSB0ICE9PSBlID8gbmV3IHIobiwgdCkgOiBuLCBuZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3VzaW5nQ3R4LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiZnVuY3Rpb24gX092ZXJsb2FkWWllbGQoZSwgZCkge1xuICB0aGlzLnYgPSBlLCB0aGlzLmsgPSBkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfT3ZlcmxvYWRZaWVsZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbmZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yKGUpIHtcbiAgcmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkKGUsIDApO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXdhaXRBc3luY0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbmZ1bmN0aW9uIF93cmFwQXN5bmNHZW5lcmF0b3IoZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgQXN5bmNHZW5lcmF0b3IoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGUpIHtcbiAgdmFyIHIsIHQ7XG4gIGZ1bmN0aW9uIHJlc3VtZShyLCB0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBuID0gZVtyXSh0KSxcbiAgICAgICAgbyA9IG4udmFsdWUsXG4gICAgICAgIHUgPSBvIGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZDtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh1ID8gby52IDogbykudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIHZhciBpID0gXCJyZXR1cm5cIiA9PT0gciA/IFwicmV0dXJuXCIgOiBcIm5leHRcIjtcbiAgICAgICAgICBpZiAoIW8uayB8fCB0LmRvbmUpIHJldHVybiByZXN1bWUoaSwgdCk7XG4gICAgICAgICAgdCA9IGVbaV0odCkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGxlKG4uZG9uZSA/IFwicmV0dXJuXCIgOiBcIm5vcm1hbFwiLCB0KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJlc3VtZShcInRocm93XCIsIGUpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc2V0dGxlKFwidGhyb3dcIiwgZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldHRsZShlLCBuKSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwicmV0dXJuXCI6XG4gICAgICAgIHIucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgZG9uZTogITBcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRocm93XCI6XG4gICAgICAgIHIucmVqZWN0KG4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHIucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgZG9uZTogITFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIChyID0gci5uZXh0KSA/IHJlc3VtZShyLmtleSwgci5hcmcpIDogdCA9IG51bGw7XG4gIH1cbiAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24gKGUsIG4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKG8sIHUpIHtcbiAgICAgIHZhciBpID0ge1xuICAgICAgICBrZXk6IGUsXG4gICAgICAgIGFyZzogbixcbiAgICAgICAgcmVzb2x2ZTogbyxcbiAgICAgICAgcmVqZWN0OiB1LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgdCA/IHQgPSB0Lm5leHQgPSBpIDogKHIgPSB0ID0gaSwgcmVzdW1lKGUsIG4pKTtcbiAgICB9KTtcbiAgfSwgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlW1wicmV0dXJuXCJdICYmICh0aGlzW1wicmV0dXJuXCJdID0gdm9pZCAwKTtcbn1cbkFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGUpO1xufSwgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1widGhyb3dcIl0gPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwidGhyb3dcIiwgZSk7XG59LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gdGhpcy5faW52b2tlKFwicmV0dXJuXCIsIGUpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gX3dyYXBBc3luY0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsImltcG9ydCB7IFVucHJvbWlzZSB9IGZyb20gJy4uLy4uLy4uL3ZlbmRvci91bnByb21pc2UnO1xuaW1wb3J0IHsgdGhyb3dBYm9ydEVycm9yIH0gZnJvbSAnLi4vLi4vaHR0cC9hYm9ydEVycm9yJztcbmltcG9ydCB7IG1ha2VBc3luY1Jlc291cmNlIH0gZnJvbSAnLi9kaXNwb3NhYmxlJztcbmltcG9ydCB7IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQsIHRpbWVyUmVzb3VyY2UgfSBmcm9tICcuL3RpbWVyUmVzb3VyY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXRlcmF0b3JSZXNvdXJjZTxUWWllbGQsIFRSZXR1cm4sIFROZXh0PihcbiAgaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCBUUmV0dXJuLCBUTmV4dD4sXG4pOiBBc3luY0l0ZXJhdG9yPFRZaWVsZCwgVFJldHVybiwgVE5leHQ+ICYgQXN5bmNEaXNwb3NhYmxlIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblxuICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdGhpcyBpcyBhZGRlZCBpbiBub2RlIDI0IHdoaWNoIHdlIGRvbid0IG9mZmljaWFsbHkgc3VwcG9ydCB5ZXRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIGlmIChpdGVyYXRvcltTeW1ib2wuYXN5bmNEaXNwb3NlXSkge1xuICAgIHJldHVybiBpdGVyYXRvciBhcyBBc3luY0l0ZXJhdG9yPFRZaWVsZCwgVFJldHVybiwgVE5leHQ+ICYgQXN5bmNEaXNwb3NhYmxlO1xuICB9XG5cbiAgcmV0dXJuIG1ha2VBc3luY1Jlc291cmNlKGl0ZXJhdG9yLCBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuPy4oKTtcbiAgfSk7XG59XG4vKipcbiAqIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvbiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IGF1dG9tYXRpY2FsbHkgYWJvcnRzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogd2l0aE1heER1cmF0aW9uPFQ+KFxuICBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPixcbiAgb3B0czogeyBtYXhEdXJhdGlvbk1zOiBudW1iZXIgfSxcbik6IEFzeW5jR2VuZXJhdG9yPFQ+IHtcbiAgYXdhaXQgdXNpbmcgaXRlcmF0b3IgPSBpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKTtcblxuICB1c2luZyB0aW1lciA9IHRpbWVyUmVzb3VyY2Uob3B0cy5tYXhEdXJhdGlvbk1zKTtcblxuICBjb25zdCB0aW1lclByb21pc2UgPSB0aW1lci5zdGFydCgpO1xuXG4gIC8vIGRlY2xhcmF0aW9uIG91dHNpZGUgdGhlIGxvb3AgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiByZWFzb25zXG4gIGxldCByZXN1bHQ6IG51bGwgfCBJdGVyYXRvclJlc3VsdDxUPiB8IHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0O1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW2l0ZXJhdG9yLm5leHQoKSwgdGltZXJQcm9taXNlXSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkge1xuICAgICAgLy8gY2FuY2VsbGVkIGR1ZSB0byB0aW1lb3V0XG4gICAgICB0aHJvd0Fib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB5aWVsZCByZXN1bHQudmFsdWU7XG4gICAgLy8gZnJlZSB1cCByZWZlcmVuY2UgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIHJlc3VsdCA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEgbmV3IHtAbGluayBBc3luY0dlbmVyYXRvcn0gYmFzZWQgb2Yge0BsaW5rIGl0ZXJhYmxlfSwgdGhhdCB5aWVsZHMgaXRzIGZpcnN0XG4gKiB7QGxpbmsgY291bnR9IHZhbHVlcy4gVGhlbiwgYSBncmFjZSBwZXJpb2Qgb2Yge0BsaW5rIGdyYWNlUGVyaW9kTXN9IGlzIHN0YXJ0ZWQgaW4gd2hpY2ggZnVydGhlclxuICogdmFsdWVzIG1heSBzdGlsbCBjb21lIHRocm91Z2guIEFmdGVyIHRoaXMgcGVyaW9kLCB0aGUgZ2VuZXJhdG9yIGFib3J0cy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiB0YWtlV2l0aEdyYWNlPFQ+KFxuICBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUPixcbiAgb3B0czoge1xuICAgIGNvdW50OiBudW1iZXI7XG4gICAgZ3JhY2VQZXJpb2RNczogbnVtYmVyO1xuICB9LFxuKTogQXN5bmNHZW5lcmF0b3I8VD4ge1xuICBhd2FpdCB1c2luZyBpdGVyYXRvciA9IGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpO1xuXG4gIC8vIGRlY2xhcmF0aW9uIG91dHNpZGUgdGhlIGxvb3AgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiByZWFzb25zXG4gIGxldCByZXN1bHQ6IG51bGwgfCBJdGVyYXRvclJlc3VsdDxUPiB8IHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0O1xuXG4gIHVzaW5nIHRpbWVyID0gdGltZXJSZXNvdXJjZShvcHRzLmdyYWNlUGVyaW9kTXMpO1xuXG4gIGxldCBjb3VudCA9IG9wdHMuY291bnQ7XG5cbiAgbGV0IHRpbWVyUHJvbWlzZSA9IG5ldyBQcm9taXNlPHR5cGVvZiBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0PigoKSA9PiB7XG4gICAgLy8gbmV2ZXIgcmVzb2x2ZXNcbiAgfSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICByZXN1bHQgPSBhd2FpdCBVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKTtcbiAgICBpZiAocmVzdWx0ID09PSBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0KSB7XG4gICAgICB0aHJvd0Fib3J0RXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICB5aWVsZCByZXN1bHQudmFsdWU7XG4gICAgaWYgKC0tY291bnQgPT09IDApIHtcbiAgICAgIHRpbWVyUHJvbWlzZSA9IHRpbWVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8vIGZyZWUgdXAgcmVmZXJlbmNlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICByZXN1bHQgPSBudWxsO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWQ8VFZhbHVlID0gdm9pZD4oKSB7XG4gIGxldCByZXNvbHZlOiAodmFsdWU6IFRWYWx1ZSkgPT4gdm9pZDtcbiAgbGV0IHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VFZhbHVlPigocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlID0gcmVzO1xuICAgIHJlamVjdCA9IHJlajtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzb2x2ZSEsIHJlamVjdDogcmVqZWN0ISB9O1xufVxuZXhwb3J0IHR5cGUgRGVmZXJyZWQ8VFZhbHVlPiA9IFJldHVyblR5cGU8dHlwZW9mIGNyZWF0ZURlZmVycmVkPFRWYWx1ZT4+O1xuIiwiaW1wb3J0IHsgY3JlYXRlRGVmZXJyZWQgfSBmcm9tICcuL2NyZWF0ZURlZmVycmVkJztcbmltcG9ydCB7IG1ha2VBc3luY1Jlc291cmNlIH0gZnJvbSAnLi9kaXNwb3NhYmxlJztcblxudHlwZSBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCBUUmV0dXJuPiA9XG4gIHwgeyBzdGF0dXM6ICd5aWVsZCc7IHZhbHVlOiBUWWllbGQgfVxuICB8IHsgc3RhdHVzOiAncmV0dXJuJzsgdmFsdWU6IFRSZXR1cm4gfVxuICB8IHsgc3RhdHVzOiAnZXJyb3InOyBlcnJvcjogdW5rbm93biB9O1xuZnVuY3Rpb24gY3JlYXRlTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgVFJldHVybj4oXG4gIGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZCwgVFJldHVybj4sXG4gIG9uUmVzdWx0OiAocmVzdWx0OiBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCBUUmV0dXJuPikgPT4gdm9pZCxcbikge1xuICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICBsZXQgc3RhdGU6ICdpZGxlJyB8ICdwZW5kaW5nJyB8ICdkb25lJyA9ICdpZGxlJztcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHN0YXRlID0gJ2RvbmUnO1xuICAgIG9uUmVzdWx0ID0gKCkgPT4ge1xuICAgICAgLy8gbm9vcFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwdWxsKCkge1xuICAgIGlmIChzdGF0ZSAhPT0gJ2lkbGUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlID0gJ3BlbmRpbmcnO1xuXG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBuZXh0XG4gICAgICAudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgIHN0YXRlID0gJ2RvbmUnO1xuICAgICAgICAgIG9uUmVzdWx0KHsgc3RhdHVzOiAncmV0dXJuJywgdmFsdWU6IHJlc3VsdC52YWx1ZSB9KTtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlID0gJ2lkbGUnO1xuICAgICAgICBvblJlc3VsdCh7IHN0YXR1czogJ3lpZWxkJywgdmFsdWU6IHJlc3VsdC52YWx1ZSB9KTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGNhdXNlKSA9PiB7XG4gICAgICAgIG9uUmVzdWx0KHsgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogY2F1c2UgfSk7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwdWxsLFxuICAgIGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcbiAgICAgIGNsZWFudXAoKTtcbiAgICAgIGF3YWl0IGl0ZXJhdG9yLnJldHVybj8uKCk7XG4gICAgfSxcbiAgfTtcbn1cbnR5cGUgTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgVFJldHVybj4gPSBSZXR1cm5UeXBlPFxuICB0eXBlb2YgY3JlYXRlTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgVFJldHVybj5cbj47XG5cbmludGVyZmFjZSBNZXJnZWRBc3luY0l0ZXJhYmxlczxUWWllbGQ+XG4gIGV4dGVuZHMgQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQsIHVua25vd24+IHtcbiAgYWRkKGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZD4pOiB2b2lkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYXN5bmMgaXRlcmFibGUgdGhhdCBtZXJnZXMgbXVsdGlwbGUgYXN5bmMgaXRlcmFibGVzIGludG8gYSBzaW5nbGUgc3RyZWFtLlxuICogVmFsdWVzIGZyb20gdGhlIGlucHV0IGl0ZXJhYmxlcyBhcmUgeWllbGRlZCBpbiB0aGUgb3JkZXIgdGhleSByZXNvbHZlLCBzaW1pbGFyIHRvIFByb21pc2UucmFjZSgpLlxuICpcbiAqIE5ldyBpdGVyYWJsZXMgY2FuIGJlIGFkZGVkIGR5bmFtaWNhbGx5IHVzaW5nIHRoZSByZXR1cm5lZCB7QGxpbmsgTWVyZ2VkQXN5bmNJdGVyYWJsZXMuYWRkfSBtZXRob2QsIGV2ZW4gYWZ0ZXIgaXRlcmF0aW9uIGhhcyBzdGFydGVkLlxuICpcbiAqIElmIGFueSBvZiB0aGUgaW5wdXQgaXRlcmFibGVzIHRocm93cyBhbiBlcnJvciwgdGhhdCBlcnJvciB3aWxsIGJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgbWVyZ2VkIHN0cmVhbS5cbiAqIE90aGVyIGl0ZXJhYmxlcyB3aWxsIG5vdCBjb250aW51ZSB0byBiZSBwcm9jZXNzZWQuXG4gKlxuICogQHRlbXBsYXRlIFRZaWVsZCBUaGUgdHlwZSBvZiB2YWx1ZXMgeWllbGRlZCBieSB0aGUgaW5wdXQgaXRlcmFibGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFzeW5jSXRlcmFibGVzPFRZaWVsZD4oKTogTWVyZ2VkQXN5bmNJdGVyYWJsZXM8VFlpZWxkPiB7XG4gIGxldCBzdGF0ZTogJ2lkbGUnIHwgJ3BlbmRpbmcnIHwgJ2RvbmUnID0gJ2lkbGUnO1xuICBsZXQgZmx1c2hTaWduYWwgPSBjcmVhdGVEZWZlcnJlZCgpO1xuXG4gIC8qKlxuICAgKiB1c2VkIHdoaWxlIHtAbGluayBzdGF0ZX0gaXMgYGlkbGVgXG4gICAqL1xuICBjb25zdCBpdGVyYWJsZXM6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCB2b2lkLCB1bmtub3duPltdID0gW107XG4gIC8qKlxuICAgKiB1c2VkIHdoaWxlIHtAbGluayBzdGF0ZX0gaXMgYHBlbmRpbmdgXG4gICAqL1xuICBjb25zdCBpdGVyYXRvcnMgPSBuZXcgU2V0PE1hbmFnZWRJdGVyYXRvcjxUWWllbGQsIHZvaWQ+PigpO1xuXG4gIGNvbnN0IGJ1ZmZlcjogQXJyYXk8XG4gICAgW1xuICAgICAgaXRlcmF0b3I6IE1hbmFnZWRJdGVyYXRvcjxUWWllbGQsIHZvaWQ+LFxuICAgICAgcmVzdWx0OiBFeGNsdWRlPFxuICAgICAgICBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCB2b2lkPixcbiAgICAgICAgeyBzdGF0dXM6ICdyZXR1cm4nIH1cbiAgICAgID4sXG4gICAgXVxuICA+ID0gW107XG5cbiAgZnVuY3Rpb24gaW5pdEl0ZXJhYmxlKGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZCwgdm9pZCwgdW5rbm93bj4pIHtcbiAgICBpZiAoc3RhdGUgIT09ICdwZW5kaW5nJykge1xuICAgICAgLy8gc2hvdWxkbid0IGhhcHBlblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVyYXRvciA9IGNyZWF0ZU1hbmFnZWRJdGVyYXRvcihpdGVyYWJsZSwgKHJlc3VsdCkgPT4ge1xuICAgICAgaWYgKHN0YXRlICE9PSAncGVuZGluZycpIHtcbiAgICAgICAgLy8gc2hvdWxkbid0IGhhcHBlblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFtpdGVyYXRvciwgcmVzdWx0XSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JldHVybic6XG4gICAgICAgICAgaXRlcmF0b3JzLmRlbGV0ZShpdGVyYXRvcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBidWZmZXIucHVzaChbaXRlcmF0b3IsIHJlc3VsdF0pO1xuICAgICAgICAgIGl0ZXJhdG9ycy5kZWxldGUoaXRlcmF0b3IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmx1c2hTaWduYWwucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIGl0ZXJhdG9ycy5hZGQoaXRlcmF0b3IpO1xuICAgIGl0ZXJhdG9yLnB1bGwoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkKGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRZaWVsZCwgdm9pZCwgdW5rbm93bj4pIHtcbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSAnaWRsZSc6XG4gICAgICAgICAgaXRlcmFibGVzLnB1c2goaXRlcmFibGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICBpbml0SXRlcmFibGUoaXRlcmFibGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb25lJzoge1xuICAgICAgICAgIC8vIHNob3VsZG4ndCBoYXBwZW5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICBpZiAoc3RhdGUgIT09ICdpZGxlJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIHR3aWNlJyk7XG4gICAgICB9XG4gICAgICBzdGF0ZSA9ICdwZW5kaW5nJztcblxuICAgICAgYXdhaXQgdXNpbmcgX2ZpbmFsbHkgPSBtYWtlQXN5bmNSZXNvdXJjZSh7fSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBzdGF0ZSA9ICdkb25lJztcblxuICAgICAgICBjb25zdCBlcnJvcnM6IHVua25vd25bXSA9IFtdO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBBcnJheS5mcm9tKGl0ZXJhdG9ycy52YWx1ZXMoKSkubWFwKGFzeW5jIChpdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgaXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgICAgICAgZXJyb3JzLnB1c2goY2F1c2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICApO1xuICAgICAgICBidWZmZXIubGVuZ3RoID0gMDtcbiAgICAgICAgaXRlcmF0b3JzLmNsZWFyKCk7XG4gICAgICAgIGZsdXNoU2lnbmFsLnJlc29sdmUoKTtcblxuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlIChpdGVyYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBpbml0SXRlcmFibGUoaXRlcmFibGVzLnNoaWZ0KCkhKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGl0ZXJhdG9ycy5zaXplID4gMCkge1xuICAgICAgICBhd2FpdCBmbHVzaFNpZ25hbC5wcm9taXNlO1xuXG4gICAgICAgIHdoaWxlIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgY29uc3QgW2l0ZXJhdG9yLCByZXN1bHRdID0gYnVmZmVyLnNoaWZ0KCkhO1xuXG4gICAgICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICd5aWVsZCc6XG4gICAgICAgICAgICAgIHlpZWxkIHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgaXRlcmF0b3IucHVsbCgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmbHVzaFNpZ25hbCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfTtcbn1cbiIsIi8qKlxuICogQ3JlYXRlcyBhIFJlYWRhYmxlU3RyZWFtIGZyb20gYW4gQXN5bmNJdGVyYWJsZS5cbiAqXG4gKiBAcGFyYW0gaXRlcmFibGUgLSBUaGUgc291cmNlIEFzeW5jSXRlcmFibGUgdG8gc3RyZWFtIGZyb21cbiAqIEByZXR1cm5zIEEgUmVhZGFibGVTdHJlYW0gdGhhdCB5aWVsZHMgdmFsdWVzIGZyb20gdGhlIEFzeW5jSXRlcmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtRnJvbTxUWWllbGQ+KFxuICBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQ+LFxuKTogUmVhZGFibGVTdHJlYW08VFlpZWxkPiB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuPy4oKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBVbnByb21pc2UgfSBmcm9tICcuLi8uLi8uLi92ZW5kb3IvdW5wcm9taXNlJztcbmltcG9ydCB7IGl0ZXJhdG9yUmVzb3VyY2UgfSBmcm9tICcuL2FzeW5jSXRlcmFibGUnO1xuaW1wb3J0IHsgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCwgdGltZXJSZXNvdXJjZSB9IGZyb20gJy4vdGltZXJSZXNvdXJjZSc7XG5cbmV4cG9ydCBjb25zdCBQSU5HX1NZTSA9IFN5bWJvbCgncGluZycpO1xuXG4vKipcbiAqIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvZiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IHlpZWxkcyB7QGxpbmsgUElOR19TWU19XG4gKiB3aGVuZXZlciBubyB2YWx1ZSBoYXMgYmVlbiB5aWVsZGVkIGZvciB7QGxpbmsgcGluZ0ludGVydmFsTXN9LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHdpdGhQaW5nPFRWYWx1ZT4oXG4gIGl0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFRWYWx1ZT4sXG4gIHBpbmdJbnRlcnZhbE1zOiBudW1iZXIsXG4pOiBBc3luY0dlbmVyYXRvcjxUVmFsdWUgfCB0eXBlb2YgUElOR19TWU0+IHtcbiAgYXdhaXQgdXNpbmcgaXRlcmF0b3IgPSBpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlKTtcblxuICAvLyBkZWNsYXJhdGlvbiBvdXRzaWRlIHRoZSBsb29wIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gcmVhc29uc1xuICBsZXQgcmVzdWx0OlxuICAgIHwgbnVsbFxuICAgIHwgSXRlcmF0b3JSZXN1bHQ8VFZhbHVlPlxuICAgIHwgdHlwZW9mIGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQ7XG5cbiAgbGV0IG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdXNpbmcgcGluZ1Byb21pc2UgPSB0aW1lclJlc291cmNlKHBpbmdJbnRlcnZhbE1zKTtcblxuICAgIHJlc3VsdCA9IGF3YWl0IFVucHJvbWlzZS5yYWNlKFtuZXh0UHJvbWlzZSwgcGluZ1Byb21pc2Uuc3RhcnQoKV0pO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkge1xuICAgICAgLy8gY2FuY2VsbGVkXG5cbiAgICAgIHlpZWxkIFBJTkdfU1lNO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIG5leHRQcm9taXNlID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIHlpZWxkIHJlc3VsdC52YWx1ZTtcblxuICAgIC8vIGZyZWUgdXAgcmVmZXJlbmNlIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICByZXN1bHQgPSBudWxsO1xuICB9XG59XG4iLCJmdW5jdGlvbiBfYXN5bmNJdGVyYXRvcihyKSB7XG4gIHZhciBuLFxuICAgIHQsXG4gICAgbyxcbiAgICBlID0gMjtcbiAgZm9yIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgKHQgPSBTeW1ib2wuYXN5bmNJdGVyYXRvciwgbyA9IFN5bWJvbC5pdGVyYXRvcik7IGUtLTspIHtcbiAgICBpZiAodCAmJiBudWxsICE9IChuID0gclt0XSkpIHJldHVybiBuLmNhbGwocik7XG4gICAgaWYgKG8gJiYgbnVsbCAhPSAobiA9IHJbb10pKSByZXR1cm4gbmV3IEFzeW5jRnJvbVN5bmNJdGVyYXRvcihuLmNhbGwocikpO1xuICAgIHQgPSBcIkBAYXN5bmNJdGVyYXRvclwiLCBvID0gXCJAQGl0ZXJhdG9yXCI7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgYXN5bmMgaXRlcmFibGVcIik7XG59XG5mdW5jdGlvbiBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocikge1xuICBmdW5jdGlvbiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24ocikge1xuICAgIGlmIChPYmplY3QocikgIT09IHIpIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKHIgKyBcIiBpcyBub3QgYW4gb2JqZWN0LlwiKSk7XG4gICAgdmFyIG4gPSByLmRvbmU7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyLnZhbHVlKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgZG9uZTogblxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yID0gZnVuY3Rpb24gQXN5bmNGcm9tU3luY0l0ZXJhdG9yKHIpIHtcbiAgICB0aGlzLnMgPSByLCB0aGlzLm4gPSByLm5leHQ7XG4gIH0sIEFzeW5jRnJvbVN5bmNJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgczogbnVsbCxcbiAgICBuOiBudWxsLFxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICByZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKHRoaXMubi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgXCJyZXR1cm5cIjogZnVuY3Rpb24gX3JldHVybihyKSB7XG4gICAgICB2YXIgbiA9IHRoaXMuc1tcInJldHVyblwiXTtcbiAgICAgIHJldHVybiB2b2lkIDAgPT09IG4gPyBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogcixcbiAgICAgICAgZG9uZTogITBcbiAgICAgIH0pIDogQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKG4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcbiAgICB9LFxuICAgIFwidGhyb3dcIjogZnVuY3Rpb24gX3Rocm93KHIpIHtcbiAgICAgIHZhciBuID0gdGhpcy5zW1wicmV0dXJuXCJdO1xuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gbiA/IFByb21pc2UucmVqZWN0KHIpIDogQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKG4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gIH0sIG5ldyBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY0l0ZXJhdG9yLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHsgaXNBc3luY0l0ZXJhYmxlLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcnVuIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgaXRlcmF0b3JSZXNvdXJjZSB9IGZyb20gJy4vdXRpbHMvYXN5bmNJdGVyYWJsZSc7XG5pbXBvcnQgdHlwZSB7IERlZmVycmVkIH0gZnJvbSAnLi91dGlscy9jcmVhdGVEZWZlcnJlZCc7XG5pbXBvcnQgeyBjcmVhdGVEZWZlcnJlZCB9IGZyb20gJy4vdXRpbHMvY3JlYXRlRGVmZXJyZWQnO1xuaW1wb3J0IHsgbWFrZVJlc291cmNlIH0gZnJvbSAnLi91dGlscy9kaXNwb3NhYmxlJztcbmltcG9ydCB7IG1lcmdlQXN5bmNJdGVyYWJsZXMgfSBmcm9tICcuL3V0aWxzL21lcmdlQXN5bmNJdGVyYWJsZXMnO1xuaW1wb3J0IHsgcmVhZGFibGVTdHJlYW1Gcm9tIH0gZnJvbSAnLi91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20nO1xuaW1wb3J0IHsgUElOR19TWU0sIHdpdGhQaW5nIH0gZnJvbSAnLi91dGlscy93aXRoUGluZyc7XG5cbi8qKlxuICogQSBzdWJzZXQgb2YgdGhlIHN0YW5kYXJkIFJlYWRhYmxlU3RyZWFtIHByb3BlcnRpZXMgbmVlZGVkIGJ5IHRSUEMgaW50ZXJuYWxseS5cbiAqIEBzZWUgUmVhZGFibGVTdHJlYW0gZnJvbSBsaWIuZG9tLmQudHNcbiAqL1xuZXhwb3J0IHR5cGUgV2ViUmVhZGFibGVTdHJlYW1Fc3F1ZSA9IHtcbiAgZ2V0UmVhZGVyOiAoKSA9PiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI8VWludDhBcnJheT47XG59O1xuXG5leHBvcnQgdHlwZSBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlID0ge1xuICBvbihcbiAgICBldmVudE5hbWU6IHN0cmluZyB8IHN5bWJvbCxcbiAgICBsaXN0ZW5lcjogKC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkLFxuICApOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlO1xufTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vLyAtLS0tLS0tLS0tIHR5cGVzXG5jb25zdCBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSAwO1xudHlwZSBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSB0eXBlb2YgQ0hVTktfVkFMVUVfVFlQRV9QUk9NSVNFO1xuY29uc3QgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRSA9IDE7XG50eXBlIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUgPSB0eXBlb2YgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRTtcblxuY29uc3QgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEID0gMDtcbnR5cGUgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEID0gdHlwZW9mIFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRDtcbmNvbnN0IFBST01JU0VfU1RBVFVTX1JFSkVDVEVEID0gMTtcbnR5cGUgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQgPSB0eXBlb2YgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQ7XG5cbmNvbnN0IEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4gPSAwO1xudHlwZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOID0gdHlwZW9mIEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk47XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSAxO1xudHlwZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSB0eXBlb2YgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gMjtcbnR5cGUgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gdHlwZW9mIEFTWU5DX0lURVJBQkxFX1NUQVRVU19FUlJPUjtcblxudHlwZSBDaHVua0RlZmluaXRpb25LZXkgPVxuICAvLyByb290IHNob3VsZCBiZSByZXBsYWNlZFxuICB8IG51bGxcbiAgLy8gYXQgYXJyYXkgcGF0aFxuICB8IG51bWJlclxuICAvLyBhdCBrZXkgcGF0aFxuICB8IHN0cmluZztcblxudHlwZSBDaHVua0luZGV4ID0gbnVtYmVyICYgeyBfX2NodW5rSW5kZXg6IHRydWUgfTtcbnR5cGUgQ2h1bmtWYWx1ZVR5cGUgPVxuICB8IENIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRVxuICB8IENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEU7XG50eXBlIENodW5rRGVmaW5pdGlvbiA9IFtcbiAga2V5OiBDaHVua0RlZmluaXRpb25LZXksXG4gIHR5cGU6IENodW5rVmFsdWVUeXBlLFxuICBjaHVua0lkOiBDaHVua0luZGV4LFxuXTtcbnR5cGUgRW5jb2RlZFZhbHVlID0gW1xuICAvLyBkYXRhXG4gIFt1bmtub3duXSB8IFtdLFxuICAvLyBjaHVuayBkZXNjcmlwdGlvbnNcbiAgLi4uQ2h1bmtEZWZpbml0aW9uW10sXG5dO1xuXG50eXBlIEhlYWQgPSBSZWNvcmQ8c3RyaW5nLCBFbmNvZGVkVmFsdWU+O1xudHlwZSBQcm9taXNlQ2h1bmsgPVxuICB8IFtcbiAgICAgIGNodW5rSW5kZXg6IENodW5rSW5kZXgsXG4gICAgICBzdGF0dXM6IFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRCxcbiAgICAgIHZhbHVlOiBFbmNvZGVkVmFsdWUsXG4gICAgXVxuICB8IFtjaHVua0luZGV4OiBDaHVua0luZGV4LCBzdGF0dXM6IFBST01JU0VfU1RBVFVTX1JFSkVDVEVELCBlcnJvcjogdW5rbm93bl07XG50eXBlIEl0ZXJhYmxlQ2h1bmsgPVxuICB8IFtcbiAgICAgIGNodW5rSW5kZXg6IENodW5rSW5kZXgsXG4gICAgICBzdGF0dXM6IEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4sXG4gICAgICB2YWx1ZTogRW5jb2RlZFZhbHVlLFxuICAgIF1cbiAgfCBbXG4gICAgICBjaHVua0luZGV4OiBDaHVua0luZGV4LFxuICAgICAgc3RhdHVzOiBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQsXG4gICAgICB2YWx1ZTogRW5jb2RlZFZhbHVlLFxuICAgIF1cbiAgfCBbXG4gICAgICBjaHVua0luZGV4OiBDaHVua0luZGV4LFxuICAgICAgc3RhdHVzOiBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfRVJST1IsXG4gICAgICBlcnJvcjogdW5rbm93bixcbiAgICBdO1xudHlwZSBDaHVua0RhdGEgPSBQcm9taXNlQ2h1bmsgfCBJdGVyYWJsZUNodW5rO1xudHlwZSBQbGFjZWhvbGRlclZhbHVlID0gMCAmIHsgX19wbGFjZWhvbGRlcjogdHJ1ZSB9O1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gKFxuICAgIChpc09iamVjdCh2YWx1ZSkgfHwgaXNGdW5jdGlvbih2YWx1ZSkpICYmXG4gICAgdHlwZW9mIHZhbHVlPy5bJ3RoZW4nXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZT8uWydjYXRjaCddID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbnR5cGUgU2VyaWFsaXplID0gKHZhbHVlOiBhbnkpID0+IGFueTtcbnR5cGUgRGVzZXJpYWxpemUgPSAodmFsdWU6IGFueSkgPT4gYW55O1xuXG50eXBlIFBhdGhBcnJheSA9IHJlYWRvbmx5IChzdHJpbmcgfCBudW1iZXIpW107XG5leHBvcnQgdHlwZSBQcm9kdWNlck9uRXJyb3IgPSAob3B0czoge1xuICBlcnJvcjogdW5rbm93bjtcbiAgcGF0aDogUGF0aEFycmF5O1xufSkgPT4gdm9pZDtcbmV4cG9ydCBpbnRlcmZhY2UgSlNPTkxQcm9kdWNlck9wdGlvbnMge1xuICBzZXJpYWxpemU/OiBTZXJpYWxpemU7XG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IHwgdW5rbm93bltdO1xuICBvbkVycm9yPzogUHJvZHVjZXJPbkVycm9yO1xuICBmb3JtYXRFcnJvcj86IChvcHRzOiB7IGVycm9yOiB1bmtub3duOyBwYXRoOiBQYXRoQXJyYXkgfSkgPT4gdW5rbm93bjtcbiAgbWF4RGVwdGg/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgdG8gc2VuZCBhIHBpbmcgdG8gdGhlIGNsaWVudCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlXG4gICAqIFRoaXMgd2lsbCBiZSBzZW50IGFzIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXJcbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBwaW5nTXM/OiBudW1iZXI7XG59XG5cbmNsYXNzIE1heERlcHRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdKSB7XG4gICAgc3VwZXIoJ01heCBkZXB0aCByZWFjaGVkIGF0IHBhdGg6ICcgKyBwYXRoLmpvaW4oJy4nKSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24qIGNyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIoXG4gIG9wdHM6IEpTT05MUHJvZHVjZXJPcHRpb25zLFxuKTogQXN5bmNJdGVyYWJsZTxIZWFkIHwgQ2h1bmtEYXRhIHwgdHlwZW9mIFBJTkdfU1lNLCB2b2lkPiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gb3B0cztcbiAgbGV0IGNvdW50ZXIgPSAwIGFzIENodW5rSW5kZXg7XG4gIGNvbnN0IHBsYWNlaG9sZGVyID0gMCBhcyBQbGFjZWhvbGRlclZhbHVlO1xuXG4gIGNvbnN0IG1lcmdlZEl0ZXJhYmxlcyA9IG1lcmdlQXN5bmNJdGVyYWJsZXM8Q2h1bmtEYXRhPigpO1xuICBmdW5jdGlvbiByZWdpc3RlckFzeW5jKFxuICAgIGNhbGxiYWNrOiAoaWR4OiBDaHVua0luZGV4KSA9PiBBc3luY0l0ZXJhYmxlPENodW5rRGF0YSwgdm9pZD4sXG4gICkge1xuICAgIGNvbnN0IGlkeCA9IGNvdW50ZXIrKyBhcyBDaHVua0luZGV4O1xuXG4gICAgY29uc3QgaXRlcmFibGUgPSBjYWxsYmFjayhpZHgpO1xuICAgIG1lcmdlZEl0ZXJhYmxlcy5hZGQoaXRlcmFibGUpO1xuXG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZVByb21pc2UocHJvbWlzZTogUHJvbWlzZTx1bmtub3duPiwgcGF0aDogKHN0cmluZyB8IG51bWJlcilbXSkge1xuICAgIHJldHVybiByZWdpc3RlckFzeW5jKGFzeW5jIGZ1bmN0aW9uKiAoaWR4KSB7XG4gICAgICBjb25zdCBlcnJvciA9IGNoZWNrTWF4RGVwdGgocGF0aCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyBmcm9tIHRoZSBvcmlnaW5hbCBwcm9taXNlIHRvIGVuc3VyZSB0aGV5J3JlIHJlcG9ydGVkXG4gICAgICAgIHByb21pc2UuY2F0Y2goKGNhdXNlKSA9PiB7XG4gICAgICAgICAgb3B0cy5vbkVycm9yPy4oeyBlcnJvcjogY2F1c2UsIHBhdGggfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZXBsYWNlIHRoZSBwcm9taXNlIHdpdGggYSByZWplY3RlZCBvbmUgY29udGFpbmluZyB0aGUgbWF4IGRlcHRoIGVycm9yXG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXh0ID0gYXdhaXQgcHJvbWlzZTtcbiAgICAgICAgeWllbGQgW2lkeCwgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVELCBlbmNvZGUobmV4dCwgcGF0aCldO1xuICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgb3B0cy5vbkVycm9yPy4oeyBlcnJvcjogY2F1c2UsIHBhdGggfSk7XG4gICAgICAgIHlpZWxkIFtcbiAgICAgICAgICBpZHgsXG4gICAgICAgICAgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQsXG4gICAgICAgICAgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGNhdXNlLCBwYXRoIH0pLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZUFzeW5jSXRlcmFibGUoXG4gICAgaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8dW5rbm93bj4sXG4gICAgcGF0aDogKHN0cmluZyB8IG51bWJlcilbXSxcbiAgKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyQXN5bmMoYXN5bmMgZnVuY3Rpb24qIChpZHgpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gY2hlY2tNYXhEZXB0aChwYXRoKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHVzaW5nIGl0ZXJhdG9yID0gaXRlcmF0b3JSZXNvdXJjZShpdGVyYWJsZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IGF3YWl0IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICB5aWVsZCBbaWR4LCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOLCBlbmNvZGUobmV4dC52YWx1ZSwgcGF0aCldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIFtpZHgsIEFTWU5DX0lURVJBQkxFX1NUQVRVU19ZSUVMRCwgZW5jb2RlKG5leHQudmFsdWUsIHBhdGgpXTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgICAgb3B0cy5vbkVycm9yPy4oeyBlcnJvcjogY2F1c2UsIHBhdGggfSk7XG5cbiAgICAgICAgeWllbGQgW1xuICAgICAgICAgIGlkeCxcbiAgICAgICAgICBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfRVJST1IsXG4gICAgICAgICAgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGNhdXNlLCBwYXRoIH0pLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrTWF4RGVwdGgocGF0aDogKHN0cmluZyB8IG51bWJlcilbXSkge1xuICAgIGlmIChvcHRzLm1heERlcHRoICYmIHBhdGgubGVuZ3RoID4gb3B0cy5tYXhEZXB0aCkge1xuICAgICAgcmV0dXJuIG5ldyBNYXhEZXB0aEVycm9yKHBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGVBc3luYyhcbiAgICB2YWx1ZTogdW5rbm93bixcbiAgICBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdLFxuICApOiBudWxsIHwgW3R5cGU6IENodW5rVmFsdWVUeXBlLCBjaHVua0lkOiBDaHVua0luZGV4XSB7XG4gICAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbQ0hVTktfVkFMVUVfVFlQRV9QUk9NSVNFLCBlbmNvZGVQcm9taXNlKHZhbHVlLCBwYXRoKV07XG4gICAgfVxuICAgIGlmIChpc0FzeW5jSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICBpZiAob3B0cy5tYXhEZXB0aCAmJiBwYXRoLmxlbmd0aCA+PSBvcHRzLm1heERlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWF4IGRlcHRoIHJlYWNoZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXG4gICAgICAgIENIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUsXG4gICAgICAgIGVuY29kZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhdGgpLFxuICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZW5jb2RlKHZhbHVlOiB1bmtub3duLCBwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdKTogRW5jb2RlZFZhbHVlIHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIFtbXV07XG4gICAgfVxuICAgIGNvbnN0IHJlZyA9IGVuY29kZUFzeW5jKHZhbHVlLCBwYXRoKTtcbiAgICBpZiAocmVnKSB7XG4gICAgICByZXR1cm4gW1twbGFjZWhvbGRlcl0sIFtudWxsLCAuLi5yZWddXTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gW1t2YWx1ZV1dO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld09iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fTtcbiAgICBjb25zdCBhc3luY1ZhbHVlczogQ2h1bmtEZWZpbml0aW9uW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBlbmNvZGVBc3luYyhpdGVtLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgICAgIG5ld09ialtrZXldID0gaXRlbTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuZXdPYmpba2V5XSA9IHBsYWNlaG9sZGVyO1xuICAgICAgYXN5bmNWYWx1ZXMucHVzaChba2V5LCAuLi50cmFuc2Zvcm1lZF0pO1xuICAgIH1cbiAgICByZXR1cm4gW1tuZXdPYmpdLCAuLi5hc3luY1ZhbHVlc107XG4gIH1cblxuICBjb25zdCBuZXdIZWFkOiBIZWFkID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcbiAgICBuZXdIZWFkW2tleV0gPSBlbmNvZGUoaXRlbSwgW2tleV0pO1xuICB9XG5cbiAgeWllbGQgbmV3SGVhZDtcblxuICBsZXQgaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8Q2h1bmtEYXRhIHwgdHlwZW9mIFBJTkdfU1lNLCB2b2lkPiA9XG4gICAgbWVyZ2VkSXRlcmFibGVzO1xuICBpZiAob3B0cy5waW5nTXMpIHtcbiAgICBpdGVyYWJsZSA9IHdpdGhQaW5nKG1lcmdlZEl0ZXJhYmxlcywgb3B0cy5waW5nTXMpO1xuICB9XG5cbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgIHlpZWxkIHZhbHVlO1xuICB9XG59XG4vKipcbiAqIEpTT04gTGluZXMgc3RyZWFtIHByb2R1Y2VyXG4gKiBAc2VlIGh0dHBzOi8vanNvbmxpbmVzLm9yZy9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpzb25sU3RyZWFtUHJvZHVjZXIob3B0czogSlNPTkxQcm9kdWNlck9wdGlvbnMpIHtcbiAgbGV0IHN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtRnJvbShjcmVhdGVCYXRjaFN0cmVhbVByb2R1Y2VyKG9wdHMpKTtcblxuICBjb25zdCB7IHNlcmlhbGl6ZSB9ID0gb3B0cztcbiAgaWYgKHNlcmlhbGl6ZSkge1xuICAgIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoY2h1bmsgPT09IFBJTkdfU1lNKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoUElOR19TWU0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoc2VyaWFsaXplKGNodW5rKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBzdHJlYW1cbiAgICAucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rID09PSBQSU5HX1NZTSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKCcgJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShKU09OLnN0cmluZ2lmeShjaHVuaykgKyAnXFxuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKVxuICAgIC5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG59XG5cbmNsYXNzIEFzeW5jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBkYXRhOiB1bmtub3duKSB7XG4gICAgc3VwZXIoJ1JlY2VpdmVkIGVycm9yIGZyb20gc2VydmVyJyk7XG4gIH1cbn1cbmV4cG9ydCB0eXBlIENvbnN1bWVyT25FcnJvciA9IChvcHRzOiB7IGVycm9yOiB1bmtub3duIH0pID0+IHZvaWQ7XG5cbmNvbnN0IG5vZGVKc1N0cmVhbVRvUmVhZGVyRXNxdWUgPSAoc291cmNlOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZ2V0UmVhZGVyKCkge1xuICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KHtcbiAgICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIHNvdXJjZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb3VyY2Uub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzb3VyY2Uub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICB9LFxuICB9O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTGluZUFjY3VtdWxhdG9yKFxuICBmcm9tOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlIHwgV2ViUmVhZGFibGVTdHJlYW1Fc3F1ZSxcbikge1xuICBjb25zdCByZWFkZXIgPVxuICAgICdnZXRSZWFkZXInIGluIGZyb21cbiAgICAgID8gZnJvbS5nZXRSZWFkZXIoKVxuICAgICAgOiBub2RlSnNTdHJlYW1Ub1JlYWRlckVzcXVlKGZyb20pLmdldFJlYWRlcigpO1xuXG4gIGxldCBsaW5lQWdncmVnYXRlID0gJyc7XG5cbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmV0dXJuIHJlYWRlci5jYW5jZWwoKTtcbiAgICB9LFxuICB9KVxuICAgIC5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSlcbiAgICAucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtPHN0cmluZywgc3RyaW5nPih7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIGxpbmVBZ2dyZWdhdGUgKz0gY2h1bms7XG4gICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lQWdncmVnYXRlLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBsaW5lQWdncmVnYXRlID0gcGFydHMucG9wKCkgPz8gJyc7XG4gICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN1bWVyU3RyZWFtPFRIZWFkPihcbiAgZnJvbTogTm9kZUpTUmVhZGFibGVTdHJlYW1Fc3F1ZSB8IFdlYlJlYWRhYmxlU3RyZWFtRXNxdWUsXG4pIHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlTGluZUFjY3VtdWxhdG9yKGZyb20pO1xuXG4gIGxldCBzZW50SGVhZCA9IGZhbHNlO1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW08c3RyaW5nLCBDaHVua0RhdGEgfCBUSGVhZD4oe1xuICAgICAgdHJhbnNmb3JtKGxpbmUsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKCFzZW50SGVhZCkge1xuICAgICAgICAgIGNvbnN0IGhlYWQgPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShoZWFkIGFzIFRIZWFkKTtcbiAgICAgICAgICBzZW50SGVhZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgY2h1bms6IENodW5rRGF0YSA9IEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KSxcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFuZGxlciBmb3IgbWFuYWdpbmcgc3RyZWFtIGNvbnRyb2xsZXJzIGFuZCB0aGVpciBsaWZlY3ljbGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RyZWFtc01hbmFnZXIoYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIpIHtcbiAgY29uc3QgY29udHJvbGxlck1hcCA9IG5ldyBNYXA8XG4gICAgQ2h1bmtJbmRleCxcbiAgICBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVTdHJlYW1Db250cm9sbGVyPlxuICA+KCk7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgbm8gcGVuZGluZyBjb250cm9sbGVycyBvciBkZWZlcnJlZCBwcm9taXNlc1xuICAgKi9cbiAgZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShjb250cm9sbGVyTWFwLnZhbHVlcygpKS5ldmVyeSgoYykgPT4gYy5jbG9zZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzdHJlYW0gY29udHJvbGxlclxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlU3RyZWFtQ29udHJvbGxlcigpIHtcbiAgICBsZXQgb3JpZ2luYWxDb250cm9sbGVyOiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPENodW5rRGF0YT47XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtPENodW5rRGF0YT4oe1xuICAgICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBvcmlnaW5hbENvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB7XG4gICAgICBlbnF1ZXVlOiAodjogQ2h1bmtEYXRhKSA9PiBvcmlnaW5hbENvbnRyb2xsZXIuZW5xdWV1ZSh2KSxcbiAgICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICAgIG9yaWdpbmFsQ29udHJvbGxlci5jbG9zZSgpO1xuXG4gICAgICAgIGNsZWFyKCk7XG5cbiAgICAgICAgaWYgKGlzRW1wdHkoKSkge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xvc2VkOiBmYWxzZSxcbiAgICAgIGdldFJlYWRlclJlc291cmNlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgICByZXR1cm4gbWFrZVJlc291cmNlKHJlYWRlciwgKCkgPT4ge1xuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IChyZWFzb246IHVua25vd24pID0+IHtcbiAgICAgICAgb3JpZ2luYWxDb250cm9sbGVyLmVycm9yKHJlYXNvbik7XG4gICAgICAgIGNsZWFyKCk7XG4gICAgICB9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0cmVhbUNvbnRyb2xsZXIsIHtcbiAgICAgICAgY2xvc2VkOiB0cnVlLFxuICAgICAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfSxcbiAgICAgICAgZW5xdWV1ZTogKCkgPT4ge1xuICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UmVhZGVyUmVzb3VyY2U6IG51bGwsXG4gICAgICAgIGVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmVhbUNvbnRyb2xsZXI7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBvciBjcmVhdGVzIGEgc3RyZWFtIGNvbnRyb2xsZXJcbiAgICovXG4gIGZ1bmN0aW9uIGdldE9yQ3JlYXRlKGNodW5rSWQ6IENodW5rSW5kZXgpIHtcbiAgICBsZXQgYyA9IGNvbnRyb2xsZXJNYXAuZ2V0KGNodW5rSWQpO1xuICAgIGlmICghYykge1xuICAgICAgYyA9IGNyZWF0ZVN0cmVhbUNvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnRyb2xsZXJNYXAuc2V0KGNodW5rSWQsIGMpO1xuICAgIH1cbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFsbCBwZW5kaW5nIGNvbnRyb2xsZXJzIGFuZCByZWplY3RzIGRlZmVycmVkIHByb21pc2VzXG4gICAqL1xuICBmdW5jdGlvbiBjYW5jZWxBbGwocmVhc29uOiB1bmtub3duKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIGNvbnRyb2xsZXJNYXAudmFsdWVzKCkpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IocmVhc29uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldE9yQ3JlYXRlLFxuICAgIGlzRW1wdHksXG4gICAgY2FuY2VsQWxsLFxuICB9O1xufVxuXG4vKipcbiAqIEpTT04gTGluZXMgc3RyZWFtIGNvbnN1bWVyXG4gKiBAc2VlIGh0dHBzOi8vanNvbmxpbmVzLm9yZy9cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGpzb25sU3RyZWFtQ29uc3VtZXI8VEhlYWQ+KG9wdHM6IHtcbiAgZnJvbTogTm9kZUpTUmVhZGFibGVTdHJlYW1Fc3F1ZSB8IFdlYlJlYWRhYmxlU3RyZWFtRXNxdWU7XG4gIGRlc2VyaWFsaXplPzogRGVzZXJpYWxpemU7XG4gIG9uRXJyb3I/OiBDb25zdW1lck9uRXJyb3I7XG4gIGZvcm1hdEVycm9yPzogKG9wdHM6IHsgZXJyb3I6IHVua25vd24gfSkgPT4gRXJyb3I7XG4gIC8qKlxuICAgKiBUaGlzIGBBYm9ydENvbnRyb2xsZXJgIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgbGlzdGVuZXJzIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlcjtcbn0pIHtcbiAgY29uc3QgeyBkZXNlcmlhbGl6ZSA9ICh2KSA9PiB2IH0gPSBvcHRzO1xuXG4gIGxldCBzb3VyY2UgPSBjcmVhdGVDb25zdW1lclN0cmVhbTxIZWFkPihvcHRzLmZyb20pO1xuICBpZiAoZGVzZXJpYWxpemUpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRlc2VyaWFsaXplKGNodW5rKSk7XG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICApO1xuICB9XG4gIGxldCBoZWFkRGVmZXJyZWQ6IG51bGwgfCBEZWZlcnJlZDxUSGVhZD4gPSBjcmVhdGVEZWZlcnJlZCgpO1xuXG4gIGNvbnN0IHN0cmVhbU1hbmFnZXIgPSBjcmVhdGVTdHJlYW1zTWFuYWdlcihvcHRzLmFib3J0Q29udHJvbGxlcik7XG5cbiAgZnVuY3Rpb24gZGVjb2RlQ2h1bmtEZWZpbml0aW9uKHZhbHVlOiBDaHVua0RlZmluaXRpb24pIHtcbiAgICBjb25zdCBbX3BhdGgsIHR5cGUsIGNodW5rSWRdID0gdmFsdWU7XG5cbiAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtTWFuYWdlci5nZXRPckNyZWF0ZShjaHVua0lkKTtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBDSFVOS19WQUxVRV9UWVBFX1BST01JU0U6IHtcbiAgICAgICAgcmV0dXJuIHJ1bihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgdXNpbmcgcmVhZGVyID0gY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpO1xuXG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBjb25zdCBbX2NodW5rSWQsIHN0YXR1cywgZGF0YV0gPSB2YWx1ZSBhcyBQcm9taXNlQ2h1bms7XG4gICAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEOlxuICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgY2FzZSBQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRDpcbiAgICAgICAgICAgICAgdGhyb3cgb3B0cy5mb3JtYXRFcnJvcj8uKHsgZXJyb3I6IGRhdGEgfSkgPz8gbmV3IEFzeW5jRXJyb3IoZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRToge1xuICAgICAgICByZXR1cm4gcnVuKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdXNpbmcgcmVhZGVyID0gY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpO1xuXG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IFtfY2h1bmtJZCwgc3RhdHVzLCBkYXRhXSA9IHZhbHVlIGFzIEl0ZXJhYmxlQ2h1bms7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgIGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1lJRUxEOlxuICAgICAgICAgICAgICAgIHlpZWxkIGRlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfUkVUVVJOOlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICAgIGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SOlxuICAgICAgICAgICAgICAgIHRocm93IChcbiAgICAgICAgICAgICAgICAgIG9wdHMuZm9ybWF0RXJyb3I/Lih7IGVycm9yOiBkYXRhIH0pID8/IG5ldyBBc3luY0Vycm9yKGRhdGEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlY29kZSh2YWx1ZTogRW5jb2RlZFZhbHVlKTogdW5rbm93biB7XG4gICAgY29uc3QgW1tkYXRhXSwgLi4uYXN5bmNQcm9wc10gPSB2YWx1ZTtcblxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgYXN5bmNQcm9wcykge1xuICAgICAgY29uc3QgW2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUpO1xuXG4gICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgfVxuXG4gICAgICAoZGF0YSBhcyBhbnkpW2tleV0gPSBkZWNvZGVkO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGNvbnN0IGNsb3NlT3JBYm9ydCA9IChyZWFzb246IHVua25vd24pID0+IHtcbiAgICBoZWFkRGVmZXJyZWQ/LnJlamVjdChyZWFzb24pO1xuICAgIHN0cmVhbU1hbmFnZXIuY2FuY2VsQWxsKHJlYXNvbik7XG4gIH07XG4gIHNvdXJjZVxuICAgIC5waXBlVG8oXG4gICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICB3cml0ZShjaHVua09ySGVhZCkge1xuICAgICAgICAgIGlmIChoZWFkRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBjaHVua09ySGVhZCBhcyBSZWNvcmQ8bnVtYmVyIHwgc3RyaW5nLCB1bmtub3duPjtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2h1bmtPckhlYWQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGRlY29kZSh2YWx1ZSBhcyBhbnkpO1xuICAgICAgICAgICAgICBoZWFkW2tleV0gPSBwYXJzZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkRGVmZXJyZWQucmVzb2x2ZShoZWFkIGFzIFRIZWFkKTtcbiAgICAgICAgICAgIGhlYWREZWZlcnJlZCA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2h1bmsgPSBjaHVua09ySGVhZCBhcyBDaHVua0RhdGE7XG4gICAgICAgICAgY29uc3QgW2lkeF0gPSBjaHVuaztcblxuICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW1NYW5hZ2VyLmdldE9yQ3JlYXRlKGlkeCk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2U6ICgpID0+IGNsb3NlT3JBYm9ydChuZXcgRXJyb3IoJ1N0cmVhbSBjbG9zZWQnKSksXG4gICAgICAgIGFib3J0OiBjbG9zZU9yQWJvcnQsXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgc2lnbmFsOiBvcHRzLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICB9LFxuICAgIClcbiAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBvcHRzLm9uRXJyb3I/Lih7IGVycm9yIH0pO1xuICAgICAgY2xvc2VPckFib3J0KGVycm9yKTtcbiAgICB9KTtcblxuICByZXR1cm4gW2F3YWl0IGhlYWREZWZlcnJlZC5wcm9taXNlLCBzdHJlYW1NYW5hZ2VyXSBhcyBjb25zdDtcbn1cbiIsInZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZShcIi4vT3ZlcmxvYWRZaWVsZC5qc1wiKTtcbmZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlKHQpIHtcbiAgdmFyIGUgPSB7fSxcbiAgICBuID0gITE7XG4gIGZ1bmN0aW9uIHB1bXAoZSwgcikge1xuICAgIHJldHVybiBuID0gITAsIHIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAobikge1xuICAgICAgbih0W2VdKHIpKTtcbiAgICB9KSwge1xuICAgICAgZG9uZTogITEsXG4gICAgICB2YWx1ZTogbmV3IE92ZXJsb2FkWWllbGQociwgMSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBlW1widW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LCBlLm5leHQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBuID8gKG4gPSAhMSwgdCkgOiBwdW1wKFwibmV4dFwiLCB0KTtcbiAgfSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0W1widGhyb3dcIl0gJiYgKGVbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKG4pIHRocm93IG4gPSAhMSwgdDtcbiAgICByZXR1cm4gcHVtcChcInRocm93XCIsIHQpO1xuICB9KSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0W1wicmV0dXJuXCJdICYmIChlW1wicmV0dXJuXCJdID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gbiA/IChuID0gITEsIHQpIDogcHVtcChcInJldHVyblwiLCB0KTtcbiAgfSksIGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY0dlbmVyYXRvckRlbGVnYXRlLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwiaW1wb3J0IHsgVW5wcm9taXNlIH0gZnJvbSAnLi4vLi4vdmVuZG9yL3VucHJvbWlzZSc7XG5pbXBvcnQgeyBnZXRUUlBDRXJyb3JGcm9tVW5rbm93biB9IGZyb20gJy4uL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgeyBpc0Fib3J0RXJyb3IgfSBmcm9tICcuLi9odHRwL2Fib3J0RXJyb3InO1xuaW1wb3J0IHR5cGUgeyBNYXliZVByb21pc2UgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBpZGVudGl0eSwgcnVuIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHR5cGUgeyBFdmVudFNvdXJjZUxpa2UgfSBmcm9tICcuL3NzZS50eXBlcyc7XG5pbXBvcnQgdHlwZSB7IGluZmVyVHJhY2tlZE91dHB1dCB9IGZyb20gJy4vdHJhY2tlZCc7XG5pbXBvcnQgeyBpc1RyYWNrZWRFbnZlbG9wZSB9IGZyb20gJy4vdHJhY2tlZCc7XG5pbXBvcnQgeyB0YWtlV2l0aEdyYWNlLCB3aXRoTWF4RHVyYXRpb24gfSBmcm9tICcuL3V0aWxzL2FzeW5jSXRlcmFibGUnO1xuaW1wb3J0IHsgbWFrZUFzeW5jUmVzb3VyY2UgfSBmcm9tICcuL3V0aWxzL2Rpc3Bvc2FibGUnO1xuaW1wb3J0IHsgcmVhZGFibGVTdHJlYW1Gcm9tIH0gZnJvbSAnLi91dGlscy9yZWFkYWJsZVN0cmVhbUZyb20nO1xuaW1wb3J0IHtcbiAgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCxcbiAgdGltZXJSZXNvdXJjZSxcbn0gZnJvbSAnLi91dGlscy90aW1lclJlc291cmNlJztcbmltcG9ydCB7IFBJTkdfU1lNLCB3aXRoUGluZyB9IGZyb20gJy4vdXRpbHMvd2l0aFBpbmcnO1xuXG50eXBlIFNlcmlhbGl6ZSA9ICh2YWx1ZTogYW55KSA9PiBhbnk7XG50eXBlIERlc2VyaWFsaXplID0gKHZhbHVlOiBhbnkpID0+IGFueTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTU0VQaW5nT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBFbmFibGUgcGluZyBjb21tZW50cyBzZW50IGZyb20gdGhlIHNlcnZlclxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgZW5hYmxlZDogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAZGVmYXVsdCAxMDAwXG4gICAqL1xuICBpbnRlcnZhbE1zPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNTRUNsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogVGltZW91dCBhbmQgcmVjb25uZWN0IGFmdGVyIGluYWN0aXZpdHkgaW4gbWlsbGlzZWNvbmRzXG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU1NFU3RyZWFtUHJvZHVjZXJPcHRpb25zPFRWYWx1ZSA9IHVua25vd24+IHtcbiAgc2VyaWFsaXplPzogU2VyaWFsaXplO1xuICBkYXRhOiBBc3luY0l0ZXJhYmxlPFRWYWx1ZT47XG5cbiAgbWF4RGVwdGg/OiBudW1iZXI7XG4gIHBpbmc/OiBTU0VQaW5nT3B0aW9ucztcbiAgLyoqXG4gICAqIE1heGltdW0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgcmVxdWVzdCBiZWZvcmUgZW5kaW5nIHRoZSBzdHJlYW1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBtYXhEdXJhdGlvbk1zPzogbnVtYmVyO1xuICAvKipcbiAgICogRW5kIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5IGFmdGVyIGRhdGEgaXMgc2VudFxuICAgKiBPbmx5IHVzZWZ1bCBmb3Igc2VydmVybGVzcyBydW50aW1lcyB0aGF0IGRvIG5vdCBzdXBwb3J0IHN0cmVhbWluZyByZXNwb25zZXNcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVtaXRBbmRFbmRJbW1lZGlhdGVseT86IGJvb2xlYW47XG4gIGZvcm1hdEVycm9yPzogKG9wdHM6IHsgZXJyb3I6IHVua25vd24gfSkgPT4gdW5rbm93bjtcbiAgLyoqXG4gICAqIENsaWVudC1zcGVjaWZpYyBvcHRpb25zIC0gdGhlc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBjbGllbnQgYXMgcGFydCBvZiB0aGUgZmlyc3QgbWVzc2FnZVxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY2xpZW50PzogU1NFQ2xpZW50T3B0aW9ucztcbn1cblxuY29uc3QgUElOR19FVkVOVCA9ICdwaW5nJztcbmNvbnN0IFNFUklBTElaRURfRVJST1JfRVZFTlQgPSAnc2VyaWFsaXplZC1lcnJvcic7XG5jb25zdCBDT05ORUNURURfRVZFTlQgPSAnY29ubmVjdGVkJztcbmNvbnN0IFJFVFVSTl9FVkVOVCA9ICdyZXR1cm4nO1xuXG5pbnRlcmZhY2UgU1NFdmVudCB7XG4gIGlkPzogc3RyaW5nO1xuICBkYXRhOiB1bmtub3duO1xuICBjb21tZW50Pzogc3RyaW5nO1xuICBldmVudD86IHN0cmluZztcbn1cbi8qKlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNzZVN0cmVhbVByb2R1Y2VyPFRWYWx1ZSA9IHVua25vd24+KFxuICBvcHRzOiBTU0VTdHJlYW1Qcm9kdWNlck9wdGlvbnM8VFZhbHVlPixcbikge1xuICBjb25zdCB7IHNlcmlhbGl6ZSA9IGlkZW50aXR5IH0gPSBvcHRzO1xuXG4gIGNvbnN0IHBpbmc6IFJlcXVpcmVkPFNTRVBpbmdPcHRpb25zPiA9IHtcbiAgICBlbmFibGVkOiBvcHRzLnBpbmc/LmVuYWJsZWQgPz8gZmFsc2UsXG4gICAgaW50ZXJ2YWxNczogb3B0cy5waW5nPy5pbnRlcnZhbE1zID8/IDEwMDAsXG4gIH07XG4gIGNvbnN0IGNsaWVudDogU1NFQ2xpZW50T3B0aW9ucyA9IG9wdHMuY2xpZW50ID8/IHt9O1xuXG4gIGlmIChcbiAgICBwaW5nLmVuYWJsZWQgJiZcbiAgICBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXMgJiZcbiAgICBwaW5nLmludGVydmFsTXMgPiBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXNcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFBpbmcgaW50ZXJ2YWwgbXVzdCBiZSBsZXNzIHRoYW4gY2xpZW50IHJlY29ubmVjdCBpbnRlcnZhbCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlY29ubmVjdGlvbiAtIHBpbmcuaW50ZXJ2YWxNczogJHtwaW5nLmludGVydmFsTXN9IGNsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNczogJHtjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXN9YCxcbiAgICApO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24qIGdlbmVyYXRvcigpOiBBc3luY0l0ZXJhYmxlPFNTRXZlbnQsIHZvaWQ+IHtcbiAgICB5aWVsZCB7XG4gICAgICBldmVudDogQ09OTkVDVEVEX0VWRU5ULFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoY2xpZW50KSxcbiAgICB9O1xuXG4gICAgdHlwZSBUSXRlcmF0b3JWYWx1ZSA9IEF3YWl0ZWQ8VFZhbHVlPiB8IHR5cGVvZiBQSU5HX1NZTTtcblxuICAgIGxldCBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUVmFsdWUgfCB0eXBlb2YgUElOR19TWU0+ID0gb3B0cy5kYXRhO1xuXG4gICAgaWYgKG9wdHMuZW1pdEFuZEVuZEltbWVkaWF0ZWx5KSB7XG4gICAgICBpdGVyYWJsZSA9IHRha2VXaXRoR3JhY2UoaXRlcmFibGUsIHtcbiAgICAgICAgY291bnQ6IDEsXG4gICAgICAgIGdyYWNlUGVyaW9kTXM6IDEsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvcHRzLm1heER1cmF0aW9uTXMgJiZcbiAgICAgIG9wdHMubWF4RHVyYXRpb25NcyA+IDAgJiZcbiAgICAgIG9wdHMubWF4RHVyYXRpb25NcyAhPT0gSW5maW5pdHlcbiAgICApIHtcbiAgICAgIGl0ZXJhYmxlID0gd2l0aE1heER1cmF0aW9uKGl0ZXJhYmxlLCB7XG4gICAgICAgIG1heER1cmF0aW9uTXM6IG9wdHMubWF4RHVyYXRpb25NcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwaW5nLmVuYWJsZWQgJiYgcGluZy5pbnRlcnZhbE1zICE9PSBJbmZpbml0eSAmJiBwaW5nLmludGVydmFsTXMgPiAwKSB7XG4gICAgICBpdGVyYWJsZSA9IHdpdGhQaW5nKGl0ZXJhYmxlLCBwaW5nLmludGVydmFsTXMpO1xuICAgIH1cblxuICAgIC8vIFdlIG5lZWQgdGhvc2UgZGVjbGFyYXRpb25zIG91dHNpZGUgdGhlIGxvb3AgZm9yIGdhcmJhZ2UgY29sbGVjdGlvbiByZWFzb25zLiBJZiB0aGV5IHdlcmVcbiAgICAvLyBkZWNsYXJlZCBpbnNpZGUsIHRoZXkgd291bGQgbm90IGJlIGZyZWVkIHVudGlsIHRoZSBuZXh0IHZhbHVlIGlzIHByZXNlbnQuXG4gICAgbGV0IHZhbHVlOiBudWxsIHwgVEl0ZXJhdG9yVmFsdWU7XG4gICAgbGV0IGNodW5rOiBudWxsIHwgU1NFdmVudDtcblxuICAgIGZvciBhd2FpdCAodmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gUElOR19TWU0pIHtcbiAgICAgICAgeWllbGQgeyBldmVudDogUElOR19FVkVOVCwgZGF0YTogJycgfTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNodW5rID0gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpXG4gICAgICAgID8geyBpZDogdmFsdWVbMF0sIGRhdGE6IHZhbHVlWzFdIH1cbiAgICAgICAgOiB7IGRhdGE6IHZhbHVlIH07XG5cbiAgICAgIGNodW5rLmRhdGEgPSBKU09OLnN0cmluZ2lmeShzZXJpYWxpemUoY2h1bmsuZGF0YSkpO1xuXG4gICAgICB5aWVsZCBjaHVuaztcblxuICAgICAgLy8gZnJlZSB1cCByZWZlcmVuY2VzIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgIGNodW5rID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiogZ2VuZXJhdG9yV2l0aEVycm9ySGFuZGxpbmcoKTogQXN5bmNJdGVyYWJsZTxTU0V2ZW50LCB2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgIHlpZWxkKiBnZW5lcmF0b3IoKTtcblxuICAgICAgeWllbGQge1xuICAgICAgICBldmVudDogUkVUVVJOX0VWRU5ULFxuICAgICAgICBkYXRhOiAnJyxcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoY2F1c2UpIHtcbiAgICAgIGlmIChpc0Fib3J0RXJyb3IoY2F1c2UpKSB7XG4gICAgICAgIC8vIGlnbm9yZSBhYm9ydCBlcnJvcnMsIHNlbmQgYW55IG90aGVyIGVycm9yc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBgZXJyYCBtdXN0IGJlIGNhdXNlZCBieSBgb3B0cy5kYXRhYCwgYEpTT04uc3RyaW5naWZ5YCBvciBgc2VyaWFsaXplYC5cbiAgICAgIC8vIFNvLCBhIHVzZXIgZXJyb3IgaW4gYW55IGNhc2UuXG4gICAgICBjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKTtcbiAgICAgIGNvbnN0IGRhdGEgPSBvcHRzLmZvcm1hdEVycm9yPy4oeyBlcnJvciB9KSA/PyBudWxsO1xuICAgICAgeWllbGQge1xuICAgICAgICBldmVudDogU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCxcbiAgICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplKGRhdGEpKSxcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkpO1xuXG4gIHJldHVybiBzdHJlYW1cbiAgICAucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxzdHJpbmc+KSB7XG4gICAgICAgICAgaWYgKCdldmVudCcgaW4gY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZXZlbnQ6ICR7Y2h1bmsuZXZlbnR9XFxuYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgnZGF0YScgaW4gY2h1bmspIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShgZGF0YTogJHtjaHVuay5kYXRhfVxcbmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ2lkJyBpbiBjaHVuaykge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGBpZDogJHtjaHVuay5pZH1cXG5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdjb21tZW50JyBpbiBjaHVuaykge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGA6ICR7Y2h1bmsuY29tbWVudH1cXG5gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKCdcXG5cXG4nKTtcbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgIClcbiAgICAucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpO1xufVxuXG5pbnRlcmZhY2UgQ29uc3VtZXJTdHJlYW1SZXN1bHRCYXNlPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz4ge1xuICBldmVudFNvdXJjZTogSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbDtcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyU3RyZWFtUmVzdWx0RGF0YTxUQ29uZmlnIGV4dGVuZHMgQ29uc3VtZXJDb25maWc+XG4gIGV4dGVuZHMgQ29uc3VtZXJTdHJlYW1SZXN1bHRCYXNlPFRDb25maWc+IHtcbiAgdHlwZTogJ2RhdGEnO1xuICBkYXRhOiBpbmZlclRyYWNrZWRPdXRwdXQ8VENvbmZpZ1snZGF0YSddPjtcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyU3RyZWFtUmVzdWx0RXJyb3I8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICdzZXJpYWxpemVkLWVycm9yJztcbiAgZXJyb3I6IFRDb25maWdbJ2Vycm9yJ107XG59XG5cbmludGVyZmFjZSBDb25zdW1lclN0cmVhbVJlc3VsdENvbm5lY3Rpbmc8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICdjb25uZWN0aW5nJztcbiAgZXZlbnQ6IEV2ZW50U291cmNlTGlrZS5FdmVudE9mPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbDtcbn1cbmludGVyZmFjZSBDb25zdW1lclN0cmVhbVJlc3VsdFRpbWVvdXQ8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICd0aW1lb3V0JztcbiAgbXM6IG51bWJlcjtcbn1cbmludGVyZmFjZSBDb25zdW1lclN0cmVhbVJlc3VsdFBpbmc8VENvbmZpZyBleHRlbmRzIENvbnN1bWVyQ29uZmlnPlxuICBleHRlbmRzIENvbnN1bWVyU3RyZWFtUmVzdWx0QmFzZTxUQ29uZmlnPiB7XG4gIHR5cGU6ICdwaW5nJztcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyU3RyZWFtUmVzdWx0Q29ubmVjdGVkPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz5cbiAgZXh0ZW5kcyBDb25zdW1lclN0cmVhbVJlc3VsdEJhc2U8VENvbmZpZz4ge1xuICB0eXBlOiAnY29ubmVjdGVkJztcbiAgb3B0aW9uczogU1NFQ2xpZW50T3B0aW9ucztcbn1cblxudHlwZSBDb25zdW1lclN0cmVhbVJlc3VsdDxUQ29uZmlnIGV4dGVuZHMgQ29uc3VtZXJDb25maWc+ID1cbiAgfCBDb25zdW1lclN0cmVhbVJlc3VsdERhdGE8VENvbmZpZz5cbiAgfCBDb25zdW1lclN0cmVhbVJlc3VsdEVycm9yPFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRDb25uZWN0aW5nPFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRUaW1lb3V0PFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRQaW5nPFRDb25maWc+XG4gIHwgQ29uc3VtZXJTdHJlYW1SZXN1bHRDb25uZWN0ZWQ8VENvbmZpZz47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU1NFU3RyZWFtQ29uc3VtZXJPcHRpb25zPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz4ge1xuICB1cmw6ICgpID0+IE1heWJlUHJvbWlzZTxzdHJpbmc+O1xuICBpbml0OiAoKSA9PlxuICAgIHwgTWF5YmVQcm9taXNlPEV2ZW50U291cmNlTGlrZS5Jbml0RGljdE9mPFRDb25maWdbJ0V2ZW50U291cmNlJ10+PlxuICAgIHwgdW5kZWZpbmVkO1xuICBzaWduYWw6IEFib3J0U2lnbmFsO1xuICBkZXNlcmlhbGl6ZT86IERlc2VyaWFsaXplO1xuICBFdmVudFNvdXJjZTogVENvbmZpZ1snRXZlbnRTb3VyY2UnXTtcbn1cblxuaW50ZXJmYWNlIENvbnN1bWVyQ29uZmlnIHtcbiAgZGF0YTogdW5rbm93bjtcbiAgZXJyb3I6IHVua25vd247XG4gIEV2ZW50U291cmNlOiBFdmVudFNvdXJjZUxpa2UuQW55Q29uc3RydWN0b3I7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdpdGhUaW1lb3V0PFQ+KG9wdHM6IHtcbiAgcHJvbWlzZTogUHJvbWlzZTxUPjtcbiAgdGltZW91dE1zOiBudW1iZXI7XG4gIG9uVGltZW91dDogKCkgPT4gUHJvbWlzZTxOb0luZmVyPFQ+Pjtcbn0pOiBQcm9taXNlPFQ+IHtcbiAgdXNpbmcgdGltZW91dFByb21pc2UgPSB0aW1lclJlc291cmNlKG9wdHMudGltZW91dE1zKTtcbiAgY29uc3QgcmVzID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW29wdHMucHJvbWlzZSwgdGltZW91dFByb21pc2Uuc3RhcnQoKV0pO1xuXG4gIGlmIChyZXMgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHtcbiAgICByZXR1cm4gYXdhaXQgb3B0cy5vblRpbWVvdXQoKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNzZVN0cmVhbUNvbnN1bWVyPFRDb25maWcgZXh0ZW5kcyBDb25zdW1lckNvbmZpZz4oXG4gIG9wdHM6IFNTRVN0cmVhbUNvbnN1bWVyT3B0aW9uczxUQ29uZmlnPixcbik6IEFzeW5jSXRlcmFibGU8Q29uc3VtZXJTdHJlYW1SZXN1bHQ8VENvbmZpZz4+IHtcbiAgY29uc3QgeyBkZXNlcmlhbGl6ZSA9ICh2KSA9PiB2IH0gPSBvcHRzO1xuXG4gIGxldCBjbGllbnRPcHRpb25zOiBTU0VDbGllbnRPcHRpb25zID0ge307XG5cbiAgY29uc3Qgc2lnbmFsID0gb3B0cy5zaWduYWw7XG5cbiAgbGV0IF9lczogSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT5cbiAgICBuZXcgUmVhZGFibGVTdHJlYW08Q29uc3VtZXJTdHJlYW1SZXN1bHQ8VENvbmZpZz4+KHtcbiAgICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgW3VybCwgaW5pdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbb3B0cy51cmwoKSwgb3B0cy5pbml0KCldKTtcbiAgICAgICAgY29uc3QgZXZlbnRTb3VyY2UgPSAoX2VzID0gbmV3IG9wdHMuRXZlbnRTb3VyY2UoXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGluaXQsXG4gICAgICAgICkgYXMgSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+KTtcblxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW5nJyxcbiAgICAgICAgICBldmVudFNvdXJjZTogX2VzLFxuICAgICAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKENPTk5FQ1RFRF9FVkVOVCwgKF9tc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBfbXNnIGFzIEV2ZW50U291cmNlTGlrZS5NZXNzYWdlRXZlbnQ7XG5cbiAgICAgICAgICBjb25zdCBvcHRpb25zOiBTU0VDbGllbnRPcHRpb25zID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cbiAgICAgICAgICBjbGllbnRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogJ2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCwgKF9tc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBfbXNnIGFzIEV2ZW50U291cmNlTGlrZS5NZXNzYWdlRXZlbnQ7XG5cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogJ3NlcmlhbGl6ZWQtZXJyb3InLFxuICAgICAgICAgICAgZXJyb3I6IGRlc2VyaWFsaXplKEpTT04ucGFyc2UobXNnLmRhdGEpKSxcbiAgICAgICAgICAgIGV2ZW50U291cmNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihQSU5HX0VWRU5ULCAoKSA9PiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6ICdwaW5nJyxcbiAgICAgICAgICAgIGV2ZW50U291cmNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihSRVRVUk5fRVZFTlQsICgpID0+IHtcbiAgICAgICAgICBldmVudFNvdXJjZS5jbG9zZSgpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICBfZXMgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRTb3VyY2UucmVhZHlTdGF0ZSA9PT0gZXZlbnRTb3VyY2UuQ0xPU0VEKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogJ2Nvbm5lY3RpbmcnLFxuICAgICAgICAgICAgICBldmVudFNvdXJjZSxcbiAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKF9tc2cpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSBfbXNnIGFzIEV2ZW50U291cmNlTGlrZS5NZXNzYWdlRXZlbnQ7XG5cbiAgICAgICAgICBjb25zdCBjaHVuayA9IGRlc2VyaWFsaXplKEpTT04ucGFyc2UobXNnLmRhdGEpKTtcblxuICAgICAgICAgIGNvbnN0IGRlZjogU1NFdmVudCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG1zZy5sYXN0RXZlbnRJZCkge1xuICAgICAgICAgICAgZGVmLmlkID0gbXNnLmxhc3RFdmVudElkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgZGF0YTogZGVmIGFzIGluZmVyVHJhY2tlZE91dHB1dDxUQ29uZmlnWydkYXRhJ10+LFxuICAgICAgICAgICAgZXZlbnRTb3VyY2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIGNhc2UgdGhlIGNvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIG9uQWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgX2VzPy5jbG9zZSgpO1xuICAgICAgfSxcbiAgICB9KTtcblxuICBjb25zdCBnZXRTdHJlYW1SZXNvdXJjZSA9ICgpID0+IHtcbiAgICBsZXQgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG4gICAgbGV0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICBfZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlQXN5bmNSZXNvdXJjZShcbiAgICAgIHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcmVjcmVhdGUoKSB7XG4gICAgICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuXG4gICAgICAgICAgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG4gICAgICAgICAgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIGRpc3Bvc2UsXG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gcnVuKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgYXdhaXQgdXNpbmcgc3RyZWFtID0gZ2V0U3RyZWFtUmVzb3VyY2UoKTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgcHJvbWlzZSA9IHN0cmVhbS5yZWFkKCk7XG5cbiAgICAgIGNvbnN0IHRpbWVvdXRNcyA9IGNsaWVudE9wdGlvbnMucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXM7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIHByb21pc2UgPSB3aXRoVGltZW91dCh7XG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICB0aW1lb3V0TXMsXG4gICAgICAgICAgb25UaW1lb3V0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXM6IEF3YWl0ZWQ8dHlwZW9mIHByb21pc2U+ID0ge1xuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0aW1lb3V0JyxcbiAgICAgICAgICAgICAgICBtczogdGltZW91dE1zLFxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlOiBfZXMsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENsb3NlIGFuZCByZWxlYXNlIG9sZCByZWFkZXJcbiAgICAgICAgICAgIGF3YWl0IHN0cmVhbS5yZWNyZWF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwcm9taXNlO1xuXG4gICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3Qgc3NlSGVhZGVycyA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L2V2ZW50LXN0cmVhbScsXG4gICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlLCBuby10cmFuc2Zvcm0nLFxuICAnWC1BY2NlbC1CdWZmZXJpbmcnOiAnbm8nLFxuICBDb25uZWN0aW9uOiAna2VlcC1hbGl2ZScsXG59IGFzIGNvbnN0O1xuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqL1xuaW1wb3J0IHtcbiAgaXNPYnNlcnZhYmxlLFxuICBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlLFxufSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL29ic2VydmFibGUnO1xuaW1wb3J0IHsgZ2V0RXJyb3JTaGFwZSB9IGZyb20gJy4uL2Vycm9yL2dldEVycm9yU2hhcGUnO1xuaW1wb3J0IHsgZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24sIFRSUENFcnJvciB9IGZyb20gJy4uL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgdHlwZSB7IFByb2NlZHVyZVR5cGUgfSBmcm9tICcuLi9wcm9jZWR1cmUnO1xuaW1wb3J0IHtcbiAgdHlwZSBBbnlSb3V0ZXIsXG4gIHR5cGUgaW5mZXJSb3V0ZXJDb250ZXh0LFxuICB0eXBlIGluZmVyUm91dGVyRXJyb3IsXG59IGZyb20gJy4uL3JvdXRlcic7XG5pbXBvcnQgdHlwZSB7IFRSUENSZXNwb25zZSB9IGZyb20gJy4uL3JwYyc7XG5pbXBvcnQgeyBpc1Byb21pc2UsIGpzb25sU3RyZWFtUHJvZHVjZXIgfSBmcm9tICcuLi9zdHJlYW0vanNvbmwnO1xuaW1wb3J0IHsgc3NlSGVhZGVycywgc3NlU3RyZWFtUHJvZHVjZXIgfSBmcm9tICcuLi9zdHJlYW0vc3NlJztcbmltcG9ydCB7IHRyYW5zZm9ybVRSUENSZXNwb25zZSB9IGZyb20gJy4uL3RyYW5zZm9ybWVyJztcbmltcG9ydCB7IGlzQXN5bmNJdGVyYWJsZSwgaXNPYmplY3QsIHJ1biB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7IGdldFJlcXVlc3RJbmZvIH0gZnJvbSAnLi9jb250ZW50VHlwZSc7XG5pbXBvcnQgeyBnZXRIVFRQU3RhdHVzQ29kZSB9IGZyb20gJy4vZ2V0SFRUUFN0YXR1c0NvZGUnO1xuaW1wb3J0IHR5cGUge1xuICBIVFRQQmFzZUhhbmRsZXJPcHRpb25zLFxuICBSZXNvbHZlSFRUUFJlcXVlc3RPcHRpb25zQ29udGV4dEZuLFxuICBUUlBDUmVxdWVzdEluZm8sXG59IGZyb20gJy4vdHlwZXMnO1xuXG5mdW5jdGlvbiBlcnJvclRvQXN5bmNJdGVyYWJsZShlcnI6IFRSUENFcnJvcik6IEFzeW5jSXRlcmFibGU8bmV2ZXI+IHtcbiAgcmV0dXJuIHJ1bihhc3luYyBmdW5jdGlvbiogKCkge1xuICAgIHRocm93IGVycjtcbiAgfSk7XG59XG50eXBlIEhUVFBNZXRob2RzID1cbiAgfCAnR0VUJ1xuICB8ICdQT1NUJ1xuICB8ICdIRUFEJ1xuICB8ICdPUFRJT05TJ1xuICB8ICdQVVQnXG4gIHwgJ0RFTEVURSdcbiAgfCAnUEFUQ0gnO1xuXG5jb25zdCBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA6IFJlY29yZDxQcm9jZWR1cmVUeXBlLCBIVFRQTWV0aG9kc1tdPiA9IHtcbiAgbXV0YXRpb246IFsnUE9TVCddLFxuICBxdWVyeTogWydHRVQnXSxcbiAgc3Vic2NyaXB0aW9uOiBbJ0dFVCddLFxufTtcbmNvbnN0IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERTogUmVjb3JkPFxuICBQcm9jZWR1cmVUeXBlLFxuICBIVFRQTWV0aG9kc1tdXG4+ID0ge1xuICAvLyBuZXZlciBhbGxvdyBHRVQgdG8gZG8gYSBtdXRhdGlvblxuICBtdXRhdGlvbjogWydQT1NUJ10sXG4gIHF1ZXJ5OiBbJ0dFVCcsICdQT1NUJ10sXG4gIHN1YnNjcmlwdGlvbjogWydHRVQnLCAnUE9TVCddLFxufTtcblxuaW50ZXJmYWNlIFJlc29sdmVIVFRQUmVxdWVzdE9wdGlvbnM8VFJvdXRlciBleHRlbmRzIEFueVJvdXRlcj5cbiAgZXh0ZW5kcyBIVFRQQmFzZUhhbmRsZXJPcHRpb25zPFRSb3V0ZXIsIFJlcXVlc3Q+IHtcbiAgY3JlYXRlQ29udGV4dDogUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uc0NvbnRleHRGbjxUUm91dGVyPjtcbiAgcmVxOiBSZXF1ZXN0O1xuICBwYXRoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBoYWQgYW4gaXNzdWUgYmVmb3JlIHJlYWNoaW5nIHRoZSBoYW5kbGVyXG4gICAqL1xuICBlcnJvcjogVFJQQ0Vycm9yIHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdFJlc3BvbnNlPFRSb3V0ZXIgZXh0ZW5kcyBBbnlSb3V0ZXIsIFRSZXF1ZXN0Pihpbml0T3B0czoge1xuICBjdHg6IGluZmVyUm91dGVyQ29udGV4dDxUUm91dGVyPiB8IHVuZGVmaW5lZDtcbiAgaW5mbzogVFJQQ1JlcXVlc3RJbmZvIHwgdW5kZWZpbmVkO1xuICByZXNwb25zZU1ldGE/OiBIVFRQQmFzZUhhbmRsZXJPcHRpb25zPFRSb3V0ZXIsIFRSZXF1ZXN0PlsncmVzcG9uc2VNZXRhJ107XG4gIHVudHJhbnNmb3JtZWRKU09OOlxuICAgIHwgVFJQQ1Jlc3BvbnNlPHVua25vd24sIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+XG4gICAgfCBUUlBDUmVzcG9uc2U8dW5rbm93biwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj5bXVxuICAgIHwgbnVsbDtcbiAgZXJyb3JzOiBUUlBDRXJyb3JbXTtcbiAgaGVhZGVyczogSGVhZGVycztcbn0pIHtcbiAgY29uc3Qge1xuICAgIGN0eCxcbiAgICBpbmZvLFxuICAgIHJlc3BvbnNlTWV0YSxcbiAgICB1bnRyYW5zZm9ybWVkSlNPTixcbiAgICBlcnJvcnMgPSBbXSxcbiAgICBoZWFkZXJzLFxuICB9ID0gaW5pdE9wdHM7XG5cbiAgbGV0IHN0YXR1cyA9IHVudHJhbnNmb3JtZWRKU09OID8gZ2V0SFRUUFN0YXR1c0NvZGUodW50cmFuc2Zvcm1lZEpTT04pIDogMjAwO1xuXG4gIGNvbnN0IGVhZ2VyR2VuZXJhdGlvbiA9ICF1bnRyYW5zZm9ybWVkSlNPTjtcbiAgY29uc3QgZGF0YSA9IGVhZ2VyR2VuZXJhdGlvblxuICAgID8gW11cbiAgICA6IEFycmF5LmlzQXJyYXkodW50cmFuc2Zvcm1lZEpTT04pXG4gICAgICA/IHVudHJhbnNmb3JtZWRKU09OXG4gICAgICA6IFt1bnRyYW5zZm9ybWVkSlNPTl07XG5cbiAgY29uc3QgbWV0YSA9XG4gICAgcmVzcG9uc2VNZXRhPy4oe1xuICAgICAgY3R4LFxuICAgICAgaW5mbyxcbiAgICAgIHBhdGhzOiBpbmZvPy5jYWxscy5tYXAoKGNhbGwpID0+IGNhbGwucGF0aCksXG4gICAgICBkYXRhLFxuICAgICAgZXJyb3JzLFxuICAgICAgZWFnZXJHZW5lcmF0aW9uLFxuICAgICAgdHlwZTpcbiAgICAgICAgaW5mbz8uY2FsbHMuZmluZCgoY2FsbCkgPT4gY2FsbC5wcm9jZWR1cmU/Ll9kZWYudHlwZSk/LnByb2NlZHVyZT8uX2RlZlxuICAgICAgICAgIC50eXBlID8/ICd1bmtub3duJyxcbiAgICB9KSA/PyB7fTtcblxuICBpZiAobWV0YS5oZWFkZXJzKSB7XG4gICAgaWYgKG1ldGEuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1ldGEuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogQGRlcHJlY2F0ZWQsIGRlbGV0ZSBpbiB2MTJcbiAgICAgICAqL1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YS5oZWFkZXJzKSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobWV0YS5zdGF0dXMpIHtcbiAgICBzdGF0dXMgPSBtZXRhLnN0YXR1cztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhdHVzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBjYXVnaHRFcnJvclRvRGF0YTxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPihcbiAgY2F1c2U6IHVua25vd24sXG4gIGVycm9yT3B0czoge1xuICAgIG9wdHM6IFBpY2s8XG4gICAgICBSZXNvbHZlSFRUUFJlcXVlc3RPcHRpb25zPFRSb3V0ZXI+LFxuICAgICAgJ29uRXJyb3InIHwgJ3JlcScgfCAncm91dGVyJ1xuICAgID47XG4gICAgY3R4OiBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlcj4gfCB1bmRlZmluZWQ7XG4gICAgdHlwZTogUHJvY2VkdXJlVHlwZSB8ICd1bmtub3duJztcbiAgICBwYXRoPzogc3RyaW5nO1xuICAgIGlucHV0PzogdW5rbm93bjtcbiAgfSxcbikge1xuICBjb25zdCB7IHJvdXRlciwgcmVxLCBvbkVycm9yIH0gPSBlcnJvck9wdHMub3B0cztcbiAgY29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSk7XG4gIG9uRXJyb3I/Lih7XG4gICAgZXJyb3IsXG4gICAgcGF0aDogZXJyb3JPcHRzLnBhdGgsXG4gICAgaW5wdXQ6IGVycm9yT3B0cy5pbnB1dCxcbiAgICBjdHg6IGVycm9yT3B0cy5jdHgsXG4gICAgdHlwZTogZXJyb3JPcHRzLnR5cGUsXG4gICAgcmVxLFxuICB9KTtcbiAgY29uc3QgdW50cmFuc2Zvcm1lZEpTT04gPSB7XG4gICAgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuICAgICAgY29uZmlnOiByb3V0ZXIuX2RlZi5fY29uZmlnLFxuICAgICAgZXJyb3IsXG4gICAgICB0eXBlOiBlcnJvck9wdHMudHlwZSxcbiAgICAgIHBhdGg6IGVycm9yT3B0cy5wYXRoLFxuICAgICAgaW5wdXQ6IGVycm9yT3B0cy5pbnB1dCxcbiAgICAgIGN0eDogZXJyb3JPcHRzLmN0eCxcbiAgICB9KSxcbiAgfTtcbiAgY29uc3QgdHJhbnNmb3JtZWRKU09OID0gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKFxuICAgIHJvdXRlci5fZGVmLl9jb25maWcsXG4gICAgdW50cmFuc2Zvcm1lZEpTT04sXG4gICk7XG4gIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEpTT04pO1xuICByZXR1cm4ge1xuICAgIGVycm9yLFxuICAgIHVudHJhbnNmb3JtZWRKU09OLFxuICAgIGJvZHksXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHN0cmVhbS1saWtlIG9iamVjdFxuICogLSBpZiBpdCdzIGFuIGFzeW5jIGl0ZXJhYmxlXG4gKiAtIGlmIGl0J3MgYW4gb2JqZWN0IHdpdGggYXN5bmMgaXRlcmFibGVzIG9yIHByb21pc2VzXG4gKi9cbmZ1bmN0aW9uIGlzRGF0YVN0cmVhbSh2OiB1bmtub3duKSB7XG4gIGlmICghaXNPYmplY3QodikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNBc3luY0l0ZXJhYmxlKHYpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIE9iamVjdC52YWx1ZXModikuc29tZShpc1Byb21pc2UpIHx8IE9iamVjdC52YWx1ZXModikuc29tZShpc0FzeW5jSXRlcmFibGUpXG4gICk7XG59XG5cbnR5cGUgUmVzdWx0VHVwbGU8VD4gPSBbdW5kZWZpbmVkLCBUXSB8IFtUUlBDRXJyb3IsIHVuZGVmaW5lZF07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlUmVzcG9uc2U8VFJvdXRlciBleHRlbmRzIEFueVJvdXRlcj4oXG4gIG9wdHM6IFJlc29sdmVIVFRQUmVxdWVzdE9wdGlvbnM8VFJvdXRlcj4sXG4pOiBQcm9taXNlPFJlc3BvbnNlPiB7XG4gIGNvbnN0IHsgcm91dGVyLCByZXEgfSA9IG9wdHM7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhbWyd2YXJ5JywgJ3RycGMtYWNjZXB0J11dKTtcbiAgY29uc3QgY29uZmlnID0gcm91dGVyLl9kZWYuX2NvbmZpZztcblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuXG4gIGlmIChyZXEubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAvLyBjYW4gYmUgdXNlZCBmb3IgbGFtYmRhIHdhcm11cFxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgc3RhdHVzOiAyMDQsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBhbGxvd0JhdGNoaW5nID0gb3B0cy5hbGxvd0JhdGNoaW5nID8/IG9wdHMuYmF0Y2hpbmc/LmVuYWJsZWQgPz8gdHJ1ZTtcbiAgY29uc3QgYWxsb3dNZXRob2RPdmVycmlkZSA9XG4gICAgKG9wdHMuYWxsb3dNZXRob2RPdmVycmlkZSA/PyBmYWxzZSkgJiYgcmVxLm1ldGhvZCA9PT0gJ1BPU1QnO1xuXG4gIHR5cGUgJENvbnRleHQgPSBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlcj47XG5cbiAgY29uc3QgaW5mb1R1cGxlOiBSZXN1bHRUdXBsZTxUUlBDUmVxdWVzdEluZm8+ID0gYXdhaXQgcnVuKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBhd2FpdCBnZXRSZXF1ZXN0SW5mbyh7XG4gICAgICAgICAgcmVxLFxuICAgICAgICAgIHBhdGg6IGRlY29kZVVSSUNvbXBvbmVudChvcHRzLnBhdGgpLFxuICAgICAgICAgIHJvdXRlcixcbiAgICAgICAgICBzZWFyY2hQYXJhbXM6IHVybC5zZWFyY2hQYXJhbXMsXG4gICAgICAgICAgaGVhZGVyczogb3B0cy5yZXEuaGVhZGVycyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgIH0pLFxuICAgICAgXTtcbiAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgcmV0dXJuIFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHVuZGVmaW5lZF07XG4gICAgfVxuICB9KTtcblxuICBpbnRlcmZhY2UgQ29udGV4dE1hbmFnZXIge1xuICAgIHZhbHVlT3JVbmRlZmluZWQ6ICgpID0+ICRDb250ZXh0IHwgdW5kZWZpbmVkO1xuICAgIHZhbHVlOiAoKSA9PiAkQ29udGV4dDtcbiAgICBjcmVhdGU6IChpbmZvOiBUUlBDUmVxdWVzdEluZm8pID0+IFByb21pc2U8dm9pZD47XG4gIH1cbiAgY29uc3QgY3R4TWFuYWdlcjogQ29udGV4dE1hbmFnZXIgPSBydW4oKCkgPT4ge1xuICAgIGxldCByZXN1bHQ6IFJlc3VsdFR1cGxlPCRDb250ZXh0PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWVPclVuZGVmaW5lZDogKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICAgIH0sXG4gICAgICB2YWx1ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBbZXJyLCBjdHhdID0gcmVzdWx0ITtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4O1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZTogYXN5bmMgKGluZm8pID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIC0gcmVwb3J0IGEgYnVnIGluIHRSUEMnLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdHggPSBhd2FpdCBvcHRzLmNyZWF0ZUNvbnRleHQoe1xuICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN1bHQgPSBbdW5kZWZpbmVkLCBjdHhdO1xuICAgICAgICB9IGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHVuZGVmaW5lZF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfSk7XG5cbiAgY29uc3QgbWV0aG9kTWFwcGVyID0gYWxsb3dNZXRob2RPdmVycmlkZVxuICAgID8gVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQX1dJVEhfTUVUSE9EX09WRVJSSURFXG4gICAgOiBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBjb25zdCBpc1N0cmVhbUNhbGwgPSByZXEuaGVhZGVycy5nZXQoJ3RycGMtYWNjZXB0JykgPT09ICdhcHBsaWNhdGlvbi9qc29ubCc7XG5cbiAgY29uc3QgZXhwZXJpbWVudGFsU1NFID0gY29uZmlnLnNzZT8uZW5hYmxlZCA/PyB0cnVlO1xuICB0cnkge1xuICAgIGNvbnN0IFtpbmZvRXJyb3IsIGluZm9dID0gaW5mb1R1cGxlO1xuICAgIGlmIChpbmZvRXJyb3IpIHtcbiAgICAgIHRocm93IGluZm9FcnJvcjtcbiAgICB9XG4gICAgaWYgKGluZm8uaXNCYXRjaENhbGwgJiYgIWFsbG93QmF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBjb2RlOiAnQkFEX1JFUVVFU1QnLFxuICAgICAgICBtZXNzYWdlOiBgQmF0Y2hpbmcgaXMgbm90IGVuYWJsZWQgb24gdGhlIHNlcnZlcmAsXG4gICAgICB9KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuICAgIGlmIChpc1N0cmVhbUNhbGwgJiYgIWluZm8uaXNCYXRjaENhbGwpIHtcbiAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgU3RyZWFtaW5nIHJlcXVlc3RzIG11c3QgYmUgYmF0Y2hlZCAoeW91IGNhbiBkbyBhIGJhdGNoIG9mIDEpYCxcbiAgICAgICAgY29kZTogJ0JBRF9SRVFVRVNUJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBjdHhNYW5hZ2VyLmNyZWF0ZShpbmZvKTtcblxuICAgIGludGVyZmFjZSBSUENSZXN1bHRPayB7XG4gICAgICBkYXRhOiB1bmtub3duO1xuICAgIH1cbiAgICB0eXBlIFJQQ1Jlc3VsdCA9IFJlc3VsdFR1cGxlPFJQQ1Jlc3VsdE9rPjtcbiAgICBjb25zdCBycGNDYWxscyA9IGluZm8uY2FsbHMubWFwKGFzeW5jIChjYWxsKTogUHJvbWlzZTxSUENSZXN1bHQ+ID0+IHtcbiAgICAgIGNvbnN0IHByb2MgPSBjYWxsLnByb2NlZHVyZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRzLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgb3B0cy5lcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvYykge1xuICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgTm8gcHJvY2VkdXJlIGZvdW5kIG9uIHBhdGggXCIke2NhbGwucGF0aH1cImAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1ldGhvZE1hcHBlcltwcm9jLl9kZWYudHlwZV0uaW5jbHVkZXMocmVxLm1ldGhvZCBhcyBIVFRQTWV0aG9kcykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgJHtyZXEubWV0aG9kfS1yZXF1ZXN0IHRvICR7cHJvYy5fZGVmLnR5cGV9IHByb2NlZHVyZSBhdCBwYXRoIFwiJHtjYWxsLnBhdGh9XCJgLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2MuX2RlZi50eXBlID09PSAnc3Vic2NyaXB0aW9uJykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cbiAgICAgICAgICBpZiAoaW5mby5pc0JhdGNoQ2FsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6ICdCQURfUkVRVUVTVCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgYmF0Y2ggc3Vic2NyaXB0aW9uIGNhbGxzYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhOiB1bmtub3duID0gYXdhaXQgcHJvYyh7XG4gICAgICAgICAgcGF0aDogY2FsbC5wYXRoLFxuICAgICAgICAgIGdldFJhd0lucHV0OiBjYWxsLmdldFJhd0lucHV0LFxuICAgICAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZSgpLFxuICAgICAgICAgIHR5cGU6IHByb2MuX2RlZi50eXBlLFxuICAgICAgICAgIHNpZ25hbDogb3B0cy5yZXEuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIHsgZGF0YSB9XTtcbiAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IGNhbGwucmVzdWx0KCk7XG5cbiAgICAgICAgb3B0cy5vbkVycm9yPy4oe1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIHBhdGg6IGNhbGwucGF0aCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgICAgIHR5cGU6IGNhbGwucHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gJ3Vua25vd24nLFxuICAgICAgICAgIHJlcTogb3B0cy5yZXEsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLSByZXNwb25zZSBoYW5kbGVycyAtLS0tLS0tLS0tLVxuICAgIGlmICghaW5mby5pc0JhdGNoQ2FsbCkge1xuICAgICAgY29uc3QgW2NhbGxdID0gaW5mby5jYWxscztcbiAgICAgIGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJwY0NhbGxzWzBdITtcblxuICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5rbm93bic6XG4gICAgICAgIGNhc2UgJ211dGF0aW9uJzpcbiAgICAgICAgY2FzZSAncXVlcnknOiB7XG4gICAgICAgICAgLy8gaHR0cExpbmtcbiAgICAgICAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcblxuICAgICAgICAgIGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0Py5kYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgIGNvZGU6ICdVTlNVUFBPUlRFRF9NRURJQV9UWVBFJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAnQ2Fubm90IHVzZSBzdHJlYW0tbGlrZSByZXNwb25zZSBpbiBub24tc3RyZWFtaW5nIHJlcXVlc3QgLSB1c2UgaHR0cEJhdGNoU3RyZWFtTGluaycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzOiBUUlBDUmVzcG9uc2U8dW5rbm93biwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4gPSBlcnJvclxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuICAgICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNhbGwhLnJlc3VsdCgpLFxuICAgICAgICAgICAgICAgICAgcGF0aDogY2FsbCEucGF0aCxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IGluZm8udHlwZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7IHJlc3VsdDogeyBkYXRhOiByZXN1bHQuZGF0YSB9IH07XG5cbiAgICAgICAgICBjb25zdCBoZWFkUmVzcG9uc2UgPSBpbml0UmVzcG9uc2Uoe1xuICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgIGluZm8sXG4gICAgICAgICAgICByZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuICAgICAgICAgICAgZXJyb3JzOiBlcnJvciA/IFtlcnJvcl0gOiBbXSxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB1bnRyYW5zZm9ybWVkSlNPTjogW3Jlc10sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybVRSUENSZXNwb25zZShjb25maWcsIHJlcykpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3Vic2NyaXB0aW9uJzoge1xuICAgICAgICAgIC8vIGh0dHBTdWJzY3JpcHRpb25MaW5rXG5cbiAgICAgICAgICBjb25zdCBpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTx1bmtub3duPiA9IHJ1bigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yVG9Bc3luY0l0ZXJhYmxlKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXhwZXJpbWVudGFsU1NFKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlcnJvclRvQXN5bmNJdGVyYWJsZShcbiAgICAgICAgICAgICAgICBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdNRVRIT0RfTk9UX1NVUFBPUlRFRCcsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnTWlzc2luZyBleHBlcmltZW50YWwgZmxhZyBcInNzZVN1YnNjcmlwdGlvbnNcIicsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNPYnNlcnZhYmxlKHJlc3VsdC5kYXRhKSAmJiAhaXNBc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZXJyb3JUb0FzeW5jSXRlcmFibGUoXG4gICAgICAgICAgICAgICAgbmV3IFRSUENFcnJvcih7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgU3Vic2NyaXB0aW9uICR7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwhLnBhdGhcbiAgICAgICAgICAgICAgICAgIH0gZGlkIG5vdCByZXR1cm4gYW4gb2JzZXJ2YWJsZSBvciBhIEFzeW5jR2VuZXJhdG9yYCxcbiAgICAgICAgICAgICAgICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YUFzSXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpXG4gICAgICAgICAgICAgID8gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSwgb3B0cy5yZXEuc2lnbmFsKVxuICAgICAgICAgICAgICA6IHJlc3VsdC5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFBc0l0ZXJhYmxlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gc3NlU3RyZWFtUHJvZHVjZXIoe1xuICAgICAgICAgICAgLi4uY29uZmlnLnNzZSxcbiAgICAgICAgICAgIGRhdGE6IGl0ZXJhYmxlLFxuICAgICAgICAgICAgc2VyaWFsaXplOiAodikgPT4gY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUodiksXG4gICAgICAgICAgICBmb3JtYXRFcnJvcihlcnJvck9wdHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihlcnJvck9wdHMuZXJyb3IpO1xuICAgICAgICAgICAgICBjb25zdCBpbnB1dCA9IGNhbGw/LnJlc3VsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBwYXRoID0gY2FsbD8ucGF0aDtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNhbGw/LnByb2NlZHVyZT8uX2RlZi50eXBlID8/ICd1bmtub3duJztcblxuICAgICAgICAgICAgICBvcHRzLm9uRXJyb3I/Lih7XG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgICAgICAgICAgIHJlcTogb3B0cy5yZXEsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBnZXRFcnJvclNoYXBlKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3NlSGVhZGVycykpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG4gICAgICAgICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgIHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG4gICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHVudHJhbnNmb3JtZWRKU09OOiBudWxsLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBiYXRjaCByZXNwb25zZSBoYW5kbGVyc1xuICAgIGlmIChpbmZvLmFjY2VwdCA9PT0gJ2FwcGxpY2F0aW9uL2pzb25sJykge1xuICAgICAgLy8gaHR0cEJhdGNoU3RyZWFtTGlua1xuICAgICAgaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICBoZWFkZXJzLnNldCgndHJhbnNmZXItZW5jb2RpbmcnLCAnY2h1bmtlZCcpO1xuICAgICAgY29uc3QgaGVhZFJlc3BvbnNlID0gaW5pdFJlc3BvbnNlKHtcbiAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgaW5mbyxcbiAgICAgICAgcmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcbiAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgdW50cmFuc2Zvcm1lZEpTT046IG51bGwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGpzb25sU3RyZWFtUHJvZHVjZXIoe1xuICAgICAgICAuLi5jb25maWcuanNvbmwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGFtcGxlIHN0cnVjdHVyZSBmb3IgYG1heERlcHRoOiA0YDpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgIC8vIDFcbiAgICAgICAgICogICAwOiB7XG4gICAgICAgICAqICAgICAvLyAyXG4gICAgICAgICAqICAgICByZXN1bHQ6IHtcbiAgICAgICAgICogICAgICAgLy8gM1xuICAgICAgICAgKiAgICAgICBkYXRhOiAvLyA0XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9XG4gICAgICAgICAqL1xuICAgICAgICBtYXhEZXB0aDogSW5maW5pdHksXG4gICAgICAgIGRhdGE6IHJwY0NhbGxzLm1hcChhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgY29uc3QgW2Vycm9yLCByZXN1bHRdID0gYXdhaXQgcmVzO1xuXG4gICAgICAgICAgY29uc3QgY2FsbCA9IGluZm8uY2FsbHNbMF07XG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvclNoYXBlKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBpbnB1dDogY2FsbCEucmVzdWx0KCksXG4gICAgICAgICAgICAgICAgcGF0aDogY2FsbCEucGF0aCxcbiAgICAgICAgICAgICAgICB0eXBlOiBjYWxsIS5wcm9jZWR1cmU/Ll9kZWYudHlwZSA/PyAndW5rbm93bicsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBOb3QgdmVyeSBwcmV0dHksIGJ1dCB3ZSBuZWVkIHRvIHdyYXAgbmVzdGVkIGRhdGEgaW4gcHJvbWlzZXNcbiAgICAgICAgICAgKiBPdXIgc3RyZWFtIHByb2R1Y2VyIHdpbGwgb25seSByZXNvbHZlIHRvcC1sZXZlbCBhc3luYyB2YWx1ZXMgb3IgYXN5bmMgdmFsdWVzIHRoYXQgYXJlIGRpcmVjdGx5IG5lc3RlZCBpbiBhbm90aGVyIGFzeW5jIHZhbHVlXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgaXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpXG4gICAgICAgICAgICA/IG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUocmVzdWx0LmRhdGEsIG9wdHMucmVxLnNpZ25hbClcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHJlc3VsdC5kYXRhKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdWx0OiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhOiBpdGVyYWJsZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICBzZXJpYWxpemU6IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplLFxuICAgICAgICBvbkVycm9yOiAoY2F1c2UpID0+IHtcbiAgICAgICAgICBvcHRzLm9uRXJyb3I/Lih7XG4gICAgICAgICAgICBlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuICAgICAgICAgICAgcGF0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG4gICAgICAgICAgICByZXE6IG9wdHMucmVxLFxuICAgICAgICAgICAgdHlwZTogaW5mbz8udHlwZSA/PyAndW5rbm93bicsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0RXJyb3IoZXJyb3JPcHRzKSB7XG4gICAgICAgICAgY29uc3QgY2FsbCA9IGluZm8/LmNhbGxzW2Vycm9yT3B0cy5wYXRoWzBdIGFzIGFueV07XG5cbiAgICAgICAgICBjb25zdCBlcnJvciA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGVycm9yT3B0cy5lcnJvcik7XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBjYWxsPy5yZXN1bHQoKTtcbiAgICAgICAgICBjb25zdCBwYXRoID0gY2FsbD8ucGF0aDtcbiAgICAgICAgICBjb25zdCB0eXBlID0gY2FsbD8ucHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gJ3Vua25vd24nO1xuXG4gICAgICAgICAgLy8gbm8gbmVlZCB0byBjYWxsIGBvbkVycm9yYCBoZXJlIGFzIGl0IHdpbGwgYmUgcHJvcGFnYXRlZCB0aHJvdWdoIHRoZSBzdHJlYW0gaXRzZWxmXG5cbiAgICAgICAgICBjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgY3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHN0cmVhbSwge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBodHRwQmF0Y2hMaW5rXG4gICAgLyoqXG4gICAgICogTm9uLXN0cmVhbWluZyByZXNwb25zZTpcbiAgICAgKiAtIGF3YWl0IGFsbCByZXNwb25zZXMgaW4gcGFyYWxsZWwsIGJsb2NraW5nIG9uIHRoZSBzbG93ZXN0IG9uZVxuICAgICAqIC0gY3JlYXRlIGhlYWRlcnMgd2l0aCBrbm93biByZXNwb25zZSBib2R5XG4gICAgICogLSByZXR1cm4gYSBjb21wbGV0ZSBIVFRQUmVzcG9uc2VcbiAgICAgKi9cbiAgICBoZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICBjb25zdCByZXN1bHRzOiBSUENSZXN1bHRbXSA9IChhd2FpdCBQcm9taXNlLmFsbChycGNDYWxscykpLm1hcChcbiAgICAgIChyZXMpOiBSUENSZXN1bHQgPT4ge1xuICAgICAgICBjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSByZXM7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEYXRhU3RyZWFtKHJlc3VsdC5kYXRhKSkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgVFJQQ0Vycm9yKHtcbiAgICAgICAgICAgICAgY29kZTogJ1VOU1VQUE9SVEVEX01FRElBX1RZUEUnLFxuICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICdDYW5ub3QgdXNlIHN0cmVhbS1saWtlIHJlc3BvbnNlIGluIG5vbi1zdHJlYW1pbmcgcmVxdWVzdCAtIHVzZSBodHRwQmF0Y2hTdHJlYW1MaW5rJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH0sXG4gICAgKTtcbiAgICBjb25zdCByZXN1bHRBc1JQQ1Jlc3BvbnNlID0gcmVzdWx0cy5tYXAoXG4gICAgICAoXG4gICAgICAgIFtlcnJvciwgcmVzdWx0XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICApOiBUUlBDUmVzcG9uc2U8dW5rbm93biwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4gPT4ge1xuICAgICAgICBjb25zdCBjYWxsID0gaW5mby5jYWxsc1tpbmRleF0hO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG4gICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICBpbnB1dDogY2FsbC5yZXN1bHQoKSxcbiAgICAgICAgICAgICAgcGF0aDogY2FsbC5wYXRoLFxuICAgICAgICAgICAgICB0eXBlOiBjYWxsLnByb2NlZHVyZT8uX2RlZi50eXBlID8/ICd1bmtub3duJyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXN1bHQ6IHsgZGF0YTogcmVzdWx0LmRhdGEgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGNvbnN0IGVycm9ycyA9IHJlc3VsdHNcbiAgICAgIC5tYXAoKFtlcnJvcl0pID0+IGVycm9yKVxuICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBUUlBDRXJyb3JbXTtcblxuICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG4gICAgICBjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuICAgICAgaW5mbyxcbiAgICAgIHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG4gICAgICB1bnRyYW5zZm9ybWVkSlNPTjogcmVzdWx0QXNSUENSZXNwb25zZSxcbiAgICAgIGVycm9ycyxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkodHJhbnNmb3JtVFJQQ1Jlc3BvbnNlKGNvbmZpZywgcmVzdWx0QXNSUENSZXNwb25zZSkpLFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IGhlYWRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICB9LFxuICAgICk7XG4gIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgY29uc3QgW19pbmZvRXJyb3IsIGluZm9dID0gaW5mb1R1cGxlO1xuICAgIGNvbnN0IGN0eCA9IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpO1xuICAgIC8vIHdlIGdldCBoZXJlIGlmXG4gICAgLy8gLSBiYXRjaGluZyBpcyBjYWxsZWQgd2hlbiBpdCdzIG5vdCBlbmFibGVkXG4gICAgLy8gLSBgY3JlYXRlQ29udGV4dCgpYCB0aHJvd3NcbiAgICAvLyAtIGByb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoKWAgdGhyb3dzXG4gICAgLy8gLSBwb3N0IGJvZHkgaXMgdG9vIGxhcmdlXG4gICAgLy8gLSBpbnB1dCBkZXNlcmlhbGl6YXRpb24gZmFpbHNcbiAgICAvLyAtIGBlcnJvckZvcm1hdHRlcmAgcmV0dXJuIHZhbHVlIGlzIG1hbGZvcm1lZFxuICAgIGNvbnN0IHsgZXJyb3IsIHVudHJhbnNmb3JtZWRKU09OLCBib2R5IH0gPSBjYXVnaHRFcnJvclRvRGF0YShjYXVzZSwge1xuICAgICAgb3B0cyxcbiAgICAgIGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG4gICAgICB0eXBlOiBpbmZvPy50eXBlID8/ICd1bmtub3duJyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG4gICAgICBjdHgsXG4gICAgICBpbmZvLFxuICAgICAgcmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcbiAgICAgIHVudHJhbnNmb3JtZWRKU09OLFxuICAgICAgZXJyb3JzOiBbZXJyb3JdLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuICAgICAgc3RhdHVzOiBoZWFkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbInBhcnNlZDogdW5rbm93biIsInN0cjogc3RyaW5nIiwiZm46ICgpID0+IFByb21pc2U8VFJldHVybj4iLCJwcm9taXNlOiBQcm9taXNlPFRSZXR1cm4+IHwgbnVsbCIsInZhbHVlOiBUUmV0dXJuIHwgdHlwZW9mIHN5bSIsImpzb25Db250ZW50VHlwZUhhbmRsZXI6IENvbnRlbnRUeXBlSGFuZGxlciIsImlucHV0czogdW5rbm93biIsImFjYzogSW5wdXRSZWNvcmQiLCJ0eXBlOiBQcm9jZWR1cmVUeXBlIHwgJ3Vua25vd24nIiwiaW5mbzogVFJQQ1JlcXVlc3RJbmZvIiwiZm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXI6IENvbnRlbnRUeXBlSGFuZGxlciIsIm9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyOiBDb250ZW50VHlwZUhhbmRsZXIiLCJyZXE6IFJlcXVlc3QiLCJoYW5kbGVyIiwib3B0czogR2V0UmVxdWVzdEluZm9PcHRpb25zIiwiZXJyb3I6IHVua25vd24iLCJhcmc6IFByb21pc2U8VD4gfCBQcm9taXNlTGlrZTxUPiB8IFByb21pc2VFeGVjdXRvcjxUPiIsInByb21pc2U6IFByb21pc2U8VD4iLCJ1bnN1YnNjcmliZTogKCkgPT4gdm9pZCIsIm9uZnVsZmlsbGVkPzpcbiAgICAgIHwgKCh2YWx1ZTogVCkgPT4gVFJlc3VsdDEgfCBQcm9taXNlTGlrZTxUUmVzdWx0MT4pXG4gICAgICB8IG51bGwiLCJvbnJlamVjdGVkPzpcbiAgICAgIHwgKChyZWFzb246IGFueSkgPT4gVFJlc3VsdDIgfCBQcm9taXNlTGlrZTxUUmVzdWx0Mj4pXG4gICAgICB8IG51bGwiLCJvbnJlamVjdGVkPzpcbiAgICAgIHwgKChyZWFzb246IGFueSkgPT4gVFJlc3VsdCB8IFByb21pc2VMaWtlPFRSZXN1bHQ+KVxuICAgICAgfCBudWxsIiwib25maW5hbGx5PzogKCgpID0+IHZvaWQpIHwgbnVsbCIsInByb21pc2U6IFByb21pc2VMaWtlPFQ+IiwidmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPiIsInZhbHVlczogSXRlcmFibGU8VCB8IFByb21pc2VMaWtlPFQ+PiIsInByb21pc2VzOiByZWFkb25seSBUUHJvbWlzZVtdIiwicHJvbWlzZTogVFByb21pc2UiLCJyZXNvbHZlITogUHJvbWlzZVdpdGhSZXNvbHZlcnM8VD5bXCJyZXNvbHZlXCJdIiwicmVqZWN0ITogUHJvbWlzZVdpdGhSZXNvbHZlcnM8VD5bXCJyZWplY3RcIl0iLCJhcnI6IHJlYWRvbmx5IFRbXSIsIm1lbWJlcjogVCIsImluZGV4OiBudW1iZXIiLCJtZW1iZXI6IHVua25vd24iLCJ0aGluZzogVCIsImRpc3Bvc2U6ICgpID0+IHZvaWQiLCJkaXNwb3NlOiAoKSA9PiBQcm9taXNlPHZvaWQ+IiwibXM6IG51bWJlciIsInRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IG51bGwiLCJyIiwiZSIsIm4iLCJvIiwiT3ZlcmxvYWRZaWVsZCIsIl9hd2FpdEFzeW5jR2VuZXJhdG9yIiwiX3dyYXBBc3luY0dlbmVyYXRvciIsInQiLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIFRSZXR1cm4sIFROZXh0PiIsIml0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPFQ+Iiwib3B0czogeyBtYXhEdXJhdGlvbk1zOiBudW1iZXIgfSIsInJlc3VsdDogbnVsbCB8IEl0ZXJhdG9yUmVzdWx0PFQ+IHwgdHlwZW9mIGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQiLCJvcHRzOiB7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgICBncmFjZVBlcmlvZE1zOiBudW1iZXI7XG4gIH0iLCJyZXNvbHZlOiAodmFsdWU6IFRWYWx1ZSkgPT4gdm9pZCIsInJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkIiwiaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCBUUmV0dXJuPiIsIm9uUmVzdWx0OiAocmVzdWx0OiBNYW5hZ2VkSXRlcmF0b3JSZXN1bHQ8VFlpZWxkLCBUUmV0dXJuPikgPT4gdm9pZCIsInN0YXRlOiAnaWRsZScgfCAncGVuZGluZycgfCAnZG9uZSciLCJpdGVyYWJsZXM6IEFzeW5jSXRlcmFibGU8VFlpZWxkLCB2b2lkLCB1bmtub3duPltdIiwiYnVmZmVyOiBBcnJheTxcbiAgICBbXG4gICAgICBpdGVyYXRvcjogTWFuYWdlZEl0ZXJhdG9yPFRZaWVsZCwgdm9pZD4sXG4gICAgICByZXN1bHQ6IEV4Y2x1ZGU8XG4gICAgICAgIE1hbmFnZWRJdGVyYXRvclJlc3VsdDxUWWllbGQsIHZvaWQ+LFxuICAgICAgICB7IHN0YXR1czogJ3JldHVybicgfVxuICAgICAgPixcbiAgICBdXG4gID4iLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQsIHVua25vd24+IiwiZXJyb3JzOiB1bmtub3duW10iLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUWWllbGQsIHZvaWQ+IiwiaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VFZhbHVlPiIsInBpbmdJbnRlcnZhbE1zOiBudW1iZXIiLCJyZXN1bHQ6XG4gICAgfCBudWxsXG4gICAgfCBJdGVyYXRvclJlc3VsdDxUVmFsdWU+XG4gICAgfCB0eXBlb2YgZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCIsIl9hc3luY0l0ZXJhdG9yIiwiQXN5bmNGcm9tU3luY0l0ZXJhdG9yIiwidmFsdWU6IHVua25vd24iLCJwYXRoOiAoc3RyaW5nIHwgbnVtYmVyKVtdIiwib3B0czogSlNPTkxQcm9kdWNlck9wdGlvbnMiLCJjYWxsYmFjazogKGlkeDogQ2h1bmtJbmRleCkgPT4gQXN5bmNJdGVyYWJsZTxDaHVua0RhdGEsIHZvaWQ+IiwiaXRlcmFibGUiLCJwcm9taXNlOiBQcm9taXNlPHVua25vd24+IiwiaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8dW5rbm93bj4iLCJuZXdPYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+IiwiYXN5bmNWYWx1ZXM6IENodW5rRGVmaW5pdGlvbltdIiwibmV3SGVhZDogSGVhZCIsIml0ZXJhYmxlOiBBc3luY0l0ZXJhYmxlPENodW5rRGF0YSB8IHR5cGVvZiBQSU5HX1NZTSwgdm9pZD4iLCJkYXRhOiB1bmtub3duIiwic291cmNlOiBOb2RlSlNSZWFkYWJsZVN0cmVhbUVzcXVlIiwiZnJvbTogTm9kZUpTUmVhZGFibGVTdHJlYW1Fc3F1ZSB8IFdlYlJlYWRhYmxlU3RyZWFtRXNxdWUiLCJjaHVuazogQ2h1bmtEYXRhIiwiYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIiLCJvcmlnaW5hbENvbnRyb2xsZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI8Q2h1bmtEYXRhPiIsInY6IENodW5rRGF0YSIsInJlYXNvbjogdW5rbm93biIsImNodW5rSWQ6IENodW5rSW5kZXgiLCJvcHRzOiB7XG4gIGZyb206IE5vZGVKU1JlYWRhYmxlU3RyZWFtRXNxdWUgfCBXZWJSZWFkYWJsZVN0cmVhbUVzcXVlO1xuICBkZXNlcmlhbGl6ZT86IERlc2VyaWFsaXplO1xuICBvbkVycm9yPzogQ29uc3VtZXJPbkVycm9yO1xuICBmb3JtYXRFcnJvcj86IChvcHRzOiB7IGVycm9yOiB1bmtub3duIH0pID0+IEVycm9yO1xuICAvKipcbiAgICogVGhpcyBgQWJvcnRDb250cm9sbGVyYCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRoZXJlIGFyZSBubyBtb3JlIGxpc3RlbmVycyB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG59IiwiaGVhZERlZmVycmVkOiBudWxsIHwgRGVmZXJyZWQ8VEhlYWQ+IiwidmFsdWU6IENodW5rRGVmaW5pdGlvbiIsInZhbHVlIiwidmFsdWU6IEVuY29kZWRWYWx1ZSIsIl9hc3luY0dlbmVyYXRvckRlbGVnYXRlIiwib3B0czogU1NFU3RyZWFtUHJvZHVjZXJPcHRpb25zPFRWYWx1ZT4iLCJwaW5nOiBSZXF1aXJlZDxTU0VQaW5nT3B0aW9ucz4iLCJjbGllbnQ6IFNTRUNsaWVudE9wdGlvbnMiLCJpdGVyYWJsZTogQXN5bmNJdGVyYWJsZTxUVmFsdWUgfCB0eXBlb2YgUElOR19TWU0+IiwidmFsdWU6IG51bGwgfCBUSXRlcmF0b3JWYWx1ZSIsImNodW5rOiBudWxsIHwgU1NFdmVudCIsImNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyPHN0cmluZz4iLCJvcHRzOiB7XG4gIHByb21pc2U6IFByb21pc2U8VD47XG4gIHRpbWVvdXRNczogbnVtYmVyO1xuICBvblRpbWVvdXQ6ICgpID0+IFByb21pc2U8Tm9JbmZlcjxUPj47XG59Iiwib3B0czogU1NFU3RyZWFtQ29uc3VtZXJPcHRpb25zPFRDb25maWc+IiwiY2xpZW50T3B0aW9uczogU1NFQ2xpZW50T3B0aW9ucyIsIl9lczogSW5zdGFuY2VUeXBlPFRDb25maWdbJ0V2ZW50U291cmNlJ10+IHwgbnVsbCIsIm9wdGlvbnM6IFNTRUNsaWVudE9wdGlvbnMiLCJkZWY6IFNTRXZlbnQiLCJyZXM6IEF3YWl0ZWQ8dHlwZW9mIHByb21pc2U+IiwiZXJyOiBUUlBDRXJyb3IiLCJUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVA6IFJlY29yZDxQcm9jZWR1cmVUeXBlLCBIVFRQTWV0aG9kc1tdPiIsIlRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERTogUmVjb3JkPFxuICBQcm9jZWR1cmVUeXBlLFxuICBIVFRQTWV0aG9kc1tdXG4+IiwiaW5pdE9wdHM6IHtcbiAgY3R4OiBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlcj4gfCB1bmRlZmluZWQ7XG4gIGluZm86IFRSUENSZXF1ZXN0SW5mbyB8IHVuZGVmaW5lZDtcbiAgcmVzcG9uc2VNZXRhPzogSFRUUEJhc2VIYW5kbGVyT3B0aW9uczxUUm91dGVyLCBUUmVxdWVzdD5bJ3Jlc3BvbnNlTWV0YSddO1xuICB1bnRyYW5zZm9ybWVkSlNPTjpcbiAgICB8IFRSUENSZXNwb25zZTx1bmtub3duLCBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXI+PlxuICAgIHwgVFJQQ1Jlc3BvbnNlPHVua25vd24sIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+W11cbiAgICB8IG51bGw7XG4gIGVycm9yczogVFJQQ0Vycm9yW107XG4gIGhlYWRlcnM6IEhlYWRlcnM7XG59IiwiY2F1c2U6IHVua25vd24iLCJlcnJvck9wdHM6IHtcbiAgICBvcHRzOiBQaWNrPFxuICAgICAgUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uczxUUm91dGVyPixcbiAgICAgICdvbkVycm9yJyB8ICdyZXEnIHwgJ3JvdXRlcidcbiAgICA+O1xuICAgIGN0eDogaW5mZXJSb3V0ZXJDb250ZXh0PFRSb3V0ZXI+IHwgdW5kZWZpbmVkO1xuICAgIHR5cGU6IFByb2NlZHVyZVR5cGUgfCAndW5rbm93bic7XG4gICAgcGF0aD86IHN0cmluZztcbiAgICBpbnB1dD86IHVua25vd247XG4gIH0iLCJ2OiB1bmtub3duIiwib3B0czogUmVzb2x2ZUhUVFBSZXF1ZXN0T3B0aW9uczxUUm91dGVyPiIsImluZm9UdXBsZTogUmVzdWx0VHVwbGU8VFJQQ1JlcXVlc3RJbmZvPiIsImN0eE1hbmFnZXI6IENvbnRleHRNYW5hZ2VyIiwicmVzdWx0OiBSZXN1bHRUdXBsZTwkQ29udGV4dD4gfCB1bmRlZmluZWQiLCJyZXM6IFRSUENSZXNwb25zZTx1bmtub3duLCBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXI+PiIsImhlYWRSZXNwb25zZSIsImVycm9yIiwicmVzdWx0czogUlBDUmVzdWx0W10iXSwiaWdub3JlTGlzdCI6WzYsNyw4LDksMTUsMTddLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/resolveResponse-CzlbRpCI.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPCError: () => (/* binding */ TRPCError),\n/* harmony export */   callProcedure: () => (/* binding */ callProcedure),\n/* harmony export */   createCallerFactory: () => (/* binding */ createCallerFactory),\n/* harmony export */   createRouterFactory: () => (/* binding */ createRouterFactory),\n/* harmony export */   defaultFormatter: () => (/* binding */ defaultFormatter),\n/* harmony export */   defaultTransformer: () => (/* binding */ defaultTransformer),\n/* harmony export */   getCauseFromUnknown: () => (/* binding */ getCauseFromUnknown),\n/* harmony export */   getDataTransformer: () => (/* binding */ getDataTransformer),\n/* harmony export */   getProcedureAtPath: () => (/* binding */ getProcedureAtPath),\n/* harmony export */   getTRPCErrorFromUnknown: () => (/* binding */ getTRPCErrorFromUnknown),\n/* harmony export */   isTrackedEnvelope: () => (/* binding */ isTrackedEnvelope),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   mergeRouters: () => (/* binding */ mergeRouters),\n/* harmony export */   sse: () => (/* binding */ sse),\n/* harmony export */   tracked: () => (/* binding */ tracked),\n/* harmony export */   transformResult: () => (/* binding */ transformResult),\n/* harmony export */   transformTRPCResponse: () => (/* binding */ transformTRPCResponse)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getErrorShape-Uhlrl4Bk.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/getErrorShape-Uhlrl4Bk.mjs\");\n/* harmony import */ var _utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-DdbbrDku.mjs */ \"(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\");\n\n\n//#region src/unstable-core-do-not-import/error/formatter.ts\nconst defaultFormatter = ({ shape })=>{\n    return shape;\n};\n//#endregion\n//#region src/unstable-core-do-not-import/error/TRPCError.ts\nvar import_defineProperty = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_defineProperty)(), 1);\nvar UnknownCauseError = class extends Error {\n};\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) return cause;\n    const type = typeof cause;\n    if (type === \"undefined\" || type === \"function\" || cause === null) return void 0;\n    if (type !== \"object\") return new Error(String(cause));\n    if ((0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(cause)) return Object.assign(new UnknownCauseError(), cause);\n    return void 0;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) return cause;\n    if (cause instanceof Error && cause.name === \"TRPCError\") return cause;\n    const trpcError = new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        cause\n    });\n    if (cause instanceof Error && cause.stack) trpcError.stack = cause.stack;\n    return trpcError;\n}\nvar TRPCError = class extends Error {\n    constructor(opts){\n        var _ref, _opts$message, _this$cause;\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = (_ref = (_opts$message = opts.message) !== null && _opts$message !== void 0 ? _opts$message : cause === null || cause === void 0 ? void 0 : cause.message) !== null && _ref !== void 0 ? _ref : opts.code;\n        super(message, {\n            cause\n        });\n        (0, import_defineProperty.default)(this, \"cause\", void 0);\n        (0, import_defineProperty.default)(this, \"code\", void 0);\n        this.code = opts.code;\n        this.name = \"TRPCError\";\n        (_this$cause = this.cause) !== null && _this$cause !== void 0 || (this.cause = cause);\n    }\n};\n//#endregion\n//#region src/unstable-core-do-not-import/transformer.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/**\n* @internal\n*/ function getDataTransformer(transformer) {\n    if (\"input\" in transformer) return transformer;\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n* @internal\n*/ const defaultTransformer = {\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\nfunction transformTRPCResponseItem(config, item) {\n    if (\"error\" in item) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, {\n        error: config.transformer.output.serialize(item.error)\n    });\n    if (\"data\" in item.result) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, {\n        result: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item.result), {}, {\n            data: config.transformer.output.serialize(item.result.data)\n        })\n    });\n    return item;\n}\n/**\n* Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n**/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n/** @internal */ function transformResultInner(response, transformer) {\n    if (\"error\" in response) {\n        const error = transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response), {}, {\n                error\n            })\n        };\n    }\n    const result = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response.result), (!response.result.type || response.result.type === \"data\") && {\n        type: \"data\",\n        data: transformer.deserialize(response.result.data)\n    });\n    return {\n        ok: true,\n        result\n    };\n}\nvar TransformResultError = class extends Error {\n    constructor(){\n        super(\"Unable to transform response from server\");\n    }\n};\n/**\n* Transforms and validates that the result is a valid TRPCResponse\n* @internal\n*/ function transformResult(response, transformer) {\n    let result;\n    try {\n        result = transformResultInner(response, transformer);\n    } catch (_unused) {\n        throw new TransformResultError();\n    }\n    if (!result.ok && (!(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.error.error) || typeof result.error.error[\"code\"] !== \"number\")) throw new TransformResultError();\n    if (result.ok && !(0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.result)) throw new TransformResultError();\n    return result;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/router.ts\nvar import_objectSpread2 = (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\nconst lazySymbol = Symbol(\"lazy\");\nfunction once(fn) {\n    const uncalled = Symbol();\n    let result = uncalled;\n    return ()=>{\n        if (result === uncalled) result = fn();\n        return result;\n    };\n}\n/**\n* Lazy load a router\n* @see https://trpc.io/docs/server/merging-routers#lazy-load\n*/ function lazy(importRouter) {\n    async function resolve() {\n        const mod = await importRouter();\n        if (isRouter(mod)) return mod;\n        const routers = Object.values(mod);\n        if (routers.length !== 1 || !isRouter(routers[0])) throw new Error(\"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\");\n        return routers[0];\n    }\n    resolve[lazySymbol] = true;\n    return resolve;\n}\nfunction isLazy(input) {\n    return typeof input === \"function\" && lazySymbol in input;\n}\nfunction isRouter(value) {\n    return (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value[\"_def\"]) && \"router\" in value[\"_def\"];\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n* Reserved words that can't be used as router or procedure names\n*/ const reservedWords = [\n    \"then\",\n    \"call\",\n    \"apply\"\n];\n/**\n* @internal\n*/ function createRouterFactory(config) {\n    function createRouterInner(input) {\n        const reservedWordsUsed = new Set(Object.keys(input).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) throw new Error(\"Reserved words used in `router({})` call: \" + Array.from(reservedWordsUsed).join(\", \"));\n        const procedures = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n        const lazy$1 = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n        function createLazyLoader(opts) {\n            return {\n                ref: opts.ref,\n                load: once(async ()=>{\n                    const router$1 = await opts.ref();\n                    const lazyPath = [\n                        ...opts.path,\n                        opts.key\n                    ];\n                    const lazyKey = lazyPath.join(\".\");\n                    opts.aggregate[opts.key] = step(router$1._def.record, lazyPath);\n                    delete lazy$1[lazyKey];\n                    for (const [nestedKey, nestedItem] of Object.entries(router$1._def.lazy)){\n                        const nestedRouterKey = [\n                            ...lazyPath,\n                            nestedKey\n                        ].join(\".\");\n                        lazy$1[nestedRouterKey] = createLazyLoader({\n                            ref: nestedItem.ref,\n                            path: lazyPath,\n                            key: nestedKey,\n                            aggregate: opts.aggregate[opts.key]\n                        });\n                    }\n                })\n            };\n        }\n        function step(from, path = []) {\n            const aggregate = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n            for (const [key, item] of Object.entries(from !== null && from !== void 0 ? from : {})){\n                if (isLazy(item)) {\n                    lazy$1[[\n                        ...path,\n                        key\n                    ].join(\".\")] = createLazyLoader({\n                        path,\n                        ref: item,\n                        key,\n                        aggregate\n                    });\n                    continue;\n                }\n                if (isRouter(item)) {\n                    aggregate[key] = step(item._def.record, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                if (!isProcedure(item)) {\n                    aggregate[key] = step(item, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                const newPath = [\n                    ...path,\n                    key\n                ].join(\".\");\n                if (procedures[newPath]) throw new Error(`Duplicate key: ${newPath}`);\n                procedures[newPath] = item;\n                aggregate[key] = item;\n            }\n            return aggregate;\n        }\n        const record = step(input);\n        const _def = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({\n            _config: config,\n            router: true,\n            procedures,\n            lazy: lazy$1\n        }, emptyRouter), {}, {\n            record\n        });\n        const router = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, record), {}, {\n            _def,\n            createCaller: createCallerFactory()({\n                _def\n            })\n        });\n        return router;\n    }\n    return createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n    return typeof procedureOrRouter === \"function\";\n}\n/**\n* @internal\n*/ async function getProcedureAtPath(router, path) {\n    const { _def } = router;\n    let procedure = _def.procedures[path];\n    while(!procedure){\n        const key = Object.keys(_def.lazy).find((key$1)=>path.startsWith(key$1));\n        if (!key) return null;\n        const lazyRouter = _def.lazy[key];\n        await lazyRouter.load();\n        procedure = _def.procedures[path];\n    }\n    return procedure;\n}\n/**\n* @internal\n*/ async function callProcedure(opts) {\n    const { type, path } = opts;\n    const proc = await getProcedureAtPath(opts.router, path);\n    if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) throw new TRPCError({\n        code: \"NOT_FOUND\",\n        message: `No \"${type}\"-procedure on path \"${path}\"`\n    });\n    /* istanbul ignore if -- @preserve */ if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === \"subscription\") throw new TRPCError({\n        code: \"METHOD_NOT_SUPPORTED\",\n        message: `Method override is not supported for subscriptions`\n    });\n    return proc(opts);\n}\nfunction createCallerFactory() {\n    return function createCallerInner(router) {\n        const { _def } = router;\n        return function createCaller(ctxOrCallback, opts) {\n            return (0,_getErrorShape_Uhlrl4Bk_mjs__WEBPACK_IMPORTED_MODULE_0__.createRecursiveProxy)(async ({ path, args })=>{\n                const fullPath = path.join(\".\");\n                if (path.length === 1 && path[0] === \"_def\") return _def;\n                const procedure = await getProcedureAtPath(router, fullPath);\n                let ctx = void 0;\n                try {\n                    if (!procedure) throw new TRPCError({\n                        code: \"NOT_FOUND\",\n                        message: `No procedure found on path \"${path}\"`\n                    });\n                    ctx = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n                    return await procedure({\n                        path: fullPath,\n                        getRawInput: async ()=>args[0],\n                        ctx,\n                        type: procedure._def.type,\n                        signal: opts === null || opts === void 0 ? void 0 : opts.signal\n                    });\n                } catch (cause) {\n                    var _opts$onError, _procedure$_def$type;\n                    opts === null || opts === void 0 || (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n                        ctx,\n                        error: getTRPCErrorFromUnknown(cause),\n                        input: args[0],\n                        path: fullPath,\n                        type: (_procedure$_def$type = procedure === null || procedure === void 0 ? void 0 : procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n                    });\n                    throw cause;\n                }\n            });\n        };\n    };\n}\nfunction mergeRouters(...routerList) {\n    var _routerList$;\n    const record = (0,_utils_DdbbrDku_mjs__WEBPACK_IMPORTED_MODULE_1__.mergeWithoutOverrides)({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) throw new Error(\"You seem to have several error formatters\");\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) throw new Error(\"You seem to have several transformers\");\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.every((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.every((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.every((r)=>r._def._config.isServer),\n        $types: (_routerList$ = routerList[0]) === null || _routerList$ === void 0 ? void 0 : _routerList$._def._config.$types\n    })(record);\n    return router;\n}\n//#endregion\n//#region src/unstable-core-do-not-import/stream/tracked.ts\nconst trackedSymbol = Symbol();\n/**\n* Produce a typed server-sent event message\n* @deprecated use `tracked(id, data)` instead\n*/ function sse(event) {\n    return tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n    return Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n* Automatically track an event so that it can be resumed from a given id if the connection is lost\n*/ function tracked(id, data) {\n    if (id === \"\") throw new Error(\"`id` must not be an empty string as empty string is the same as not setting the id at all\");\n    return [\n        id,\n        data,\n        trackedSymbol\n    ];\n}\n//#endregion\n //# sourceMappingURL=tracked-gU3ttYjg.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvdHJhY2tlZC1nVTN0dFlqZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDQSxNQUFhQSxtQkFBNkMsQ0FBQyxFQUFFLE9BQU87SUFDbEUsT0FBTztBQUNSOzs7O0FDM0NELElBQU0sb0JBQU4sY0FBZ0MsTUFBTTtBQUVyQztBQUNELFNBQWdCLG9CQUFvQkMsS0FBQUEsRUFBbUM7SUFDckUsSUFBSSxpQkFBaUIsTUFDbkIsUUFBTztJQUdULE1BQU0sY0FBYztJQUNwQixJQUFJLFNBQVMsZUFBZSxTQUFTLGNBQWMsVUFBVSxLQUMzRDtJQUlGLElBQUksU0FBUyxTQUVYLFFBQU8sSUFBSSxNQUFNLE9BQU8sTUFBTTtJQUloQyxJQUFJLDZEQUFRLENBQUMsTUFBTSxDQUNqQixRQUFPLE9BQU8sT0FBTyxJQUFJLHFCQUFxQixNQUFNO0lBR3REO0FBQ0Q7QUFFRCxTQUFnQix3QkFBd0JBLEtBQUFBLEVBQTJCO0lBQ2pFLElBQUksaUJBQWlCLFVBQ25CLFFBQU87SUFFVCxJQUFJLGlCQUFpQixTQUFTLE1BQU0sU0FBUyxZQUUzQyxRQUFPO0lBR1QsTUFBTSxZQUFZLElBQUksVUFBVTtRQUM5QixNQUFNO1FBQ047SUFDRDtJQUdELElBQUksaUJBQWlCLFNBQVMsTUFBTSxNQUNsQyxXQUFVLFFBQVEsTUFBTTtJQUcxQixPQUFPO0FBQ1I7QUFFRCxJQUFhLFlBQWIsY0FBK0IsTUFBTTtJQU1uQyxZQUFZQyxJQUFBQSxDQUlUOztRQUNELE1BQU0sUUFBUSxvQkFBb0IsS0FBSyxNQUFNO1FBQzdDLE1BQU0sbUNBQVUsS0FBSyw4R0FBVyxNQUFPLDhDQUFXLEtBQUs7UUFJdkQsTUFBTSxTQUFTO1lBQUU7UUFBTyxFQUFDOzJDQU8zQixNQXBCeUI7MkNBb0J4QixNQW5C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SUFDakMsT0FBTyxNQUFNLFFBQVEsTUFBTSxJQUFJLE1BQU0sT0FBTztBQUM3Qzs7O0dBS0QsU0FBZ0IsUUFDZHFCLEVBQUFBLEVBQ0FDLElBQUFBLEVBQ3dCO0lBQ3hCLElBQUksT0FBTyxHQUVULE9BQU0sSUFBSSxNQUNSO0lBR0osT0FBTztRQUFDO1FBQWlCO1FBQU07S0FBYztBQUM5QyIsInNvdXJjZXMiOlsiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2Vycm9yL2Zvcm1hdHRlci50cyIsIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9lcnJvci9UUlBDRXJyb3IudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvdHJhbnNmb3JtZXIudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcm91dGVyLnRzIiwiL1VzZXJzL3BldGVyamFtZXNibGl6emFyZC9wcm9qZWN0cy9hcHBfY29kZXhjcm1hcHAvYXBwcy9zcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS90cmFja2VkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUHJvY2VkdXJlVHlwZSB9IGZyb20gJy4uL3Byb2NlZHVyZSc7XG5pbXBvcnQgdHlwZSB7XG4gIFRSUENfRVJST1JfQ09ERV9LRVksXG4gIFRSUENfRVJST1JfQ09ERV9OVU1CRVIsXG4gIFRSUENFcnJvclNoYXBlLFxufSBmcm9tICcuLi9ycGMnO1xuaW1wb3J0IHR5cGUgeyBUUlBDRXJyb3IgfSBmcm9tICcuL1RSUENFcnJvcic7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIEVycm9yRm9ybWF0dGVyPFRDb250ZXh0LCBUU2hhcGUgZXh0ZW5kcyBUUlBDRXJyb3JTaGFwZT4gPSAob3B0czoge1xuICBlcnJvcjogVFJQQ0Vycm9yO1xuICB0eXBlOiBQcm9jZWR1cmVUeXBlIHwgJ3Vua25vd24nO1xuICBwYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGlucHV0OiB1bmtub3duO1xuICBjdHg6IFRDb250ZXh0IHwgdW5kZWZpbmVkO1xuICBzaGFwZTogRGVmYXVsdEVycm9yU2hhcGU7XG59KSA9PiBUU2hhcGU7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCB0eXBlIERlZmF1bHRFcnJvckRhdGEgPSB7XG4gIGNvZGU6IFRSUENfRVJST1JfQ09ERV9LRVk7XG4gIGh0dHBTdGF0dXM6IG51bWJlcjtcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIHByb2NlZHVyZSB0aGF0IHRocmV3IHRoZSBlcnJvclxuICAgKi9cbiAgcGF0aD86IHN0cmluZztcbiAgLyoqXG4gICAqIFN0YWNrIHRyYWNlIG9mIHRoZSBlcnJvciAob25seSBpbiBkZXZlbG9wbWVudClcbiAgICovXG4gIHN0YWNrPzogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEZWZhdWx0RXJyb3JTaGFwZSBleHRlbmRzIFRSUENFcnJvclNoYXBlPERlZmF1bHRFcnJvckRhdGE+IHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBjb2RlOiBUUlBDX0VSUk9SX0NPREVfTlVNQkVSO1xufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdEZvcm1hdHRlcjogRXJyb3JGb3JtYXR0ZXI8YW55LCBhbnk+ID0gKHsgc2hhcGUgfSkgPT4ge1xuICByZXR1cm4gc2hhcGU7XG59O1xuIiwiaW1wb3J0IHR5cGUgeyBUUlBDX0VSUk9SX0NPREVfS0VZIH0gZnJvbSAnLi4vcnBjL2NvZGVzJztcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jbGFzcyBVbmtub3duQ2F1c2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgW2tleTogc3RyaW5nXTogdW5rbm93bjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXVzZUZyb21Vbmtub3duKGNhdXNlOiB1bmtub3duKTogRXJyb3IgfCB1bmRlZmluZWQge1xuICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBjYXVzZTtcbiAgfVxuXG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgY2F1c2U7XG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnZnVuY3Rpb24nIHx8IGNhdXNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBqdXN0IGdldCB3cmFwcGVkIGluIGFuIGVycm9yXG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYmFzZS10by1zdHJpbmdcbiAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhjYXVzZSkpO1xuICB9XG5cbiAgLy8gSWYgaXQncyBhbiBvYmplY3QsIHdlJ2xsIGNyZWF0ZSBhIHN5bnRoZXRpYyBlcnJvclxuICBpZiAoaXNPYmplY3QoY2F1c2UpKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVua25vd25DYXVzZUVycm9yKCksIGNhdXNlKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZTogdW5rbm93bik6IFRSUENFcnJvciB7XG4gIGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikge1xuICAgIHJldHVybiBjYXVzZTtcbiAgfVxuICBpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSAnVFJQQ0Vycm9yJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90cnBjL3RycGMvcHVsbC80ODQ4XG4gICAgcmV0dXJuIGNhdXNlIGFzIFRSUENFcnJvcjtcbiAgfVxuXG4gIGNvbnN0IHRycGNFcnJvciA9IG5ldyBUUlBDRXJyb3Ioe1xuICAgIGNvZGU6ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICAgIGNhdXNlLFxuICB9KTtcblxuICAvLyBJbmhlcml0IHN0YWNrIGZyb20gZXJyb3JcbiAgaWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgJiYgY2F1c2Uuc3RhY2spIHtcbiAgICB0cnBjRXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcbiAgfVxuXG4gIHJldHVybiB0cnBjRXJyb3I7XG59XG5cbmV4cG9ydCBjbGFzcyBUUlBDRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZSBvdmVycmlkZSBkb2Vzbid0IHdvcmsgaW4gYWxsIGVudmlyb25tZW50cyBkdWUgdG8gXCJUaGlzIG1lbWJlciBjYW5ub3QgaGF2ZSBhbiAnb3ZlcnJpZGUnIG1vZGlmaWVyIGJlY2F1c2UgaXQgaXMgbm90IGRlY2xhcmVkIGluIHRoZSBiYXNlIGNsYXNzICdFcnJvcidcIlxuICBwdWJsaWMgb3ZlcnJpZGUgcmVhZG9ubHkgY2F1c2U/OiBFcnJvcjtcbiAgcHVibGljIHJlYWRvbmx5IGNvZGU7XG5cbiAgY29uc3RydWN0b3Iob3B0czoge1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gICAgY29kZTogVFJQQ19FUlJPUl9DT0RFX0tFWTtcbiAgICBjYXVzZT86IHVua25vd247XG4gIH0pIHtcbiAgICBjb25zdCBjYXVzZSA9IGdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IG9wdHMubWVzc2FnZSA/PyBjYXVzZT8ubWVzc2FnZSA/PyBvcHRzLmNvZGU7XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZSBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1lcnJvci1jYXVzZVxuICAgIHN1cGVyKG1lc3NhZ2UsIHsgY2F1c2UgfSk7XG5cbiAgICB0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG4gICAgdGhpcy5uYW1lID0gJ1RSUENFcnJvcic7XG4gICAgdGhpcy5jYXVzZSA/Pz0gY2F1c2U7XG4gIH1cbn1cbiIsImltcG9ydCB0eXBlIHsgQW55Um9vdFR5cGVzLCBSb290Q29uZmlnIH0gZnJvbSAnLi9yb290Q29uZmlnJztcbmltcG9ydCB0eXBlIHsgQW55Um91dGVyLCBpbmZlclJvdXRlckVycm9yIH0gZnJvbSAnLi9yb3V0ZXInO1xuaW1wb3J0IHR5cGUge1xuICBUUlBDUmVzcG9uc2UsXG4gIFRSUENSZXNwb25zZU1lc3NhZ2UsXG4gIFRSUENSZXN1bHRNZXNzYWdlLFxufSBmcm9tICcuL3JwYyc7XG5pbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEYXRhVHJhbnNmb3JtZXIge1xuICBzZXJpYWxpemU6IChvYmplY3Q6IGFueSkgPT4gYW55O1xuICBkZXNlcmlhbGl6ZTogKG9iamVjdDogYW55KSA9PiBhbnk7XG59XG5cbmludGVyZmFjZSBJbnB1dERhdGFUcmFuc2Zvcm1lciBleHRlbmRzIERhdGFUcmFuc2Zvcm1lciB7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgKipvbiB0aGUgY2xpZW50KiogYmVmb3JlIHNlbmRpbmcgdGhlIGRhdGEgdG8gdGhlIHNlcnZlci5cbiAgICovXG4gIHNlcmlhbGl6ZTogKG9iamVjdDogYW55KSA9PiBhbnk7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJ1bnMgKipvbiB0aGUgc2VydmVyKiogdG8gdHJhbnNmb3JtIHRoZSBkYXRhIGJlZm9yZSBpdCBpcyBwYXNzZWQgdG8gdGhlIHJlc29sdmVyXG4gICAqL1xuICBkZXNlcmlhbGl6ZTogKG9iamVjdDogYW55KSA9PiBhbnk7XG59XG5cbmludGVyZmFjZSBPdXRwdXREYXRhVHJhbnNmb3JtZXIgZXh0ZW5kcyBEYXRhVHJhbnNmb3JtZXIge1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBydW5zICoqb24gdGhlIHNlcnZlcioqIGJlZm9yZSBzZW5kaW5nIHRoZSBkYXRhIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICBzZXJpYWxpemU6IChvYmplY3Q6IGFueSkgPT4gYW55O1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBydW5zICoqb25seSBvbiB0aGUgY2xpZW50KiogdG8gdHJhbnNmb3JtIHRoZSBkYXRhIHNlbnQgZnJvbSB0aGUgc2VydmVyLlxuICAgKi9cbiAgZGVzZXJpYWxpemU6IChvYmplY3Q6IGFueSkgPT4gYW55O1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb21iaW5lZERhdGFUcmFuc2Zvcm1lciB7XG4gIC8qKlxuICAgKiBTcGVjaWZ5IGhvdyB0aGUgZGF0YSBzZW50IGZyb20gdGhlIGNsaWVudCB0byB0aGUgc2VydmVyIHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAgICovXG4gIGlucHV0OiBJbnB1dERhdGFUcmFuc2Zvcm1lcjtcbiAgLyoqXG4gICAqIFNwZWNpZnkgaG93IHRoZSBkYXRhIHNlbnQgZnJvbSB0aGUgc2VydmVyIHRvIHRoZSBjbGllbnQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICAgKi9cbiAgb3V0cHV0OiBPdXRwdXREYXRhVHJhbnNmb3JtZXI7XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgdHlwZSBDb21iaW5lZERhdGFUcmFuc2Zvcm1lckNsaWVudCA9IHtcbiAgaW5wdXQ6IFBpY2s8Q29tYmluZWREYXRhVHJhbnNmb3JtZXJbJ2lucHV0J10sICdzZXJpYWxpemUnPjtcbiAgb3V0cHV0OiBQaWNrPENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyWydvdXRwdXQnXSwgJ2Rlc2VyaWFsaXplJz47XG59O1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IHR5cGUgRGF0YVRyYW5zZm9ybWVyT3B0aW9ucyA9IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyIHwgRGF0YVRyYW5zZm9ybWVyO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YVRyYW5zZm9ybWVyKFxuICB0cmFuc2Zvcm1lcjogRGF0YVRyYW5zZm9ybWVyT3B0aW9ucyxcbik6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyIHtcbiAgaWYgKCdpbnB1dCcgaW4gdHJhbnNmb3JtZXIpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gIH1cbiAgcmV0dXJuIHsgaW5wdXQ6IHRyYW5zZm9ybWVyLCBvdXRwdXQ6IHRyYW5zZm9ybWVyIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0VHJhbnNmb3JtZXI6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyID0ge1xuICBpbnB1dDogeyBzZXJpYWxpemU6IChvYmopID0+IG9iaiwgZGVzZXJpYWxpemU6IChvYmopID0+IG9iaiB9LFxuICBvdXRwdXQ6IHsgc2VyaWFsaXplOiAob2JqKSA9PiBvYmosIGRlc2VyaWFsaXplOiAob2JqKSA9PiBvYmogfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVRSUENSZXNwb25zZUl0ZW08XG4gIFRSZXNwb25zZUl0ZW0gZXh0ZW5kcyBUUlBDUmVzcG9uc2UgfCBUUlBDUmVzcG9uc2VNZXNzYWdlLFxuPihjb25maWc6IFJvb3RDb25maWc8QW55Um9vdFR5cGVzPiwgaXRlbTogVFJlc3BvbnNlSXRlbSk6IFRSZXNwb25zZUl0ZW0ge1xuICBpZiAoJ2Vycm9yJyBpbiBpdGVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLml0ZW0sXG4gICAgICBlcnJvcjogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5lcnJvciksXG4gICAgfTtcbiAgfVxuXG4gIGlmICgnZGF0YScgaW4gaXRlbS5yZXN1bHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaXRlbSxcbiAgICAgIHJlc3VsdDoge1xuICAgICAgICAuLi5pdGVtLnJlc3VsdCxcbiAgICAgICAgZGF0YTogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5yZXN1bHQuZGF0YSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHVuc2VyaWFsaXplZCBgVFJQQ1Jlc3BvbnNlYCBhbmQgc2VyaWFsaXplcyBpdCB3aXRoIHRoZSByb3V0ZXIncyB0cmFuc2Zvcm1lcnNcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2U8XG4gIFRSZXNwb25zZSBleHRlbmRzXG4gICAgfCBUUlBDUmVzcG9uc2VcbiAgICB8IFRSUENSZXNwb25zZVtdXG4gICAgfCBUUlBDUmVzcG9uc2VNZXNzYWdlXG4gICAgfCBUUlBDUmVzcG9uc2VNZXNzYWdlW10sXG4+KGNvbmZpZzogUm9vdENvbmZpZzxBbnlSb290VHlwZXM+LCBpdGVtT3JJdGVtczogVFJlc3BvbnNlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW1Pckl0ZW1zKVxuICAgID8gaXRlbU9ySXRlbXMubWFwKChpdGVtKSA9PiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbSkpXG4gICAgOiB0cmFuc2Zvcm1UUlBDUmVzcG9uc2VJdGVtKGNvbmZpZywgaXRlbU9ySXRlbXMpO1xufVxuXG4vLyBGSVhNRTpcbi8vIC0gdGhlIGdlbmVyaWNzIGhlcmUgYXJlIHByb2JhYmx5IHVubmVjZXNzYXJ5XG4vLyAtIHRoZSBSUEMtc3BlYyBjb3VsZCBwcm9iYWJseSBiZSBzaW1wbGlmaWVkIHRvIGNvbWJpbmUgSFRUUCArIFdTXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHRJbm5lcjxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyLCBUT3V0cHV0PihcbiAgcmVzcG9uc2U6XG4gICAgfCBUUlBDUmVzcG9uc2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj5cbiAgICB8IFRSUENSZXNwb25zZU1lc3NhZ2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4sXG4gIHRyYW5zZm9ybWVyOiBEYXRhVHJhbnNmb3JtZXIsXG4pIHtcbiAgaWYgKCdlcnJvcicgaW4gcmVzcG9uc2UpIHtcbiAgICBjb25zdCBlcnJvciA9IHRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKFxuICAgICAgcmVzcG9uc2UuZXJyb3IsXG4gICAgKSBhcyBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXI+O1xuICAgIHJldHVybiB7XG4gICAgICBvazogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICB9LFxuICAgIH0gYXMgY29uc3Q7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4ucmVzcG9uc2UucmVzdWx0LFxuICAgIC4uLigoIXJlc3BvbnNlLnJlc3VsdC50eXBlIHx8IHJlc3BvbnNlLnJlc3VsdC50eXBlID09PSAnZGF0YScpICYmIHtcbiAgICAgIHR5cGU6ICdkYXRhJyxcbiAgICAgIGRhdGE6IHRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHJlc3BvbnNlLnJlc3VsdC5kYXRhKSxcbiAgICB9KSxcbiAgfSBhcyBUUlBDUmVzdWx0TWVzc2FnZTxUT3V0cHV0PlsncmVzdWx0J107XG4gIHJldHVybiB7IG9rOiB0cnVlLCByZXN1bHQgfSBhcyBjb25zdDtcbn1cblxuY2xhc3MgVHJhbnNmb3JtUmVzdWx0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCdVbmFibGUgdG8gdHJhbnNmb3JtIHJlc3BvbnNlIGZyb20gc2VydmVyJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuZCB2YWxpZGF0ZXMgdGhhdCB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgVFJQQ1Jlc3BvbnNlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJlc3VsdDxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyLCBUT3V0cHV0PihcbiAgcmVzcG9uc2U6XG4gICAgfCBUUlBDUmVzcG9uc2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj5cbiAgICB8IFRSUENSZXNwb25zZU1lc3NhZ2U8VE91dHB1dCwgaW5mZXJSb3V0ZXJFcnJvcjxUUm91dGVyPj4sXG4gIHRyYW5zZm9ybWVyOiBEYXRhVHJhbnNmb3JtZXIsXG4pOiBSZXR1cm5UeXBlPHR5cGVvZiB0cmFuc2Zvcm1SZXN1bHRJbm5lcj4ge1xuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPHR5cGVvZiB0cmFuc2Zvcm1SZXN1bHRJbm5lcj47XG4gIHRyeSB7XG4gICAgLy8gVXNlIHRoZSBkYXRhIHRyYW5zZm9ybWVycyBvbiB0aGUgSlNPTi1yZXNwb25zZVxuICAgIHJlc3VsdCA9IHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcik7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuICB9XG5cbiAgLy8gY2hlY2sgdGhhdCBvdXRwdXQgb2YgdGhlIHRyYW5zZm9ybWVycyBpcyBhIHZhbGlkIFRSUENSZXNwb25zZVxuICBpZiAoXG4gICAgIXJlc3VsdC5vayAmJlxuICAgICghaXNPYmplY3QocmVzdWx0LmVycm9yLmVycm9yKSB8fFxuICAgICAgdHlwZW9mIHJlc3VsdC5lcnJvci5lcnJvclsnY29kZSddICE9PSAnbnVtYmVyJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG4gIH1cbiAgaWYgKHJlc3VsdC5vayAmJiAhaXNPYmplY3QocmVzdWx0LnJlc3VsdCkpIHtcbiAgICB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0IHR5cGUgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjcmVhdGVSZWN1cnNpdmVQcm94eSB9IGZyb20gJy4vY3JlYXRlUHJveHknO1xuaW1wb3J0IHsgZGVmYXVsdEZvcm1hdHRlciB9IGZyb20gJy4vZXJyb3IvZm9ybWF0dGVyJztcbmltcG9ydCB7IGdldFRSUENFcnJvckZyb21Vbmtub3duLCBUUlBDRXJyb3IgfSBmcm9tICcuL2Vycm9yL1RSUENFcnJvcic7XG5pbXBvcnQgdHlwZSB7XG4gIEFueVByb2NlZHVyZSxcbiAgRXJyb3JIYW5kbGVyT3B0aW9ucyxcbiAgaW5mZXJQcm9jZWR1cmVJbnB1dCxcbiAgaW5mZXJQcm9jZWR1cmVPdXRwdXQsXG4gIExlZ2FjeU9ic2VydmFibGVTdWJzY3JpcHRpb25Qcm9jZWR1cmUsXG59IGZyb20gJy4vcHJvY2VkdXJlJztcbmltcG9ydCB0eXBlIHsgUHJvY2VkdXJlQ2FsbE9wdGlvbnMgfSBmcm9tICcuL3Byb2NlZHVyZUJ1aWxkZXInO1xuaW1wb3J0IHR5cGUgeyBBbnlSb290VHlwZXMsIFJvb3RDb25maWcgfSBmcm9tICcuL3Jvb3RDb25maWcnO1xuaW1wb3J0IHsgZGVmYXVsdFRyYW5zZm9ybWVyIH0gZnJvbSAnLi90cmFuc2Zvcm1lcic7XG5pbXBvcnQgdHlwZSB7IE1heWJlUHJvbWlzZSwgVmFsdWVPZiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtcbiAgaXNGdW5jdGlvbixcbiAgaXNPYmplY3QsXG4gIG1lcmdlV2l0aG91dE92ZXJyaWRlcyxcbiAgb21pdFByb3RvdHlwZSxcbn0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyUmVjb3JkIHtcbiAgW2tleTogc3RyaW5nXTogQW55UHJvY2VkdXJlIHwgUm91dGVyUmVjb3JkO1xufVxuXG50eXBlIERlY29yYXRlUHJvY2VkdXJlPFRQcm9jZWR1cmUgZXh0ZW5kcyBBbnlQcm9jZWR1cmU+ID0gKFxuICBpbnB1dDogaW5mZXJQcm9jZWR1cmVJbnB1dDxUUHJvY2VkdXJlPixcbikgPT4gUHJvbWlzZTxcbiAgVFByb2NlZHVyZVsnX2RlZiddWyd0eXBlJ10gZXh0ZW5kcyAnc3Vic2NyaXB0aW9uJ1xuICAgID8gVFByb2NlZHVyZSBleHRlbmRzIExlZ2FjeU9ic2VydmFibGVTdWJzY3JpcHRpb25Qcm9jZWR1cmU8YW55PlxuICAgICAgPyBPYnNlcnZhYmxlPGluZmVyUHJvY2VkdXJlT3V0cHV0PFRQcm9jZWR1cmU+LCBUUlBDRXJyb3I+XG4gICAgICA6IGluZmVyUHJvY2VkdXJlT3V0cHV0PFRQcm9jZWR1cmU+XG4gICAgOiBpbmZlclByb2NlZHVyZU91dHB1dDxUUHJvY2VkdXJlPlxuPjtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgRGVjb3JhdGVSb3V0ZXJSZWNvcmQ8VFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZD4gPSB7XG4gIFtUS2V5IGluIGtleW9mIFRSZWNvcmRdOiBUUmVjb3JkW1RLZXldIGV4dGVuZHMgaW5mZXIgJFZhbHVlXG4gICAgPyAkVmFsdWUgZXh0ZW5kcyBBbnlQcm9jZWR1cmVcbiAgICAgID8gRGVjb3JhdGVQcm9jZWR1cmU8JFZhbHVlPlxuICAgICAgOiAkVmFsdWUgZXh0ZW5kcyBSb3V0ZXJSZWNvcmRcbiAgICAgICAgPyBEZWNvcmF0ZVJvdXRlclJlY29yZDwkVmFsdWU+XG4gICAgICAgIDogbmV2ZXJcbiAgICA6IG5ldmVyO1xufTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5leHBvcnQgdHlwZSBSb3V0ZXJDYWxsZXJFcnJvckhhbmRsZXI8VENvbnRleHQ+ID0gKFxuICBvcHRzOiBFcnJvckhhbmRsZXJPcHRpb25zPFRDb250ZXh0PixcbikgPT4gdm9pZDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHR5cGUgUm91dGVyQ2FsbGVyPFxuICBUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcyxcbiAgVFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZCxcbj4gPSAoXG4gIC8qKlxuICAgKiBAbm90ZVxuICAgKiBJZiBwYXNzaW5nIGEgZnVuY3Rpb24sIHdlIHJlY29tbWVuZCBpdCdzIGEgY2FjaGVkIGZ1bmN0aW9uXG4gICAqIGUuZy4gd3JhcHBlZCBpbiBgUmVhY3QuY2FjaGVgIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uc1xuICAgKi9cbiAgY3R4OiBUUm9vdFsnY3R4J10gfCAoKCkgPT4gTWF5YmVQcm9taXNlPFRSb290WydjdHgnXT4pLFxuICBvcHRpb25zPzoge1xuICAgIG9uRXJyb3I/OiBSb3V0ZXJDYWxsZXJFcnJvckhhbmRsZXI8VFJvb3RbJ2N0eCddPjtcbiAgICBzaWduYWw/OiBBYm9ydFNpZ25hbDtcbiAgfSxcbikgPT4gRGVjb3JhdGVSb3V0ZXJSZWNvcmQ8VFJlY29yZD47XG5cbmNvbnN0IGxhenlTeW1ib2wgPSBTeW1ib2woJ2xhenknKTtcbmV4cG9ydCB0eXBlIExhenk8VEFueT4gPSAoKCkgPT4gUHJvbWlzZTxUQW55PikgJiB7IFtsYXp5U3ltYm9sXTogdHJ1ZSB9O1xuXG50eXBlIExhenlMb2FkZXI8VEFueT4gPSB7XG4gIGxvYWQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJlZjogTGF6eTxUQW55Pjtcbn07XG5cbmZ1bmN0aW9uIG9uY2U8VD4oZm46ICgpID0+IFQpOiAoKSA9PiBUIHtcbiAgY29uc3QgdW5jYWxsZWQgPSBTeW1ib2woKTtcbiAgbGV0IHJlc3VsdDogVCB8IHR5cGVvZiB1bmNhbGxlZCA9IHVuY2FsbGVkO1xuICByZXR1cm4gKCk6IFQgPT4ge1xuICAgIGlmIChyZXN1bHQgPT09IHVuY2FsbGVkKSB7XG4gICAgICByZXN1bHQgPSBmbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIExhenkgbG9hZCBhIHJvdXRlclxuICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy9zZXJ2ZXIvbWVyZ2luZy1yb3V0ZXJzI2xhenktbG9hZFxuICovXG5leHBvcnQgZnVuY3Rpb24gbGF6eTxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPihcbiAgaW1wb3J0Um91dGVyOiAoKSA9PiBQcm9taXNlPFxuICAgIHwgVFJvdXRlclxuICAgIHwge1xuICAgICAgICBba2V5OiBzdHJpbmddOiBUUm91dGVyO1xuICAgICAgfVxuICA+LFxuKTogTGF6eTxOb0luZmVyPFRSb3V0ZXI+PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmUoKTogUHJvbWlzZTxUUm91dGVyPiB7XG4gICAgY29uc3QgbW9kID0gYXdhaXQgaW1wb3J0Um91dGVyKCk7XG5cbiAgICAvLyBpZiB0aGUgbW9kdWxlIGlzIGEgcm91dGVyLCByZXR1cm4gaXRcbiAgICBpZiAoaXNSb3V0ZXIobW9kKSkge1xuICAgICAgcmV0dXJuIG1vZDtcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZXJzID0gT2JqZWN0LnZhbHVlcyhtb2QpO1xuXG4gICAgaWYgKHJvdXRlcnMubGVuZ3RoICE9PSAxIHx8ICFpc1JvdXRlcihyb3V0ZXJzWzBdKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkludmFsaWQgcm91dGVyIG1vZHVsZSAtIGVpdGhlciBkZWZpbmUgZXhhY3RseSAxIGV4cG9ydCBvciByZXR1cm4gdGhlIHJvdXRlciBkaXJlY3RseS5cXG5FeGFtcGxlOiBgbGF6eSgoKSA9PiBpbXBvcnQoJy4vc2xvdy5qcycpLnRoZW4oKG0pID0+IG0uc2xvd1JvdXRlcikpYFwiLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm91dGVyc1swXTtcbiAgfVxuICByZXNvbHZlW2xhenlTeW1ib2xdID0gdHJ1ZSBhcyBjb25zdDtcblxuICByZXR1cm4gcmVzb2x2ZTtcbn1cblxuZnVuY3Rpb24gaXNMYXp5PFRBbnk+KGlucHV0OiB1bmtub3duKTogaW5wdXQgaXMgTGF6eTxUQW55PiB7XG4gIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicgJiYgbGF6eVN5bWJvbCBpbiBpbnB1dDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJEZWY8XG4gIFRSb290IGV4dGVuZHMgQW55Um9vdFR5cGVzLFxuICBUUmVjb3JkIGV4dGVuZHMgUm91dGVyUmVjb3JkLFxuPiB7XG4gIF9jb25maWc6IFJvb3RDb25maWc8VFJvb3Q+O1xuICByb3V0ZXI6IHRydWU7XG4gIHByb2NlZHVyZT86IG5ldmVyO1xuICBwcm9jZWR1cmVzOiBUUmVjb3JkO1xuICByZWNvcmQ6IFRSZWNvcmQ7XG4gIGxhenk6IFJlY29yZDxzdHJpbmcsIExhenlMb2FkZXI8QW55Um91dGVyPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVyPFxuICBUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcyxcbiAgVFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZCxcbj4ge1xuICBfZGVmOiBSb3V0ZXJEZWY8VFJvb3QsIFRSZWNvcmQ+O1xuICAvKipcbiAgICogQHNlZSBodHRwczovL3RycGMuaW8vZG9jcy92MTEvc2VydmVyL3NlcnZlci1zaWRlLWNhbGxzXG4gICAqL1xuICBjcmVhdGVDYWxsZXI6IFJvdXRlckNhbGxlcjxUUm9vdCwgVFJlY29yZD47XG59XG5cbmV4cG9ydCB0eXBlIEJ1aWx0Um91dGVyPFxuICBUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcyxcbiAgVFJlY29yZCBleHRlbmRzIFJvdXRlclJlY29yZCxcbj4gPSBSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+ICYgVFJlY29yZDtcblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZXJCdWlsZGVyPFRSb290IGV4dGVuZHMgQW55Um9vdFR5cGVzPiB7XG4gIDxUSW4gZXh0ZW5kcyBDcmVhdGVSb3V0ZXJPcHRpb25zPihcbiAgICBfOiBUSW4sXG4gICk6IEJ1aWx0Um91dGVyPFRSb290LCBEZWNvcmF0ZUNyZWF0ZVJvdXRlck9wdGlvbnM8VEluPj47XG59XG5cbmV4cG9ydCB0eXBlIEFueVJvdXRlciA9IFJvdXRlcjxhbnksIGFueT47XG5cbmV4cG9ydCB0eXBlIGluZmVyUm91dGVyUm9vdFR5cGVzPFRSb3V0ZXIgZXh0ZW5kcyBBbnlSb3V0ZXI+ID1cbiAgVFJvdXRlclsnX2RlZiddWydfY29uZmlnJ11bJyR0eXBlcyddO1xuXG5leHBvcnQgdHlwZSBpbmZlclJvdXRlckNvbnRleHQ8VFJvdXRlciBleHRlbmRzIEFueVJvdXRlcj4gPVxuICBpbmZlclJvdXRlclJvb3RUeXBlczxUUm91dGVyPlsnY3R4J107XG5leHBvcnQgdHlwZSBpbmZlclJvdXRlckVycm9yPFRSb3V0ZXIgZXh0ZW5kcyBBbnlSb3V0ZXI+ID1cbiAgaW5mZXJSb3V0ZXJSb290VHlwZXM8VFJvdXRlcj5bJ2Vycm9yU2hhcGUnXTtcbmV4cG9ydCB0eXBlIGluZmVyUm91dGVyTWV0YTxUUm91dGVyIGV4dGVuZHMgQW55Um91dGVyPiA9XG4gIGluZmVyUm91dGVyUm9vdFR5cGVzPFRSb3V0ZXI+WydtZXRhJ107XG5cbmZ1bmN0aW9uIGlzUm91dGVyKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQW55Um91dGVyIHtcbiAgcmV0dXJuIChcbiAgICBpc09iamVjdCh2YWx1ZSkgJiYgaXNPYmplY3QodmFsdWVbJ19kZWYnXSkgJiYgJ3JvdXRlcicgaW4gdmFsdWVbJ19kZWYnXVxuICApO1xufVxuXG5jb25zdCBlbXB0eVJvdXRlciA9IHtcbiAgX2N0eDogbnVsbCBhcyBhbnksXG4gIF9lcnJvclNoYXBlOiBudWxsIGFzIGFueSxcbiAgX21ldGE6IG51bGwgYXMgYW55LFxuICBxdWVyaWVzOiB7fSxcbiAgbXV0YXRpb25zOiB7fSxcbiAgc3Vic2NyaXB0aW9uczoge30sXG4gIGVycm9yRm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuICB0cmFuc2Zvcm1lcjogZGVmYXVsdFRyYW5zZm9ybWVyLFxufTtcblxuLyoqXG4gKiBSZXNlcnZlZCB3b3JkcyB0aGF0IGNhbid0IGJlIHVzZWQgYXMgcm91dGVyIG9yIHByb2NlZHVyZSBuYW1lc1xuICovXG5jb25zdCByZXNlcnZlZFdvcmRzID0gW1xuICAvKipcbiAgICogVGhlbiBpcyBhIHJlc2VydmVkIHdvcmQgYmVjYXVzZSBvdGhlcndpc2Ugd2UgY2FuJ3QgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHJldHVybnMgYSBQcm94eVxuICAgKiBzaW5jZSBKUyB3aWxsIHRoaW5rIHRoYXQgYC50aGVuYCBpcyBzb21ldGhpbmcgdGhhdCBleGlzdHNcbiAgICovXG4gICd0aGVuJyxcbiAgLyoqXG4gICAqIGBmbi5jYWxsKClgIGFuZCBgZm4uYXBwbHkoKWAgYXJlIHJlc2VydmVkIHdvcmRzIGJlY2F1c2Ugb3RoZXJ3aXNlIHdlIGNhbid0IGNhbGwgYSBmdW5jdGlvbiB1c2luZyBgLmNhbGxgIG9yIGAuYXBwbHlgXG4gICAqL1xuICAnY2FsbCcsXG4gICdhcHBseScsXG5dO1xuXG4vKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSBDcmVhdGVSb3V0ZXJPcHRpb25zID0ge1xuICBba2V5OiBzdHJpbmddOlxuICAgIHwgQW55UHJvY2VkdXJlXG4gICAgfCBBbnlSb3V0ZXJcbiAgICB8IENyZWF0ZVJvdXRlck9wdGlvbnNcbiAgICB8IExhenk8QW55Um91dGVyPjtcbn07XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB0eXBlIERlY29yYXRlQ3JlYXRlUm91dGVyT3B0aW9uczxcbiAgVFJvdXRlck9wdGlvbnMgZXh0ZW5kcyBDcmVhdGVSb3V0ZXJPcHRpb25zLFxuPiA9IHtcbiAgW0sgaW4ga2V5b2YgVFJvdXRlck9wdGlvbnNdOiBUUm91dGVyT3B0aW9uc1tLXSBleHRlbmRzIGluZmVyICRWYWx1ZVxuICAgID8gJFZhbHVlIGV4dGVuZHMgQW55UHJvY2VkdXJlXG4gICAgICA/ICRWYWx1ZVxuICAgICAgOiAkVmFsdWUgZXh0ZW5kcyBSb3V0ZXI8YW55LCBpbmZlciBUUmVjb3JkPlxuICAgICAgICA/IFRSZWNvcmRcbiAgICAgICAgOiAkVmFsdWUgZXh0ZW5kcyBMYXp5PFJvdXRlcjxhbnksIGluZmVyIFRSZWNvcmQ+PlxuICAgICAgICAgID8gVFJlY29yZFxuICAgICAgICAgIDogJFZhbHVlIGV4dGVuZHMgQ3JlYXRlUm91dGVyT3B0aW9uc1xuICAgICAgICAgICAgPyBEZWNvcmF0ZUNyZWF0ZVJvdXRlck9wdGlvbnM8JFZhbHVlPlxuICAgICAgICAgICAgOiBuZXZlclxuICAgIDogbmV2ZXI7XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVyRmFjdG9yeTxUUm9vdCBleHRlbmRzIEFueVJvb3RUeXBlcz4oXG4gIGNvbmZpZzogUm9vdENvbmZpZzxUUm9vdD4sXG4pIHtcbiAgZnVuY3Rpb24gY3JlYXRlUm91dGVySW5uZXI8VElucHV0IGV4dGVuZHMgQ3JlYXRlUm91dGVyT3B0aW9ucz4oXG4gICAgaW5wdXQ6IFRJbnB1dCxcbiAgKTogQnVpbHRSb3V0ZXI8VFJvb3QsIERlY29yYXRlQ3JlYXRlUm91dGVyT3B0aW9uczxUSW5wdXQ+PiB7XG4gICAgY29uc3QgcmVzZXJ2ZWRXb3Jkc1VzZWQgPSBuZXcgU2V0KFxuICAgICAgT2JqZWN0LmtleXMoaW5wdXQpLmZpbHRlcigodikgPT4gcmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyh2KSksXG4gICAgKTtcbiAgICBpZiAocmVzZXJ2ZWRXb3Jkc1VzZWQuc2l6ZSA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1Jlc2VydmVkIHdvcmRzIHVzZWQgaW4gYHJvdXRlcih7fSlgIGNhbGw6ICcgK1xuICAgICAgICAgIEFycmF5LmZyb20ocmVzZXJ2ZWRXb3Jkc1VzZWQpLmpvaW4oJywgJyksXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2NlZHVyZXM6IFJlY29yZDxzdHJpbmcsIEFueVByb2NlZHVyZT4gPSBvbWl0UHJvdG90eXBlKHt9KTtcbiAgICBjb25zdCBsYXp5OiBSZWNvcmQ8c3RyaW5nLCBMYXp5TG9hZGVyPEFueVJvdXRlcj4+ID0gb21pdFByb3RvdHlwZSh7fSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMYXp5TG9hZGVyKG9wdHM6IHtcbiAgICAgIHJlZjogTGF6eTxBbnlSb3V0ZXI+O1xuICAgICAgcGF0aDogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgICBrZXk6IHN0cmluZztcbiAgICAgIGFnZ3JlZ2F0ZTogUm91dGVyUmVjb3JkO1xuICAgIH0pOiBMYXp5TG9hZGVyPEFueVJvdXRlcj4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmOiBvcHRzLnJlZixcbiAgICAgICAgbG9hZDogb25jZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm91dGVyID0gYXdhaXQgb3B0cy5yZWYoKTtcbiAgICAgICAgICBjb25zdCBsYXp5UGF0aCA9IFsuLi5vcHRzLnBhdGgsIG9wdHMua2V5XTtcbiAgICAgICAgICBjb25zdCBsYXp5S2V5ID0gbGF6eVBhdGguam9pbignLicpO1xuXG4gICAgICAgICAgb3B0cy5hZ2dyZWdhdGVbb3B0cy5rZXldID0gc3RlcChyb3V0ZXIuX2RlZi5yZWNvcmQsIGxhenlQYXRoKTtcblxuICAgICAgICAgIGRlbGV0ZSBsYXp5W2xhenlLZXldO1xuXG4gICAgICAgICAgLy8gYWRkIGxhenkgbG9hZGVycyBmb3IgbmVzdGVkIHJvdXRlcnNcbiAgICAgICAgICBmb3IgKGNvbnN0IFtuZXN0ZWRLZXksIG5lc3RlZEl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKFxuICAgICAgICAgICAgcm91dGVyLl9kZWYubGF6eSxcbiAgICAgICAgICApKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWRSb3V0ZXJLZXkgPSBbLi4ubGF6eVBhdGgsIG5lc3RlZEtleV0uam9pbignLicpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWRkaW5nIGxhenknLCBuZXN0ZWRSb3V0ZXJLZXkpO1xuICAgICAgICAgICAgbGF6eVtuZXN0ZWRSb3V0ZXJLZXldID0gY3JlYXRlTGF6eUxvYWRlcih7XG4gICAgICAgICAgICAgIHJlZjogbmVzdGVkSXRlbS5yZWYsXG4gICAgICAgICAgICAgIHBhdGg6IGxhenlQYXRoLFxuICAgICAgICAgICAgICBrZXk6IG5lc3RlZEtleSxcbiAgICAgICAgICAgICAgYWdncmVnYXRlOiBvcHRzLmFnZ3JlZ2F0ZVtvcHRzLmtleV0gYXMgUm91dGVyUmVjb3JkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RlcChmcm9tOiBDcmVhdGVSb3V0ZXJPcHRpb25zLCBwYXRoOiByZWFkb25seSBzdHJpbmdbXSA9IFtdKSB7XG4gICAgICBjb25zdCBhZ2dyZWdhdGU6IFJvdXRlclJlY29yZCA9IG9taXRQcm90b3R5cGUoe30pO1xuICAgICAgZm9yIChjb25zdCBba2V5LCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhmcm9tID8/IHt9KSkge1xuICAgICAgICBpZiAoaXNMYXp5KGl0ZW0pKSB7XG4gICAgICAgICAgbGF6eVtbLi4ucGF0aCwga2V5XS5qb2luKCcuJyldID0gY3JlYXRlTGF6eUxvYWRlcih7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcmVmOiBpdGVtLFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgYWdncmVnYXRlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JvdXRlcihpdGVtKSkge1xuICAgICAgICAgIGFnZ3JlZ2F0ZVtrZXldID0gc3RlcChpdGVtLl9kZWYucmVjb3JkLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1Byb2NlZHVyZShpdGVtKSkge1xuICAgICAgICAgIC8vIFJvdXRlclJlY29yZFxuICAgICAgICAgIGFnZ3JlZ2F0ZVtrZXldID0gc3RlcChpdGVtLCBbLi4ucGF0aCwga2V5XSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBuZXdQYXRoID0gWy4uLnBhdGgsIGtleV0uam9pbignLicpO1xuXG4gICAgICAgIGlmIChwcm9jZWR1cmVzW25ld1BhdGhdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUga2V5OiAke25ld1BhdGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZWR1cmVzW25ld1BhdGhdID0gaXRlbTtcbiAgICAgICAgYWdncmVnYXRlW2tleV0gPSBpdGVtO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWdncmVnYXRlO1xuICAgIH1cbiAgICBjb25zdCByZWNvcmQgPSBzdGVwKGlucHV0KTtcblxuICAgIGNvbnN0IF9kZWY6IEFueVJvdXRlclsnX2RlZiddID0ge1xuICAgICAgX2NvbmZpZzogY29uZmlnLFxuICAgICAgcm91dGVyOiB0cnVlLFxuICAgICAgcHJvY2VkdXJlcyxcbiAgICAgIGxhenksXG4gICAgICAuLi5lbXB0eVJvdXRlcixcbiAgICAgIHJlY29yZCxcbiAgICB9O1xuXG4gICAgY29uc3Qgcm91dGVyOiBCdWlsdFJvdXRlcjxUUm9vdCwge30+ID0ge1xuICAgICAgLi4uKHJlY29yZCBhcyB7fSksXG4gICAgICBfZGVmLFxuICAgICAgY3JlYXRlQ2FsbGVyOiBjcmVhdGVDYWxsZXJGYWN0b3J5PFRSb290PigpKHtcbiAgICAgICAgX2RlZixcbiAgICAgIH0pLFxuICAgIH07XG4gICAgcmV0dXJuIHJvdXRlciBhcyBCdWlsdFJvdXRlcjxUUm9vdCwgRGVjb3JhdGVDcmVhdGVSb3V0ZXJPcHRpb25zPFRJbnB1dD4+O1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVJvdXRlcklubmVyO1xufVxuXG5mdW5jdGlvbiBpc1Byb2NlZHVyZShcbiAgcHJvY2VkdXJlT3JSb3V0ZXI6IFZhbHVlT2Y8Q3JlYXRlUm91dGVyT3B0aW9ucz4sXG4pOiBwcm9jZWR1cmVPclJvdXRlciBpcyBBbnlQcm9jZWR1cmUge1xuICByZXR1cm4gdHlwZW9mIHByb2NlZHVyZU9yUm91dGVyID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvY2VkdXJlQXRQYXRoKFxuICByb3V0ZXI6IFBpY2s8Um91dGVyPGFueSwgYW55PiwgJ19kZWYnPixcbiAgcGF0aDogc3RyaW5nLFxuKTogUHJvbWlzZTxBbnlQcm9jZWR1cmUgfCBudWxsPiB7XG4gIGNvbnN0IHsgX2RlZiB9ID0gcm91dGVyO1xuICBsZXQgcHJvY2VkdXJlID0gX2RlZi5wcm9jZWR1cmVzW3BhdGhdO1xuXG4gIHdoaWxlICghcHJvY2VkdXJlKSB7XG4gICAgY29uc3Qga2V5ID0gT2JqZWN0LmtleXMoX2RlZi5sYXp5KS5maW5kKChrZXkpID0+IHBhdGguc3RhcnRzV2l0aChrZXkpKTtcbiAgICAvLyBjb25zb2xlLmxvZyhgZm91bmQgbGF6eTogJHtrZXkgPz8gJ05PUEUnfSAoZnVsbFBhdGg6ICR7ZnVsbFBhdGh9KWApO1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnbG9hZGluZycsIGtleSwgJy4uLi4uLi4nKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IGxhenlSb3V0ZXIgPSBfZGVmLmxhenlba2V5XSE7XG4gICAgYXdhaXQgbGF6eVJvdXRlci5sb2FkKCk7XG5cbiAgICBwcm9jZWR1cmUgPSBfZGVmLnByb2NlZHVyZXNbcGF0aF07XG4gIH1cblxuICByZXR1cm4gcHJvY2VkdXJlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbFByb2NlZHVyZShcbiAgb3B0czogUHJvY2VkdXJlQ2FsbE9wdGlvbnM8dW5rbm93bj4gJiB7XG4gICAgcm91dGVyOiBBbnlSb3V0ZXI7XG4gICAgYWxsb3dNZXRob2RPdmVycmlkZT86IGJvb2xlYW47XG4gIH0sXG4pIHtcbiAgY29uc3QgeyB0eXBlLCBwYXRoIH0gPSBvcHRzO1xuICBjb25zdCBwcm9jID0gYXdhaXQgZ2V0UHJvY2VkdXJlQXRQYXRoKG9wdHMucm91dGVyLCBwYXRoKTtcbiAgaWYgKFxuICAgICFwcm9jIHx8XG4gICAgIWlzUHJvY2VkdXJlKHByb2MpIHx8XG4gICAgKHByb2MuX2RlZi50eXBlICE9PSB0eXBlICYmICFvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUpXG4gICkge1xuICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgY29kZTogJ05PVF9GT1VORCcsXG4gICAgICBtZXNzYWdlOiBgTm8gXCIke3R5cGV9XCItcHJvY2VkdXJlIG9uIHBhdGggXCIke3BhdGh9XCJgLFxuICAgIH0pO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0tIEBwcmVzZXJ2ZSAqL1xuICBpZiAoXG4gICAgcHJvYy5fZGVmLnR5cGUgIT09IHR5cGUgJiZcbiAgICBvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUgJiZcbiAgICBwcm9jLl9kZWYudHlwZSA9PT0gJ3N1YnNjcmlwdGlvbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IFRSUENFcnJvcih7XG4gICAgICBjb2RlOiAnTUVUSE9EX05PVF9TVVBQT1JURUQnLFxuICAgICAgbWVzc2FnZTogYE1ldGhvZCBvdmVycmlkZSBpcyBub3Qgc3VwcG9ydGVkIGZvciBzdWJzY3JpcHRpb25zYCxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBwcm9jKG9wdHMpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlckNhbGxlckZhY3Rvcnk8VFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXM+IHtcbiAgPFRSZWNvcmQgZXh0ZW5kcyBSb3V0ZXJSZWNvcmQ+KFxuICAgIHJvdXRlcjogUGljazxSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+LCAnX2RlZic+LFxuICApOiBSb3V0ZXJDYWxsZXI8VFJvb3QsIFRSZWNvcmQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2FsbGVyRmFjdG9yeTxcbiAgVFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXMsXG4+KCk6IFJvdXRlckNhbGxlckZhY3Rvcnk8VFJvb3Q+IHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNhbGxlcklubmVyPFRSZWNvcmQgZXh0ZW5kcyBSb3V0ZXJSZWNvcmQ+KFxuICAgIHJvdXRlcjogUGljazxSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+LCAnX2RlZic+LFxuICApOiBSb3V0ZXJDYWxsZXI8VFJvb3QsIFRSZWNvcmQ+IHtcbiAgICBjb25zdCB7IF9kZWYgfSA9IHJvdXRlcjtcbiAgICB0eXBlIENvbnRleHQgPSBUUm9vdFsnY3R4J107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVyKGN0eE9yQ2FsbGJhY2ssIG9wdHMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVSZWN1cnNpdmVQcm94eTxSZXR1cm5UeXBlPFJvdXRlckNhbGxlcjxhbnksIGFueT4+PihcbiAgICAgICAgYXN5bmMgKHsgcGF0aCwgYXJncyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oJy4nKTtcblxuICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiBwYXRoWzBdID09PSAnX2RlZicpIHtcbiAgICAgICAgICAgIHJldHVybiBfZGVmO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChyb3V0ZXIsIGZ1bGxQYXRoKTtcblxuICAgICAgICAgIGxldCBjdHg6IENvbnRleHQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghcHJvY2VkdXJlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6ICdOT1RfRk9VTkQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBObyBwcm9jZWR1cmUgZm91bmQgb24gcGF0aCBcIiR7cGF0aH1cImAsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4ID0gaXNGdW5jdGlvbihjdHhPckNhbGxiYWNrKVxuICAgICAgICAgICAgICA/IGF3YWl0IFByb21pc2UucmVzb2x2ZShjdHhPckNhbGxiYWNrKCkpXG4gICAgICAgICAgICAgIDogY3R4T3JDYWxsYmFjaztcblxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHByb2NlZHVyZSh7XG4gICAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgICBnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4gYXJnc1swXSxcbiAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICB0eXBlOiBwcm9jZWR1cmUuX2RlZi50eXBlLFxuICAgICAgICAgICAgICBzaWduYWw6IG9wdHM/LnNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGNhdXNlKSB7XG4gICAgICAgICAgICBvcHRzPy5vbkVycm9yPy4oe1xuICAgICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICAgIGVycm9yOiBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksXG4gICAgICAgICAgICAgIGlucHV0OiBhcmdzWzBdLFxuICAgICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgICAgdHlwZTogcHJvY2VkdXJlPy5fZGVmLnR5cGUgPz8gJ3Vua25vd24nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBjYXVzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH07XG4gIH07XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB0eXBlIE1lcmdlUm91dGVyczxcbiAgVFJvdXRlcnMgZXh0ZW5kcyBBbnlSb3V0ZXJbXSxcbiAgVFJvb3QgZXh0ZW5kcyBBbnlSb290VHlwZXMgPSBUUm91dGVyc1swXVsnX2RlZiddWydfY29uZmlnJ11bJyR0eXBlcyddLFxuICBUUmVjb3JkIGV4dGVuZHMgUm91dGVyUmVjb3JkID0ge30sXG4+ID0gVFJvdXRlcnMgZXh0ZW5kcyBbXG4gIGluZmVyIEhlYWQgZXh0ZW5kcyBBbnlSb3V0ZXIsXG4gIC4uLmluZmVyIFRhaWwgZXh0ZW5kcyBBbnlSb3V0ZXJbXSxcbl1cbiAgPyBNZXJnZVJvdXRlcnM8VGFpbCwgVFJvb3QsIEhlYWRbJ19kZWYnXVsncmVjb3JkJ10gJiBUUmVjb3JkPlxuICA6IEJ1aWx0Um91dGVyPFRSb290LCBUUmVjb3JkPjtcblxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlUm91dGVyczxUUm91dGVycyBleHRlbmRzIEFueVJvdXRlcltdPihcbiAgLi4ucm91dGVyTGlzdDogWy4uLlRSb3V0ZXJzXVxuKTogTWVyZ2VSb3V0ZXJzPFRSb3V0ZXJzPiB7XG4gIGNvbnN0IHJlY29yZCA9IG1lcmdlV2l0aG91dE92ZXJyaWRlcyhcbiAgICB7fSxcbiAgICAuLi5yb3V0ZXJMaXN0Lm1hcCgocikgPT4gci5fZGVmLnJlY29yZCksXG4gICk7XG4gIGNvbnN0IGVycm9yRm9ybWF0dGVyID0gcm91dGVyTGlzdC5yZWR1Y2UoXG4gICAgKGN1cnJlbnRFcnJvckZvcm1hdHRlciwgbmV4dFJvdXRlcikgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAmJlxuICAgICAgICBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlclxuICAgICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IGRlZmF1bHRGb3JtYXR0ZXIgJiZcbiAgICAgICAgICBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNlZW0gdG8gaGF2ZSBzZXZlcmFsIGVycm9yIGZvcm1hdHRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFJvdXRlci5fZGVmLl9jb25maWcuZXJyb3JGb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudEVycm9yRm9ybWF0dGVyO1xuICAgIH0sXG4gICAgZGVmYXVsdEZvcm1hdHRlcixcbiAgKTtcblxuICBjb25zdCB0cmFuc2Zvcm1lciA9IHJvdXRlckxpc3QucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgaWYgKFxuICAgICAgY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgJiZcbiAgICAgIGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyICE9PSBkZWZhdWx0VHJhbnNmb3JtZXJcbiAgICApIHtcbiAgICAgIGlmIChcbiAgICAgICAgcHJldiAhPT0gZGVmYXVsdFRyYW5zZm9ybWVyICYmXG4gICAgICAgIHByZXYgIT09IGN1cnJlbnQuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2VlbSB0byBoYXZlIHNldmVyYWwgdHJhbnNmb3JtZXJzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHJldHVybiBwcmV2O1xuICB9LCBkZWZhdWx0VHJhbnNmb3JtZXIpO1xuXG4gIGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdXRlckZhY3Rvcnkoe1xuICAgIGVycm9yRm9ybWF0dGVyLFxuICAgIHRyYW5zZm9ybWVyLFxuICAgIGlzRGV2OiByb3V0ZXJMaXN0LmV2ZXJ5KChyKSA9PiByLl9kZWYuX2NvbmZpZy5pc0RldiksXG4gICAgYWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHJvdXRlckxpc3QuZXZlcnkoXG4gICAgICAocikgPT4gci5fZGVmLl9jb25maWcuYWxsb3dPdXRzaWRlT2ZTZXJ2ZXIsXG4gICAgKSxcbiAgICBpc1NlcnZlcjogcm91dGVyTGlzdC5ldmVyeSgocikgPT4gci5fZGVmLl9jb25maWcuaXNTZXJ2ZXIpLFxuICAgICR0eXBlczogcm91dGVyTGlzdFswXT8uX2RlZi5fY29uZmlnLiR0eXBlcyxcbiAgfSkocmVjb3JkKTtcblxuICByZXR1cm4gcm91dGVyIGFzIE1lcmdlUm91dGVyczxUUm91dGVycz47XG59XG4iLCJjb25zdCB0cmFja2VkU3ltYm9sID0gU3ltYm9sKCk7XG5cbnR5cGUgVHJhY2tlZElkID0gc3RyaW5nICYge1xuICBfX2JyYW5kOiAnVHJhY2tlZElkJztcbn07XG5leHBvcnQgdHlwZSBUcmFja2VkRW52ZWxvcGU8VERhdGE+ID0gW1RyYWNrZWRJZCwgVERhdGEsIHR5cGVvZiB0cmFja2VkU3ltYm9sXTtcblxudHlwZSBUcmFja2VkRGF0YTxURGF0YT4gPSB7XG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIG1lc3NhZ2UgdG8ga2VlcCB0cmFjayBvZiBpbiBjYXNlIHRoZSBjb25uZWN0aW9uIGdldHMgbG9zdFxuICAgKi9cbiAgaWQ6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBkYXRhIGZpZWxkIG9mIHRoZSBtZXNzYWdlIC0gdGhpcyBjYW4gYmUgYW55dGhpbmdcbiAgICovXG4gIGRhdGE6IFREYXRhO1xufTtcbi8qKlxuICogUHJvZHVjZSBhIHR5cGVkIHNlcnZlci1zZW50IGV2ZW50IG1lc3NhZ2VcbiAqIEBkZXByZWNhdGVkIHVzZSBgdHJhY2tlZChpZCwgZGF0YSlgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNzZTxURGF0YT4oZXZlbnQ6IHsgaWQ6IHN0cmluZzsgZGF0YTogVERhdGEgfSkge1xuICByZXR1cm4gdHJhY2tlZChldmVudC5pZCwgZXZlbnQuZGF0YSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1RyYWNrZWRFbnZlbG9wZTxURGF0YT4oXG4gIHZhbHVlOiB1bmtub3duLFxuKTogdmFsdWUgaXMgVHJhY2tlZEVudmVsb3BlPFREYXRhPiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZVsyXSA9PT0gdHJhY2tlZFN5bWJvbDtcbn1cblxuLyoqXG4gKiBBdXRvbWF0aWNhbGx5IHRyYWNrIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgZnJvbSBhIGdpdmVuIGlkIGlmIHRoZSBjb25uZWN0aW9uIGlzIGxvc3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrZWQ8VERhdGE+KFxuICBpZDogc3RyaW5nLFxuICBkYXRhOiBURGF0YSxcbik6IFRyYWNrZWRFbnZlbG9wZTxURGF0YT4ge1xuICBpZiAoaWQgPT09ICcnKSB7XG4gICAgLy8gVGhpcyBsaW1pdGF0aW9uIGNvdWxkIGJlIHJlbW92ZWQgYnkgdXNpbmcgZGlmZmVyZW50IFNTRSBldmVudCBuYW1lcyAvIGNoYW5uZWxzIGZvciB0cmFja2VkIGV2ZW50IGFuZCBub24tdHJhY2tlZCBldmVudFxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgaWRgIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBhcyBlbXB0eSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgbm90IHNldHRpbmcgdGhlIGlkIGF0IGFsbCcsXG4gICAgKTtcbiAgfVxuICByZXR1cm4gW2lkIGFzIFRyYWNrZWRJZCwgZGF0YSwgdHJhY2tlZFN5bWJvbF07XG59XG5cbmV4cG9ydCB0eXBlIGluZmVyVHJhY2tlZE91dHB1dDxURGF0YT4gPVxuICBURGF0YSBleHRlbmRzIFRyYWNrZWRFbnZlbG9wZTxpbmZlciAkRGF0YT4gPyBUcmFja2VkRGF0YTwkRGF0YT4gOiBURGF0YTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0Rm9ybWF0dGVyOiBFcnJvckZvcm1hdHRlcjxhbnksIGFueT4iLCJjYXVzZTogdW5rbm93biIsIm9wdHM6IHtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIGNvZGU6IFRSUENfRVJST1JfQ09ERV9LRVk7XG4gICAgY2F1c2U/OiB1bmtub3duO1xuICB9IiwidHJhbnNmb3JtZXI6IERhdGFUcmFuc2Zvcm1lck9wdGlvbnMiLCJkZWZhdWx0VHJhbnNmb3JtZXI6IENvbWJpbmVkRGF0YVRyYW5zZm9ybWVyIiwiY29uZmlnOiBSb290Q29uZmlnPEFueVJvb3RUeXBlcz4iLCJpdGVtOiBUUmVzcG9uc2VJdGVtIiwiaXRlbU9ySXRlbXM6IFRSZXNwb25zZSIsInJlc3BvbnNlOlxuICAgIHwgVFJQQ1Jlc3BvbnNlPFRPdXRwdXQsIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+XG4gICAgfCBUUlBDUmVzcG9uc2VNZXNzYWdlPFRPdXRwdXQsIGluZmVyUm91dGVyRXJyb3I8VFJvdXRlcj4+IiwidHJhbnNmb3JtZXI6IERhdGFUcmFuc2Zvcm1lciIsInJlc3VsdDogUmV0dXJuVHlwZTx0eXBlb2YgdHJhbnNmb3JtUmVzdWx0SW5uZXI+IiwiZm46ICgpID0+IFQiLCJyZXN1bHQ6IFQgfCB0eXBlb2YgdW5jYWxsZWQiLCJpbXBvcnRSb3V0ZXI6ICgpID0+IFByb21pc2U8XG4gICAgfCBUUm91dGVyXG4gICAgfCB7XG4gICAgICAgIFtrZXk6IHN0cmluZ106IFRSb3V0ZXI7XG4gICAgICB9XG4gID4iLCJpbnB1dDogdW5rbm93biIsInZhbHVlOiB1bmtub3duIiwiY29uZmlnOiBSb290Q29uZmlnPFRSb290PiIsImlucHV0OiBUSW5wdXQiLCJwcm9jZWR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBBbnlQcm9jZWR1cmU+IiwibGF6eTogUmVjb3JkPHN0cmluZywgTGF6eUxvYWRlcjxBbnlSb3V0ZXI+PiIsIm9wdHM6IHtcbiAgICAgIHJlZjogTGF6eTxBbnlSb3V0ZXI+O1xuICAgICAgcGF0aDogcmVhZG9ubHkgc3RyaW5nW107XG4gICAgICBrZXk6IHN0cmluZztcbiAgICAgIGFnZ3JlZ2F0ZTogUm91dGVyUmVjb3JkO1xuICAgIH0iLCJyb3V0ZXIiLCJsYXp5IiwiZnJvbTogQ3JlYXRlUm91dGVyT3B0aW9ucyIsInBhdGg6IHJlYWRvbmx5IHN0cmluZ1tdIiwiYWdncmVnYXRlOiBSb3V0ZXJSZWNvcmQiLCJfZGVmOiBBbnlSb3V0ZXJbJ19kZWYnXSIsInJvdXRlcjogQnVpbHRSb3V0ZXI8VFJvb3QsIHt9PiIsInByb2NlZHVyZU9yUm91dGVyOiBWYWx1ZU9mPENyZWF0ZVJvdXRlck9wdGlvbnM+Iiwicm91dGVyOiBQaWNrPFJvdXRlcjxhbnksIGFueT4sICdfZGVmJz4iLCJwYXRoOiBzdHJpbmciLCJrZXkiLCJvcHRzOiBQcm9jZWR1cmVDYWxsT3B0aW9uczx1bmtub3duPiAmIHtcbiAgICByb3V0ZXI6IEFueVJvdXRlcjtcbiAgICBhbGxvd01ldGhvZE92ZXJyaWRlPzogYm9vbGVhbjtcbiAgfSIsInJvdXRlcjogUGljazxSb3V0ZXI8VFJvb3QsIFRSZWNvcmQ+LCAnX2RlZic+IiwiY3R4OiBDb250ZXh0IHwgdW5kZWZpbmVkIiwiZXZlbnQ6IHsgaWQ6IHN0cmluZzsgZGF0YTogVERhdGEgfSIsImlkOiBzdHJpbmciLCJkYXRhOiBURGF0YSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/tracked-gU3ttYjg.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPC_ERROR_CODES_BY_KEY: () => (/* binding */ TRPC_ERROR_CODES_BY_KEY),\n/* harmony export */   TRPC_ERROR_CODES_BY_NUMBER: () => (/* binding */ TRPC_ERROR_CODES_BY_NUMBER),\n/* harmony export */   abortSignalsAnyPonyfill: () => (/* binding */ abortSignalsAnyPonyfill),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeWithoutOverrides: () => (/* binding */ mergeWithoutOverrides),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omitPrototype: () => (/* binding */ omitPrototype),\n/* harmony export */   retryableRpcCodes: () => (/* binding */ retryableRpcCodes),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we're copying the last digits of HTTP 4XX errors.\n*/ const TRPC_ERROR_CODES_BY_KEY = {\n    PARSE_ERROR: -32700,\n    BAD_REQUEST: -32600,\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    BAD_GATEWAY: -32603,\n    SERVICE_UNAVAILABLE: -32603,\n    GATEWAY_TIMEOUT: -32603,\n    UNAUTHORIZED: -32001,\n    PAYMENT_REQUIRED: -32002,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNSUPPORTED_MEDIA_TYPE: -32015,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n    [-32700]: \"PARSE_ERROR\",\n    [-32600]: \"BAD_REQUEST\",\n    [-32603]: \"INTERNAL_SERVER_ERROR\",\n    [-32001]: \"UNAUTHORIZED\",\n    [-32002]: \"PAYMENT_REQUIRED\",\n    [-32003]: \"FORBIDDEN\",\n    [-32004]: \"NOT_FOUND\",\n    [-32005]: \"METHOD_NOT_SUPPORTED\",\n    [-32008]: \"TIMEOUT\",\n    [-32009]: \"CONFLICT\",\n    [-32012]: \"PRECONDITION_FAILED\",\n    [-32013]: \"PAYLOAD_TOO_LARGE\",\n    [-32015]: \"UNSUPPORTED_MEDIA_TYPE\",\n    [-32022]: \"UNPROCESSABLE_CONTENT\",\n    [-32029]: \"TOO_MANY_REQUESTS\",\n    [-32099]: \"CLIENT_CLOSED_REQUEST\"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/ const retryableRpcCodes = [\n    TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n    TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n    TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n    TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n//#endregion\n//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs)for(const key in overrides){\n        if (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n        newObj[key] = overrides[key];\n    }\n    return newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/ function isObject(value) {\n    return !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === \"function\" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n    return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/ const run = (fn)=>fn();\nfunction noop() {}\nfunction identity(it) {\n    return it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/ function assert(condition, msg = \"no additional info\") {\n    if (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/ function abortSignalsAnyPonyfill(signals) {\n    if (typeof AbortSignal.any === \"function\") return AbortSignal.any(signals);\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal.aborted) {\n            trigger();\n            break;\n        }\n        signal.addEventListener(\"abort\", trigger, {\n            once: true\n        });\n    }\n    return ac.signal;\n    function trigger() {\n        ac.abort();\n        for (const signal of signals)signal.removeEventListener(\"abort\", trigger);\n    }\n}\n//#endregion\n //# sourceMappingURL=utils-DdbbrDku.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0cnBjK3NlcnZlckAxMS40LjJfdHlwZXNjcmlwdEA1LjguMy9ub2RlX21vZHVsZXMvQHRycGMvc2VydmVyL2Rpc3QvdXRpbHMtRGRiYnJEa3UubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBVUEsTUFBYSwwQkFBMEI7SUFLckMsYUFBYTtJQUliLGFBQWE7SUFHYix1QkFBdUI7SUFDdkIsaUJBQWlCO0lBQ2pCLGFBQWE7SUFDYixxQkFBcUI7SUFDckIsaUJBQWlCO0lBR2pCLGNBQWM7SUFDZCxrQkFBa0I7SUFDbEIsV0FBVztJQUNYLFdBQVc7SUFDWCxzQkFBc0I7SUFDdEIsU0FBUztJQUNULFVBQVU7SUFDVixxQkFBcUI7SUFDckIsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4Qix1QkFBdUI7SUFDdkIsbUJBQW1CO0lBQ25CLHVCQUF1QjtBQUN4QjtBQUdELE1BQWFBLDZCQUVUO0tBQ0QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztLQUNULFNBQVM7S0FDVCxTQUFTO0tBQ1QsU0FBUztBQUNYOzs7O0dBU0QsTUFBYUMsb0JBQThDO0lBQ3pELHdCQUF3QjtJQUN4Qix3QkFBd0I7SUFDeEIsd0JBQXdCO0lBQ3hCLHdCQUF3QjtDQUN6Qjs7Ozs7O0dDckVELFNBQWdCLHNCQUNkQyxJQUFBQSxFQUNBLEdBQUcsTUFDSTtJQUNQLE1BQU1DLFNBQWdCLE9BQU8sT0FBTyxPQUFPLE9BQU8sS0FBSyxFQUFFLEtBQUs7SUFFOUQsS0FBSyxNQUFNLGFBQWEsS0FDdEIsSUFBSyxNQUFNLE9BQU8sVUFBVztRQUMzQixJQUFJLE9BQU8sVUFBVSxPQUFPLFNBQVMsVUFBVSxLQUM3QyxPQUFNLElBQUksT0FBTyxnQkFBZ0IsSUFBSTtRQUV2QyxPQUFPLE9BQXNCLFVBQVU7SUFDeEM7SUFFSCxPQUFPO0FBQ1I7Ozs7R0FNRCxTQUFnQixTQUFTQyxLQUFBQSxFQUFrRDtJQUN6RSxTQUFTLFVBQVUsTUFBTSxRQUFRLE1BQU0sV0FBVyxVQUFVO0FBQzdEO0FBR0QsU0FBZ0IsV0FBV0MsRUFBQUEsRUFBMEI7SUFDbkQsY0FBYyxPQUFPO0FBQ3RCOzs7O0dBTUQsU0FBZ0IsY0FDZEMsR0FBQUEsRUFDTTtJQUNOLE9BQU8sT0FBTyxPQUFPLE9BQU8sT0FBTyxLQUFLLEVBQUUsSUFBSTtBQUMvQztBQUVELE1BQU0saUNBQ0csV0FBVyxnQkFBZ0IsT0FBTztBQUUzQyxTQUFnQixnQkFDZEYsS0FBQUEsRUFDZ0M7SUFDaEMsT0FDRSwyQkFBMkIsU0FBUyxNQUFNLElBQUksT0FBTyxpQkFBaUI7QUFFekU7OztHQUtELE1BQWEsTUFBTSxDQUFTRyxLQUE2QixJQUFJO0FBRzdELFNBQWdCLE9BQWEsQ0FBRTtBQUUvQixTQUFnQixTQUFZQyxFQUFBQSxFQUFVO0lBQ3BDLE9BQU87QUFDUjs7Ozs7O0dBUUQsU0FBZ0IsT0FDZEMsU0FBQUEsRUFDQSxNQUFNLHNCQUNhO0lBQ25CLEtBQUssVUFDSCxPQUFNLElBQUksT0FBTyxrQkFBa0IsSUFBSTtBQUUxQztBQUVELFNBQWdCLE1BQU0sS0FBSyxHQUFrQjtJQUMzQyxPQUFPLElBQUksUUFBYyxDQUFDLE1BQVEsV0FBVyxLQUFLLEdBQUc7QUFDdEQ7Ozs7R0FNRCxTQUFnQix3QkFBd0JDLE9BQUFBLEVBQXFDO0lBQzNFLFdBQVcsWUFBWSxRQUFRLFdBQzdCLFFBQU8sWUFBWSxJQUFJLFFBQVE7SUFHakMsTUFBTSxLQUFLLElBQUk7SUFFZixLQUFLLE1BQU0sVUFBVSxRQUFTO1FBQzVCLElBQUksT0FBTyxTQUFTO1lBQ2xCLFNBQVM7WUFDVDtRQUNEO1FBQ0QsT0FBTyxpQkFBaUIsU0FBUyxTQUFTO1lBQUUsTUFBTTtRQUFNLEVBQUM7SUFDMUQ7SUFFRCxPQUFPLEdBQUc7SUFFVixTQUFTLFVBQVU7UUFDakIsR0FBRyxPQUFPO1FBQ1YsS0FBSyxNQUFNLFVBQVUsUUFDbkIsT0FBTyxvQkFBb0IsU0FBUyxRQUFRO0lBRS9DO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wZXRlcmphbWVzYmxpenphcmQvcHJvamVjdHMvYXBwX2NvZGV4Y3JtYXBwL2FwcHMvc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9ycGMvY29kZXMudHMiLCIvVXNlcnMvcGV0ZXJqYW1lc2JsaXp6YXJkL3Byb2plY3RzL2FwcF9jb2RleGNybWFwcC9hcHBzL3NyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvdXRpbHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBJbnZlcnRLZXlWYWx1ZSwgVmFsdWVPZiB9IGZyb20gJy4uL3R5cGVzJztcblxuLy8gcmVmZXJlbmNlOiBodHRwczovL3d3dy5qc29ucnBjLm9yZy9zcGVjaWZpY2F0aW9uXG5cbi8qKlxuICogSlNPTi1SUEMgMi4wIEVycm9yIGNvZGVzXG4gKlxuICogYC0zMjAwMGAgdG8gYC0zMjA5OWAgYXJlIHJlc2VydmVkIGZvciBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHNlcnZlci1lcnJvcnMuXG4gKiBGb3IgdFJQQyB3ZSdyZSBjb3B5aW5nIHRoZSBsYXN0IGRpZ2l0cyBvZiBIVFRQIDRYWCBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSA9IHtcbiAgLyoqXG4gICAqIEludmFsaWQgSlNPTiB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci5cbiAgICogQW4gZXJyb3Igb2NjdXJyZWQgb24gdGhlIHNlcnZlciB3aGlsZSBwYXJzaW5nIHRoZSBKU09OIHRleHQuXG4gICAqL1xuICBQQVJTRV9FUlJPUjogLTMyNzAwLFxuICAvKipcbiAgICogVGhlIEpTT04gc2VudCBpcyBub3QgYSB2YWxpZCBSZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIEJBRF9SRVFVRVNUOiAtMzI2MDAsIC8vIDQwMFxuXG4gIC8vIEludGVybmFsIEpTT04tUlBDIGVycm9yXG4gIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogLTMyNjAzLCAvLyA1MDBcbiAgTk9UX0lNUExFTUVOVEVEOiAtMzI2MDMsIC8vIDUwMVxuICBCQURfR0FURVdBWTogLTMyNjAzLCAvLyA1MDJcbiAgU0VSVklDRV9VTkFWQUlMQUJMRTogLTMyNjAzLCAvLyA1MDNcbiAgR0FURVdBWV9USU1FT1VUOiAtMzI2MDMsIC8vIDUwNFxuXG4gIC8vIEltcGxlbWVudGF0aW9uIHNwZWNpZmljIGVycm9yc1xuICBVTkFVVEhPUklaRUQ6IC0zMjAwMSwgLy8gNDAxXG4gIFBBWU1FTlRfUkVRVUlSRUQ6IC0zMjAwMiwgLy8gNDAyXG4gIEZPUkJJRERFTjogLTMyMDAzLCAvLyA0MDNcbiAgTk9UX0ZPVU5EOiAtMzIwMDQsIC8vIDQwNFxuICBNRVRIT0RfTk9UX1NVUFBPUlRFRDogLTMyMDA1LCAvLyA0MDVcbiAgVElNRU9VVDogLTMyMDA4LCAvLyA0MDhcbiAgQ09ORkxJQ1Q6IC0zMjAwOSwgLy8gNDA5XG4gIFBSRUNPTkRJVElPTl9GQUlMRUQ6IC0zMjAxMiwgLy8gNDEyXG4gIFBBWUxPQURfVE9PX0xBUkdFOiAtMzIwMTMsIC8vIDQxM1xuICBVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiAtMzIwMTUsIC8vIDQxNVxuICBVTlBST0NFU1NBQkxFX0NPTlRFTlQ6IC0zMjAyMiwgLy8gNDIyXG4gIFRPT19NQU5ZX1JFUVVFU1RTOiAtMzIwMjksIC8vIDQyOVxuICBDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IC0zMjA5OSwgLy8gNDk5XG59IGFzIGNvbnN0O1xuXG4vLyBwdXJlXG5leHBvcnQgY29uc3QgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVI6IEludmVydEtleVZhbHVlPFxuICB0eXBlb2YgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVlcbj4gPSB7XG4gIFstMzI3MDBdOiAnUEFSU0VfRVJST1InLFxuICBbLTMyNjAwXTogJ0JBRF9SRVFVRVNUJyxcbiAgWy0zMjYwM106ICdJTlRFUk5BTF9TRVJWRVJfRVJST1InLFxuICBbLTMyMDAxXTogJ1VOQVVUSE9SSVpFRCcsXG4gIFstMzIwMDJdOiAnUEFZTUVOVF9SRVFVSVJFRCcsXG4gIFstMzIwMDNdOiAnRk9SQklEREVOJyxcbiAgWy0zMjAwNF06ICdOT1RfRk9VTkQnLFxuICBbLTMyMDA1XTogJ01FVEhPRF9OT1RfU1VQUE9SVEVEJyxcbiAgWy0zMjAwOF06ICdUSU1FT1VUJyxcbiAgWy0zMjAwOV06ICdDT05GTElDVCcsXG4gIFstMzIwMTJdOiAnUFJFQ09ORElUSU9OX0ZBSUxFRCcsXG4gIFstMzIwMTNdOiAnUEFZTE9BRF9UT09fTEFSR0UnLFxuICBbLTMyMDE1XTogJ1VOU1VQUE9SVEVEX01FRElBX1RZUEUnLFxuICBbLTMyMDIyXTogJ1VOUFJPQ0VTU0FCTEVfQ09OVEVOVCcsXG4gIFstMzIwMjldOiAnVE9PX01BTllfUkVRVUVTVFMnLFxuICBbLTMyMDk5XTogJ0NMSUVOVF9DTE9TRURfUkVRVUVTVCcsXG59O1xuXG5leHBvcnQgdHlwZSBUUlBDX0VSUk9SX0NPREVfTlVNQkVSID0gVmFsdWVPZjx0eXBlb2YgVFJQQ19FUlJPUl9DT0RFU19CWV9LRVk+O1xuZXhwb3J0IHR5cGUgVFJQQ19FUlJPUl9DT0RFX0tFWSA9IGtleW9mIHR5cGVvZiBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWTtcblxuLyoqXG4gKiB0UlBDIGVycm9yIGNvZGVzIHRoYXQgYXJlIGNvbnNpZGVyZWQgcmV0cnlhYmxlXG4gKiBXaXRoIG91dCBvZiB0aGUgYm94IFNTRSwgdGhlIGNsaWVudCB3aWxsIHJlY29ubmVjdCB3aGVuIHRoZXNlIGVycm9ycyBhcmUgZW5jb3VudGVyZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHJldHJ5YWJsZVJwY0NvZGVzOiBUUlBDX0VSUk9SX0NPREVfTlVNQkVSW10gPSBbXG4gIFRSUENfRVJST1JfQ09ERVNfQllfS0VZLkJBRF9HQVRFV0FZLFxuICBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5TRVJWSUNFX1VOQVZBSUxBQkxFLFxuICBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5HQVRFV0FZX1RJTUVPVVQsXG4gIFRSUENfRVJST1JfQ09ERVNfQllfS0VZLklOVEVSTkFMX1NFUlZFUl9FUlJPUixcbl07XG4iLCIvKiogQGludGVybmFsICovXG5leHBvcnQgdHlwZSBVbnNldE1hcmtlciA9ICd1bnNldE1hcmtlcicgJiB7XG4gIF9fYnJhbmQ6ICd1bnNldE1hcmtlcic7XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZSBrZXlzIHdoZW4gYnVpbGRpbmcgYSBwcm9jZWR1cmUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlV2l0aG91dE92ZXJyaWRlczxUVHlwZSBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb2JqMTogVFR5cGUsXG4gIC4uLm9ianM6IFBhcnRpYWw8VFR5cGU+W11cbik6IFRUeXBlIHtcbiAgY29uc3QgbmV3T2JqOiBUVHlwZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwgb2JqMSk7XG5cbiAgZm9yIChjb25zdCBvdmVycmlkZXMgb2Ygb2Jqcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG92ZXJyaWRlcykge1xuICAgICAgaWYgKGtleSBpbiBuZXdPYmogJiYgbmV3T2JqW2tleV0gIT09IG92ZXJyaWRlc1trZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGtleSAke2tleX1gKTtcbiAgICAgIH1cbiAgICAgIG5ld09ialtrZXkgYXMga2V5b2YgVFR5cGVdID0gb3ZlcnJpZGVzW2tleV0gYXMgVFR5cGVba2V5b2YgVFR5cGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3T2JqO1xufVxuXG4vKipcbiAqIENoZWNrIHRoYXQgdmFsdWUgaXMgb2JqZWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4ge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jztcbn1cblxudHlwZSBBbnlGbiA9ICgoLi4uYXJnczogYW55W10pID0+IHVua25vd24pICYgUmVjb3JkPGtleW9mIGFueSwgdW5rbm93bj47XG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbihmbjogdW5rbm93bik6IGZuIGlzIEFueUZuIHtcbiAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gb2JqZWN0IHdpdGhvdXQgaW5oZXJpdGluZyBhbnl0aGluZyBmcm9tIGBPYmplY3QucHJvdG90eXBlYFxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbWl0UHJvdG90eXBlPFRPYmogZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gIG9iajogVE9iaixcbik6IFRPYmoge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvYmopO1xufVxuXG5jb25zdCBhc3luY0l0ZXJhdG9yc1N1cHBvcnRlZCA9XG4gIHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgISFTeW1ib2wuYXN5bmNJdGVyYXRvcjtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXN5bmNJdGVyYWJsZTxUVmFsdWU+KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIEFzeW5jSXRlcmFibGU8VFZhbHVlPiB7XG4gIHJldHVybiAoXG4gICAgYXN5bmNJdGVyYXRvcnNTdXBwb3J0ZWQgJiYgaXNPYmplY3QodmFsdWUpICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlXG4gICk7XG59XG5cbi8qKlxuICogUnVuIGFuIElJRkVcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1biA9IDxUVmFsdWU+KGZuOiAoKSA9PiBUVmFsdWUpOiBUVmFsdWUgPT4gZm4oKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKTogdm9pZCB7fVxuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHk8VD4oaXQ6IFQpOiBUIHtcbiAgcmV0dXJuIGl0O1xufVxuXG4vKipcbiAqIEdlbmVyaWMgcnVudGltZSBhc3NlcnRpb24gZnVuY3Rpb24uIFRocm93cywgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgYHRydWVgLlxuICpcbiAqIENhbiBiZSB1c2VkIGFzIGEgc2xpZ2h0bHkgbGVzcyBkYW5nZXJvdXMgdmFyaWFudCBvZiB0eXBlIGFzc2VydGlvbnMuIENvZGVcbiAqIG1pc3Rha2VzIHdvdWxkIGJlIHJldmVhbGVkIGF0IHJ1bnRpbWUgdGhlbiAoaG9wZWZ1bGx5IGR1cmluZyB0ZXN0aW5nKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChcbiAgY29uZGl0aW9uOiBib29sZWFuLFxuICBtc2cgPSAnbm8gYWRkaXRpb25hbCBpbmZvJyxcbik6IGFzc2VydHMgY29uZGl0aW9uIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2VydGlvbkVycm9yOiAke21zZ31gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2xlZXAobXMgPSAwKTogUHJvbWlzZTx2b2lkPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbXMpKTtcbn1cblxuLyoqXG4gKiBQb255ZmlsbCBmb3JcbiAqIFtgQWJvcnRTaWduYWwuYW55YF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsL2FueV9zdGF0aWMpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRTaWduYWxzQW55UG9ueWZpbGwoc2lnbmFsczogQWJvcnRTaWduYWxbXSk6IEFib3J0U2lnbmFsIHtcbiAgaWYgKHR5cGVvZiBBYm9ydFNpZ25hbC5hbnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQWJvcnRTaWduYWwuYW55KHNpZ25hbHMpO1xuICB9XG5cbiAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cbiAgZm9yIChjb25zdCBzaWduYWwgb2Ygc2lnbmFscykge1xuICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgdHJpZ2dlcigpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRyaWdnZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJldHVybiBhYy5zaWduYWw7XG5cbiAgZnVuY3Rpb24gdHJpZ2dlcigpIHtcbiAgICBhYy5hYm9ydCgpO1xuICAgIGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHMpIHtcbiAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRyaWdnZXIpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbIlRSUENfRVJST1JfQ09ERVNfQllfTlVNQkVSOiBJbnZlcnRLZXlWYWx1ZTxcbiAgdHlwZW9mIFRSUENfRVJST1JfQ09ERVNfQllfS0VZXG4+IiwicmV0cnlhYmxlUnBjQ29kZXM6IFRSUENfRVJST1JfQ09ERV9OVU1CRVJbXSIsIm9iajE6IFRUeXBlIiwibmV3T2JqOiBUVHlwZSIsInZhbHVlOiB1bmtub3duIiwiZm46IHVua25vd24iLCJvYmo6IFRPYmoiLCJmbjogKCkgPT4gVFZhbHVlIiwiaXQ6IFQiLCJjb25kaXRpb246IGJvb2xlYW4iLCJzaWduYWxzOiBBYm9ydFNpZ25hbFtdIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@trpc+server@11.4.2_typescript@5.8.3/node_modules/@trpc/server/dist/utils-DdbbrDku.mjs\n");

/***/ })

};
;