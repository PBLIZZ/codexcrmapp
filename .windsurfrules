# CodexCRM Workspace Rules & Preferences

## Developer Mindset & Role

You are an expert full-stack developer focused on producing clear, readable, and maintainable code for the **CodexCRM** project, using **Next.js 15+ (App Router)**. You strictly follow the Global Rules regarding monorepo structure, path aliases, and core technologies (tRPC, Supabase, TanStack Query v5).

## Current Priority

**Your immediate focus is to help complete Sprint 1 tasks, primarily by resolving the existing build errors (`Module not found`, TypeScript issues) and getting the initial `clientRouter` tRPC endpoint fully wired and functional.** Implement fixes incrementally and verify them. Do NOT introduce new features or large refactors until the build is stable.

## Technical Preferences & Practices

### Component Architecture

- **Favor Server Components:** Use React Server Components (RSCs) by default for data fetching, routing logic, and non-interactive UI.
- **Isolate Client Components:** Use `'use client'` directives _only_ when necessary (for hooks like `useState`, `useEffect`, event handlers, or libraries requiring browser APIs like TanStack Query's `useQuery`). Keep Client Components small and push them down the component tree (pass data down as props from Server Components).
- **Naming:** Use **PascalCase** for component file names AND function/variable names (e.g., `ClientTable.tsx`, `function ClientTable() {}`). **Do NOT use kebab-case.**
- **Exports:** Prefer **named exports** for components (`export function MyComponent...`).

### Data Fetching & Handling

    *   **Server-Side:** Fetch data directly in Server Components using Supabase client helpers (e.g., from `@/lib/auth/actions.ts`) or via Server Actions.
    *   **Client-Side:** Use **TanStack Query v5 hooks** integrated with **tRPC** (`api.routerName.procedureName.useQuery()`, `useMutation()`) for fetching/mutating data interactively in Client Components.
    *   **Form Mutations:** For forms that trigger mutations, use Server Actions. In the Client Component containing the form, use the new React 19 hooks to manage state:
        *   `useActionState` to handle pending, error, and success states returned from a Server Action.
        *   `useFormStatus` to disable buttons or show spinners while the form is submitting.
        *   `useOptimistic` for instantaneous UI updates while the mutation is in flight.

### Server Actions Example

- Server Action (actions.ts)

```typescript
'use server';
import { z } from 'zod';

export async function updateUser(previousState: any, formData: FormData) {
  const schema = z.object({ name: z.string().min(1) });
  const validated = schema.safeParse({ name: formData.get('name') });

  if (!validated.success) {
    return { message: 'Name is required.' };
  }

  // ... database logic to update user ...

  return { message: 'User updated successfully!' };
}
```

### Client Component (UpdateUserForm.tsx)

```typescript
'use client';
import { useActionState } from 'react';
import { useFormStatus } from 'react-dom';
import { updateUser } from './actions';

function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <button type='submit' disabled={pending}>
      {pending ? 'Saving...' : 'Save'}
    </button>
  );
}

export function UpdateUserForm() {
  const [state, formAction] = useActionState(updateUser, { message: null });

  return (
    <form action={formAction}>
      <input type='text' name='name' />
      <SubmitButton />
      {state?.message && <p>{state.message}</p>}
    </form>
  );
}
```

## Postgres SQL Style Guide

### General

- Use lowercase for SQL reserved words to maintain consistency and readability.
- Employ consistent, descriptive identifiers for tables, columns, and other database objects.
- Use white space and indentation to enhance the readability of your code.
- Store dates in ISO 8601 format (`yyyy-mm-ddThh:mm:ss.sssss`).
- Include comments for complex logic, using '/_ ... _/' for block comments and '--' for line comments.

### Naming Conventions

- Avoid SQL reserved words and ensure names are unique and under 63 characters.
- Use snake_case for tables and columns.
- Prefer plurals for table names
- Prefer singular names for columns.

### Tables

- Avoid prefixes like 'tbl\_' and ensure no table name matches any of its column names.
- Always add an `id` column of type `uuid` unless otherwise specified.
- Create all tables in the `public` schema unless otherwise specified.
- Always add the schema to SQL queries for clarity.
- Always add a comment to describe what the table does. The comment can be up to 1024 characters.

### Columns

- Use singular names and avoid generic names like 'id'.
- For references to foreign tables, use the singular of the table name with the `_id` suffix. For example `user_id` to reference the `users` table
- Always use lowercase except in cases involving acronyms or when readability would be enhanced by an exception.

#### Examples:

```sql
create table sessions (
  id uuid generated always as identity primary key,
  title text not null,
  contact_id uuid references contacts (id)
);
comment on table sessions is 'A list of all the sessions for each contact.';
```

### Queries

- When the query is shorter keep it on just a few lines. As it gets larger start adding newlines for readability
- Add spaces for readability.

Smaller queries:

```sql
select *
from sessions
where end_date is null;

update sessions
set end_date = '2023-12-31'
where employee_id = 1001;
```

Larger queries:

```sql
select
  full_name,
  social_handles,
from
  sessions
where
  start_date between '2021-01-01' and '2021-12-31'
and
  status = 'attended';
```

#### Joins and Subqueries

- Format joins and subqueries for clarity, aligning them with related SQL clauses.
- Prefer full table names when referencing tables. This helps for readability.

```sql
select
  sessions.title,
  contacts.full_name,
from
  sessions
join
  contacts on sessions.contact_id = contacts.id
where
  sessions.start_date > '2022-01-01';
```

### Aliases

- Use meaningful aliases that reflect the data or transformation applied, and always include the 'as' keyword for clarity.

```sql
select count(*) as total_sessions
from sessions
where end_date is null;
```

### Complex queries and CTEs

- If a query is extremely complex, prefer a CTE.
- Make sure the CTE is clear and linear. Prefer readability over performance.
- Add comments to each block.

```sql
with session_contacts as (
  -- Get all sessions and their contacts
  select
    sessions.id,
    sessions.title,
    contacts.full_name,
    contacts.social_handles
  from
    sessions
  join
    contacts on sessions.contact_id = contacts.id
),
session_counts as (
  -- Count how many sessions in each department
  select
    full_name,
    count(*) as num_sessions
  from
    session_contacts
  group by
    full_name
)
select
  full_name,
  num_sessions
from
  session_counts
order by
  full_name;
```

## Styling & UI

- Use **Tailwind CSS** utility classes for all styling. Follow configuration in `apps/web/tailwind.config.ts`.
- Utilize **Shadcn UI** components (`import { Button } from '@/components/ui/button'`, etc.) for the UI library. Follow its usage patterns.
- Use semantic HTML elements (`<nav>`, `<main>`, `<article>`, `<button>`, etc.).

### TypeScript

- Adhere strictly to TypeScript (`strict: true`). Avoid `any`.
- Use explicit types/interfaces. Prefer `type` for object shapes/functions, `interface` for declaration merging needs.
- Do not use `enum`; use string literal unions or `as const` objects.

### General Coding

- Write functional, declarative code. Avoid classes.
- Prioritize readability and maintainability.
- Be explicit (e.g., `isLoading` boolean variables).
- Structure component files logically (e.g., main export, types, sub-components, helpers).
  - Implement requested functionality completely. Do not leave `// TODO` comments or placeholders or memories to deal with supposed unrelated issues later. Either fix them now or create or update a task in taskmaster to capture the taskl correctly and give it a high priority.
  - Do not leave any code that is not used or that is not needed unless specifically asked to.
  - Do not comment out code that is causing a lint error or a build error. Instead, fix underlying issue.

## Error Handling

These examples should be used as guidance when configuring Sentry functionality within a project.

# Exception Catching

- Use `Sentry.captureException(error)` to capture an exception and log the error in Sentry.
- Use this in try catch blocks or areas where exceptions are expected

# Tracing Examples

- Spans should be created for meaningful actions within an applications like button clicks, API calls, and function calls
- Use the `Sentry.startSpan` function to create a span
- Child spans can exist within a parent span

## Custom Span instrumentation in component actions

- The `name` and `op` properties should be meaninful for the activities in the call.
- Attach attributes based on relevant information and metrics from the request

```javascript
function TestComponent() {
  const handleTestButtonClick = () => {
    // Create a transaction/span to measure performance
    Sentry.startSpan(
      {
        op: 'ui.click',
        name: 'Test Button Click',
      },
      (span) => {
        const value = 'some config';
        const metric = 'some metric';

        // Metrics can be added to the span
        span.setAttribute('config', value);
        span.setAttribute('metric', metric);

        doSomething();
      }
    );
  };

  return (
    <button type='button' onClick={handleTestButtonClick}>
      Test Sentry
    </button>
  );
}
```

## Custom span instrumentation in API calls

The `name` and `op` properties should be meaninful for the activities in the call.
Attach attributes based on relevant information and metrics from the request

```javascript
async function fetchUserData(userId) {
  return Sentry.startSpan(
    {
      op: 'http.client',
      name: `GET /api/users/${userId}`,
    },
    async () => {
      const response = await fetch(`/api/users/${userId}`);
      const data = await response.json();
      return data;
    }
  );
}
```

# Logs

Where logs are used, ensure Sentry is imported using `import * as Sentry from "@sentry/nextjs"`
Enable logging in Sentry using `Sentry.init({ _experiments: { enableLogs: true } })`
Reference the logger using `const { logger } = Sentry`
Sentry offers a consoleLoggingIntegration that can be used to log specific console error types automatically without instrumenting the individual logger calls

## Configuration

In NextJS the client side Sentry initialization is in `instrumentation-client.ts`, the server initialization is in `sentry.edge.config.ts` and the edge initialization is in `sentry.server.config.ts`
Initialization does not need to be repeated in other files, it only needs to happen the files mentioned above. You should use `import * as Sentry from "@sentry/nextjs"` to reference Sentry functionality

### Baseline

```javascript
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',

  _experiments: {
    enableLogs: true,
  },
});
```

### Logger Integration

```javascript
Sentry.init({
  dsn: 'https://examplePublicKey@o0.ingest.sentry.io/0',
  integrations: [
    // send console.log, console.error, and console.warn calls as logs to Sentry
    Sentry.consoleLoggingIntegration({ levels: ['log', 'error', 'warn'] }),
  ],
});
```

## Logger Examples

`logger.fmt` is a template literal function that should be used to bring variables into the structured logs.

```javascript
logger.trace('Starting database connection', { database: 'users' });
logger.debug(logger.fmt`Cache miss for user: ${userId}`);
logger.info('Updated profile', { profileId: 345 });
logger.warn('Rate limit reached for endpoint', {
  endpoint: '/api/results/',
  isEnterprise: false,
});
logger.error('Failed to process payment', {
  orderId: 'order_123',
  amount: 99.99,
});
logger.fatal('Database connection pool exhausted', {
  database: 'users',
  activeConnections: 100,
});
```

## Interaction Style

- Reference specific file names (`apps/web/app/page.tsx`, `packages/server/src/router/client.ts`) when discussing changes.
- Explain _why_ a change is being made, especially if it relates to fixing an error or adhering to these rules.
- Be concise in explanations.
- If you are unsure or cannot fulfill a request according to these rules and the global context, state that clearly rather than guessing or deviating.

# Added by Task Master - Development Workflow Rules

Below you will find a variety of important rules spanning:

- the dev_workflow
- the .windsurfrules document self-improvement workflow
- the template to follow when modifying or adding new sections/rules to this document.

---

## DEV_WORKFLOW

description: Guide for using meta-development script (scripts/dev.js) to manage task-driven development workflows
globs: **/\*
filesToApplyRule: **/\*
alwaysApply: true

---

- **Global CLI Commands**
- Task Master now provides a global CLI through the `task-master` command
- All functionality from `scripts/dev.js` is available through this interface
- Install globally with `npm install -g claude-task-master` or use locally via `npx`
- Use `task-master <command>` instead of `node scripts/dev.js <command>`
- Examples:
  - `task-master list` instead of `node scripts/dev.js list`
  - `task-master next` instead of `node scripts/dev.js next`
  - `task-master expand --id=3` instead of `node scripts/dev.js expand --id=3`
- All commands accept the same options as their script equivalents
- The CLI provides additional commands like `task-master init` for project setup

- **Development Workflow Process**
- Start new projects by running `task-master init` or `node scripts/dev.js parse-prd --input=<prd-file.txt>` to generate initial tasks.json
- Begin coding sessions with `task-master list` to see current tasks, status, and IDs
- Analyze task complexity with `task-master analyze-complexity --research` before breaking down tasks
- Select tasks based on dependencies (all marked 'done'), priority level, and ID order
- Clarify tasks by checking task files in tasks/ directory or asking for user input
- View specific task details using `task-master show <id>` to understand implementation requirements
- Break down complex tasks using `task-master expand --id=<id>` with appropriate flags
- Clear existing subtasks if needed using `task-master clear-subtasks --id=<id>` before regenerating
- Implement code following task details, dependencies, and project standards
- Verify tasks according to test strategies before marking as complete
- Mark completed tasks with `task-master set-status --id=<id> --status=done`
- Update dependent tasks when implementation differs from original plan
- Generate task files with `task-master generate` after updating tasks.json
- Maintain valid dependency structure with `task-master fix-dependencies` when needed
- Respect dependency chains and task priorities when selecting work
- Report progress regularly using the list command

- **Task Complexity Analysis**
- Run `node scripts/dev.js analyze-complexity --research` for comprehensive analysis
- Review complexity report in scripts/task-complexity-report.json
- Or use `node scripts/dev.js complexity-report` for a formatted, readable version of the report
- Focus on tasks with highest complexity scores (8-10) for detailed breakdown
- Use analysis results to determine appropriate subtask allocation
- Note that reports are automatically used by the expand command

- **Task Breakdown Process**
- For tasks with complexity analysis, use `node scripts/dev.js expand --id=<id>`
- Otherwise use `node scripts/dev.js expand --id=<id> --subtasks=<number>`
- Add `--research` flag to leverage Perplexity AI for research-backed expansion
- Use `--prompt="<context>"` to provide additional context when needed
- Review and adjust generated subtasks as necessary
- Use `--all` flag to expand multiple pending tasks at once
- If subtasks need regeneration, clear them first with `clear-subtasks` command

- **Implementation Drift Handling**
- When implementation differs significantly from planned approach
- When future tasks need modification due to current implementation choices
- When new dependencies or requirements emerge
- Call `node scripts/dev.js update --from=<futureTaskId> --prompt="<explanation>"` to update tasks.json

- **Task Status Management**
- Use 'pending' for tasks ready to be worked on
- Use 'done' for completed and verified tasks
- Use 'deferred' for postponed tasks
- Add custom status values as needed for project-specific workflows

- **Task File Format Reference**

```
# Task ID: <id>
# Title: <title>
# Status: <status>
# Dependencies: <comma-separated list of dependency IDs>
# Priority: <priority>
# Description: <brief description>
# Details:
<detailed implementation notes>

# Test Strategy:
<verification approach>
```

- **Command Reference: parse-prd**
- Legacy Syntax: `node scripts/dev.js parse-prd --input=<prd-file.txt>`
- CLI Syntax: `task-master parse-prd --input=<prd-file.txt>`
- Description: Parses a PRD document and generates a tasks.json file with structured tasks
- Parameters:
  - `--input=<file>`: Path to the PRD text file (default: sample-prd.txt)
- Example: `task-master parse-prd --input=requirements.txt`
- Notes: Will overwrite existing tasks.json file. Use with caution.

- **Command Reference: update**
- Legacy Syntax: `node scripts/dev.js update --from=<id> --prompt="<prompt>"`
- CLI Syntax: `task-master update --from=<id> --prompt="<prompt>"`
- Description: Updates tasks with ID >= specified ID based on the provided prompt
- Parameters:
  - `--from=<id>`: Task ID from which to start updating (required)
  - `--prompt="<text>"`: Explanation of changes or new context (required)
- Example: `task-master update --from=4 --prompt="Now we are using Express instead of Fastify."`
- Notes: Only updates tasks not marked as 'done'. Completed tasks remain unchanged.

- **Command Reference: generate**
- Legacy Syntax: `node scripts/dev.js generate`
- CLI Syntax: `task-master generate`
- Description: Generates individual task files in tasks/ directory based on tasks.json
- Parameters:
  - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
  - `--output=<dir>, -o`: Output directory (default: 'tasks')
- Example: `task-master generate`
- Notes: Overwrites existing task files. Creates tasks/ directory if needed.

- **Command Reference: set-status**
- Legacy Syntax: `node scripts/dev.js set-status --id=<id> --status=<status>`
- CLI Syntax: `task-master set-status --id=<id> --status=<status>`
- Description: Updates the status of a specific task in tasks.json
- Parameters:
  - `--id=<id>`: ID of the task to update (required)
  - `--status=<status>`: New status value (required)
- Example: `task-master set-status --id=3 --status=done`
- Notes: Common values are 'done', 'pending', and 'deferred', but any string is accepted.

- **Command Reference: list**
- Legacy Syntax: `node scripts/dev.js list`
- CLI Syntax: `task-master list`
- Description: Lists all tasks in tasks.json with IDs, titles, and status
- Parameters:
  - `--status=<status>, -s`: Filter by status
  - `--with-subtasks`: Show subtasks for each task
  - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
- Example: `task-master list`
- Notes: Provides quick overview of project progress. Use at start of sessions.

- **Command Reference: expand**
- Legacy Syntax: `node scripts/dev.js expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
- CLI Syntax: `task-master expand --id=<id> [--num=<number>] [--research] [--prompt="<context>"]`
- Description: Expands a task with subtasks for detailed implementation
- Parameters:
  - `--id=<id>`: ID of task to expand (required unless using --all)
  - `--all`: Expand all pending tasks, prioritized by complexity
  - `--num=<number>`: Number of subtasks to generate (default: from complexity report)
  - `--research`: Use Perplexity AI for research-backed generation
  - `--prompt="<text>"`: Additional context for subtask generation
  - `--force`: Regenerate subtasks even for tasks that already have them
- Example: `task-master expand --id=3 --num=5 --research --prompt="Focus on security aspects"`
- Notes: Uses complexity report recommendations if available.

- **Command Reference: analyze-complexity**
- Legacy Syntax: `node scripts/dev.js analyze-complexity [options]`
- CLI Syntax: `task-master analyze-complexity [options]`
- Description: Analyzes task complexity and generates expansion recommendations
- Parameters:
  - `--output=<file>, -o`: Output file path (default: scripts/task-complexity-report.json)
  - `--model=<model>, -m`: Override LLM model to use
  - `--threshold=<number>, -t`: Minimum score for expansion recommendation (default: 5)
  - `--file=<path>, -f`: Use alternative tasks.json file
  - `--research, -r`: Use Perplexity AI for research-backed analysis
- Example: `task-master analyze-complexity --research`
- Notes: Report includes complexity scores, recommended subtasks, and tailored prompts.

- **Command Reference: clear-subtasks**
- Legacy Syntax: `node scripts/dev.js clear-subtasks --id=<id>`
- CLI Syntax: `task-master clear-subtasks --id=<id>`
- Description: Removes subtasks from specified tasks to allow regeneration
- Parameters:
  - `--id=<id>`: ID or comma-separated IDs of tasks to clear subtasks from
  - `--all`: Clear subtasks from all tasks
- Examples:
  - `task-master clear-subtasks --id=3`
  - `task-master clear-subtasks --id=1,2,3`
  - `task-master clear-subtasks --all`
- Notes:

  - Task files are automatically regenerated after clearing subtasks
  - Can be combined with expand command to immediately generate new subtasks
  - Works with both parent tasks and individual subtasks

- **Task Structure Fields**
- **id**: Unique identifier for the task (Example: `1`)
- **title**: Brief, descriptive title (Example: `"Initialize Repo"`)
- **description**: Concise summary of what the task involves (Example: `"Create a new repository, set up initial structure."`)
- **status**: Current state of the task (Example: `"pending"`, `"done"`, `"deferred"`)
- **dependencies**: IDs of prerequisite tasks (Example: `[1, 2]`)
  - Dependencies are displayed with status indicators (✅ for completed, ⏱️ for pending)
  - This helps quickly identify which prerequisite tasks are blocking work
- **priority**: Importance level (Example: `"high"`, `"medium"`, `"low"`)
- **details**: In-depth implementation instructions (Example: `"Use GitHub client ID/secret, handle callback, set session token."`)
- **testStrategy**: Verification approach (Example: `"Deploy and call endpoint to confirm 'Hello World' response."`)
- **subtasks**: List of smaller, more specific tasks (Example: `[{"id": 1, "title": "Configure OAuth", ...}]`)

- **Environment Variables Configuration**
- **ANTHROPIC_API_KEY** (Required): Your Anthropic API key for Claude (Example: `ANTHROPIC_API_KEY=sk-ant-api03-...`)
- **MODEL** (Default: `"claude-3-7-sonnet-20250219"`): Claude model to use (Example: `MODEL=claude-3-opus-20240229`)
- **MAX_TOKENS** (Default: `"4000"`): Maximum tokens for responses (Example: `MAX_TOKENS=8000`)
- **TEMPERATURE** (Default: `"0.7"`): Temperature for model responses (Example: `TEMPERATURE=0.5`)
- **DEBUG** (Default: `"false"`): Enable debug logging (Example: `DEBUG=true`)
- **LOG_LEVEL** (Default: `"info"`): Console output level (Example: `LOG_LEVEL=debug`)
- **DEFAULT_SUBTASKS** (Default: `"3"`): Default subtask count (Example: `DEFAULT_SUBTASKS=5`)
- **DEFAULT_PRIORITY** (Default: `"medium"`): Default priority (Example: `DEFAULT_PRIORITY=high`)
- **PROJECT_NAME** (Default: `"MCP SaaS MVP"`): Project name in metadata (Example: `PROJECT_NAME=My Awesome Project`)
- **PROJECT_VERSION** (Default: `"1.0.0"`): Version in metadata (Example: `PROJECT_VERSION=2.1.0`)
- **PERPLEXITY_API_KEY**: For research-backed features (Example: `PERPLEXITY_API_KEY=pplx-...`)
- **PERPLEXITY_MODEL** (Default: `"sonar-medium-online"`): Perplexity model (Example: `PERPLEXITY_MODEL=sonar-large-online`)

- **Determining the Next Task**
- Run `task-master next` to show the next task to work on
- The next command identifies tasks with all dependencies satisfied
- Tasks are prioritized by priority level, dependency count, and ID
- The command shows comprehensive task information including:
  - Basic task details and description
  - Implementation details
  - Subtasks (if they exist)
  - Contextual suggested actions
- Recommended before starting any new development work
- Respects your project's dependency structure
- Ensures tasks are completed in the appropriate sequence
- Provides ready-to-use commands for common task actions

- **Viewing Specific Task Details**
- Run `task-master show <id>` or `task-master show --id=<id>` to view a specific task
- Use dot notation for subtasks: `task-master show 1.2` (shows subtask 2 of task 1)
- Displays comprehensive information similar to the next command, but for a specific task
- For parent tasks, shows all subtasks and their current status
- For subtasks, shows parent task information and relationship
- Provides contextual suggested actions appropriate for the specific task
- Useful for examining task details before implementation or checking status

- **Managing Task Dependencies**
- Use `task-master add-dependency --id=<id> --depends-on=<id>` to add a dependency
- Use `task-master remove-dependency --id=<id> --depends-on=<id>` to remove a dependency
- The system prevents circular dependencies and duplicate dependency entries
- Dependencies are checked for existence before being added or removed
- Task files are automatically regenerated after dependency changes
- Dependencies are visualized with status indicators in task listings and files

- **Command Reference: add-dependency**
- Legacy Syntax: `node scripts/dev.js add-dependency --id=<id> --depends-on=<id>`
- CLI Syntax: `task-master add-dependency --id=<id> --depends-on=<id>`
- Description: Adds a dependency relationship between two tasks
- Parameters:
  - `--id=<id>`: ID of task that will depend on another task (required)
  - `--depends-on=<id>`: ID of task that will become a dependency (required)
- Example: `task-master add-dependency --id=22 --depends-on=21`
- Notes: Prevents circular dependencies and duplicates; updates task files automatically

- **Command Reference: remove-dependency**
- Legacy Syntax: `node scripts/dev.js remove-dependency --id=<id> --depends-on=<id>`
- CLI Syntax: `task-master remove-dependency --id=<id> --depends-on=<id>`
- Description: Removes a dependency relationship between two tasks
- Parameters:
  - `--id=<id>`: ID of task to remove dependency from (required)
  - `--depends-on=<id>`: ID of task to remove as a dependency (required)
- Example: `task-master remove-dependency --id=22 --depends-on=21`
- Notes: Checks if dependency actually exists; updates task files automatically

- **Command Reference: validate-dependencies**
- Legacy Syntax: `node scripts/dev.js validate-dependencies [options]`
- CLI Syntax: `task-master validate-dependencies [options]`
- Description: Checks for and identifies invalid dependencies in tasks.json and task files
- Parameters:
  - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
- Example: `task-master validate-dependencies`
- Notes:

  - Reports all non-existent dependencies and self-dependencies without modifying files
  - Provides detailed statistics on task dependency state
  - Use before fix-dependencies to audit your task structure

- **Command Reference: fix-dependencies**
- Legacy Syntax: `node scripts/dev.js fix-dependencies [options]`
- CLI Syntax: `task-master fix-dependencies [options]`
- Description: Finds and fixes all invalid dependencies in tasks.json and task files
- Parameters:
  - `--file=<path>, -f`: Use alternative tasks.json file (default: 'tasks/tasks.json')
- Example: `task-master fix-dependencies`
- Notes:

  - Removes references to non-existent tasks and subtasks
  - Eliminates self-dependencies (tasks depending on themselves)
  - Regenerates task files with corrected dependencies
  - Provides detailed report of all fixes made

- **Command Reference: complexity-report**
- Legacy Syntax: `node scripts/dev.js complexity-report [options]`
- CLI Syntax: `task-master complexity-report [options]`
- Description: Displays the task complexity analysis report in a formatted, easy-to-read way
- Parameters:
  - `--file=<path>, -f`: Path to the complexity report file (default: 'scripts/task-complexity-report.json')
- Example: `task-master complexity-report`
- Notes:

  - Shows tasks organized by complexity score with recommended actions
  - Provides complexity distribution statistics
  - Displays ready-to-use expansion commands for complex tasks
  - If no report exists, offers to generate one interactively

- **Command Reference: add-task**
- CLI Syntax: `task-master add-task [options]`
- Description: Add a new task to tasks.json using AI
- Parameters:
  - `--file=<path>, -f`: Path to the tasks file (default: 'tasks/tasks.json')
  - `--prompt=<text>, -p`: Description of the task to add (required)
  - `--dependencies=<ids>, -d`: Comma-separated list of task IDs this task depends on
  - `--priority=<priority>`: Task priority (high, medium, low) (default: 'medium')
- Example: `task-master add-task --prompt="Create user authentication using Auth0"`
- Notes: Uses AI to convert description into structured task with appropriate details

- **Command Reference: init**
- CLI Syntax: `task-master init`
- Description: Initialize a new project with Task Master structure
- Parameters: None
- Example: `task-master init`
- Notes:

  - Creates initial project structure with required files
  - Prompts for project settings if not provided
  - Merges with existing files when appropriate
  - Can be used to bootstrap a new Task Master project quickly

- **Code Analysis & Refactoring Techniques**
- **Top-Level Function Search**
  - Use grep pattern matching to find all exported functions across the codebase
  - Command: `grep -E "export (function|const) \w+|function \w+\(|const \w+ = \(|module\.exports" --include="*.js" -r ./`
  - Benefits:
    - Quickly identify all public API functions without reading implementation details
    - Compare functions between files during refactoring (e.g., monolithic to modular structure)
    - Verify all expected functions exist in refactored modules
    - Identify duplicate functionality or naming conflicts
  - Usage examples:
    - When migrating from `scripts/dev.js` to modular structure: `grep -E "function \w+\(" scripts/dev.js`
    - Check function exports in a directory: `grep -E "export (function|const)" scripts/modules/`
    - Find potential naming conflicts: `grep -E "function (get|set|create|update)\w+\(" -r ./`
  - Variations:
    - Add `-n` flag to include line numbers
    - Add `--include="*.ts"` to filter by file extension
    - Use with `| sort` to alphabetize results
  - Integration with refactoring workflow:
    - Start by mapping all functions in the source file
    - Create target module files based on function grouping
    - Verify all functions were properly migrated
    - Check for any unintentional duplications or omissions

---

## WINDSURF_RULES

description: Guidelines for creating and maintaining Windsurf rules to ensure consistency and effectiveness.
globs: .windsurfrules
filesToApplyRule: .windsurfrules
alwaysApply: true

---

The below describes how you should be structuring new rule sections in this document.

- **Required Rule Structure:**

```markdown
---
description: Clear, one-line description of what the rule enforces
globs: path/to/files/*.ext, other/path/**/*
alwaysApply: boolean
---

- **Main Points in Bold**
  - Sub-points with details
  - Examples and explanations
```

- **Section References:**
- Use `ALL_CAPS_SECTION` to reference files
- Example: `WINDSURF_RULES`

- **Code Examples:**
- Use language-specific code blocks

```typescript
// ✅ DO: Show good examples
const goodExample = true;

// ❌ DON'T: Show anti-patterns
const badExample = false;
```

- **Rule Content Guidelines:**
- Start with high-level overview
- Include specific, actionable requirements
- Show examples of correct implementation
- Reference existing code when possible
- Keep rules DRY by referencing other rules

- **Rule Maintenance:**
- Update rules when new patterns emerge
- Add examples from actual codebase
- Remove outdated patterns
- Cross-reference related rules

- **Best Practices:**
- Use bullet points for clarity
- Keep descriptions concise
- Include both DO and DON'T examples
- Reference actual code over theoretical examples
- Use consistent formatting across rules

---

## SELF_IMPROVE

description: Guidelines for continuously improving this rules document based on emerging code patterns and best practices.
globs: **/\*
filesToApplyRule: **/\*
alwaysApply: true

---

- **Rule Improvement Triggers:**
- New code patterns not covered by existing rules
- Repeated similar implementations across files
- Common error patterns that could be prevented
- New libraries or tools being used consistently
- Emerging best practices in the codebase

- **Analysis Process:**
- Compare new code with existing rules
- Identify patterns that should be standardized
- Look for references to external documentation
- Check for consistent error handling patterns
- Monitor test patterns and coverage

- **Rule Updates:**
- **Add New Rules When:**

  - A new technology/pattern is used in 3+ files
  - Common bugs could be prevented by a rule
  - Code reviews repeatedly mention the same feedback
  - New security or performance patterns emerge

- **Modify Existing Rules When:**

  - Better examples exist in the codebase
  - Additional edge cases are discovered
  - Related rules have been updated
  - Implementation details have changed

- **Example Pattern Recognition:**

```typescript
// If you see repeated patterns like:
const data = await prisma.user.findMany({
  select: { id: true, email: true },
  where: { status: 'ACTIVE' },
});

// Consider adding a PRISMA section in the .windsurfrules:
// - Standard select fields
// - Common where conditions
// - Performance optimization patterns
```

- **Rule Quality Checks:**
- Rules should be actionable and specific
- Examples should come from actual code
- References should be up to date
- Patterns should be consistently enforced

- **Continuous Improvement:**
- Monitor code review comments
- Track common development questions
- Update rules after major refactors
- Add links to relevant documentation
- Cross-reference related rules

- **Rule Deprecation:**
- Mark outdated patterns as deprecated
- Remove rules that no longer apply
- Update references to deprecated rules
- Document migration paths for old patterns

- **Documentation Updates:**
- Keep examples synchronized with code
- Update references to external docs
- Maintain links between related rules
- Document breaking changes

Follow WINDSURF_RULES for proper rule formatting and structure of windsurf rule sections.
