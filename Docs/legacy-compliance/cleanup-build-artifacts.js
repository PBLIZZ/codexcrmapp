#!/usr/bin/env node

import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

class BuildArtifactCleaner {
  constructor() {
    this.filesToDelete = [];
    this.isDryRun = true;
  }

  async findBuildArtifacts(directory = process.cwd()) {
    try {
      const entries = await fs.readdir(directory, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(directory, entry.name);
        
        if (entry.isDirectory()) {
          // Skip node_modules and other common directories that shouldn't be cleaned
          if (!['node_modules', '.git', '.next', 'dist', 'build'].includes(entry.name)) {
            await this.findBuildArtifacts(fullPath);
          }
        } else if (entry.isFile()) {
          await this.checkFile(fullPath);
        }
      }
    } catch (error) {
      console.error(`Error reading directory ${directory}:`, error.message);
    }
  }

  async checkFile(filePath) {
    const ext = path.extname(filePath);
    const baseName = path.basename(filePath, ext);
    const directory = path.dirname(filePath);

    if (ext === '.js') {
      // Check if corresponding .ts or .tsx file exists
      const tsPath = path.join(directory, `${baseName}.ts`);
      const tsxPath = path.join(directory, `${baseName}.tsx`);
      
      try {
        const [tsExists, tsxExists] = await Promise.all([
          this.fileExists(tsPath),
          this.fileExists(tsxPath)
        ]);

        if (tsExists || tsxExists) {
          this.filesToDelete.push(filePath);
          
          // Check for corresponding .js.map file
          const mapPath = `${filePath}.map`;
          if (await this.fileExists(mapPath)) {
            this.filesToDelete.push(mapPath);
          }
        }
      } catch (error) {
        console.error(`Error checking file ${filePath}:`, error.message);
      }
    } else if (ext === '.jsx') {
      // Check if corresponding .tsx file exists
      const tsxPath = path.join(directory, `${baseName}.tsx`);
      
      try {
        if (await this.fileExists(tsxPath)) {
          this.filesToDelete.push(filePath);
          
          // Check for corresponding .jsx.map file
          const mapPath = `${filePath}.map`;
          if (await this.fileExists(mapPath)) {
            this.filesToDelete.push(mapPath);
          }
        }
      } catch (error) {
        console.error(`Error checking file ${filePath}:`, error.message);
      }
    }
  }

  async fileExists(filePath) {
    try {
      await fs.access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  async execute() {
    if (this.isDryRun) {
      console.log('\nðŸ” [DRY RUN] The following files would be deleted:\n');
      
      if (this.filesToDelete.length === 0) {
        console.log('âœ… No build artifacts found to clean up.');
        return;
      }

      for (const file of this.filesToDelete) {
        console.log(`[DRY RUN] Would delete: ${file}`);
      }
      
      console.log(`\nðŸ“Š Summary: Found ${this.filesToDelete.length} files to delete.`);
      console.log('\nðŸ’¡ To actually delete these files, run with --execute flag:');
      console.log('   node cleanup-build-artifacts.js --execute');
    } else {
      console.log('\nðŸ—‘ï¸  Deleting build artifacts...\n');
      
      if (this.filesToDelete.length === 0) {
        console.log('âœ… No build artifacts found to clean up.');
        return;
      }

      let deletedCount = 0;
      let failedCount = 0;

      for (const file of this.filesToDelete) {
        try {
          await fs.unlink(file);
          console.log(`âœ“ Deleted: ${file}`);
          deletedCount++;
        } catch (error) {
          console.error(`âœ— Failed to delete ${file}:`, error.message);
          failedCount++;
        }
      }

      console.log(`\nðŸ“Š Summary: Deleted ${deletedCount} files successfully.`);
      if (failedCount > 0) {
        console.log(`âš ï¸  Failed to delete ${failedCount} files.`);
      }
    }
  }

  setExecuteMode(execute) {
    this.isDryRun = !execute;
  }
}

async function main() {
  const args = process.argv.slice(2);
  const executeMode = args.includes('--execute') || args.includes('--delete');
  const helpRequested = args.includes('--help') || args.includes('-h');

  if (helpRequested) {
    console.log(`
ðŸ§¹ TypeScript Build Artifact Cleaner

This script safely removes JavaScript files (.js, .jsx) and their source maps
(.js.map) that were generated by TypeScript compilation when they have 
corresponding TypeScript source files.

Usage:
  node cleanup-build-artifacts.js           # Dry run (safe, shows what would be deleted)
  node cleanup-build-artifacts.js --execute # Actually delete the files
  node cleanup-build-artifacts.js --help    # Show this help

Safety Features:
- Runs in dry-run mode by default
- Only deletes .js/.jsx files that have corresponding .ts/.tsx files
- Recursively searches all subdirectories (except node_modules, .git, etc.)
- Provides detailed output of all operations

Examples:
  # See what files would be deleted (safe)
  node cleanup-build-artifacts.js

  # Actually delete the files
  node cleanup-build-artifacts.js --execute
`);
    return;
  }

  console.log('ðŸ§¹ TypeScript Build Artifact Cleaner');
  console.log('=====================================');

  const cleaner = new BuildArtifactCleaner();
  cleaner.setExecuteMode(executeMode);

  console.log(`\nðŸ” Scanning for build artifacts in: ${process.cwd()}`);
  console.log(`ðŸ“‹ Mode: ${executeMode ? 'EXECUTE' : 'DRY RUN'}`);

  try {
    await cleaner.findBuildArtifacts();
    await cleaner.execute();
  } catch (error) {
    console.error('\nâŒ An error occurred:', error.message);
    process.exit(1);
  }

  console.log('\nâœ… Cleanup completed!');
}

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

main().catch(console.error);